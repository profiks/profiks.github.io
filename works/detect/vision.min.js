(function() {
    function resolve() {
        document.body.removeAttribute("unresolved")
    }
    if (window.WebComponents)
        addEventListener("WebComponentsReady", resolve);
    else if (document.readyState === "interactive" || document.readyState === "complete")
        resolve();
    else
        addEventListener("DOMContentLoaded", resolve)
}
)();
window.Polymer = {
    Settings: function() {
        var settings = window.Polymer || {};
        if (!settings.noUrlSettings) {
            var parts = location.search.slice(1).split("&");
            for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
                o = o.split("=");
                o[0] && (settings[o[0]] = o[1] || true)
            }
        }
        settings.wantShadow = settings.dom === "shadow";
        settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
        settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
        settings.useShadow = settings.wantShadow && settings.hasShadow;
        settings.hasNativeImports = Boolean("import"in document.createElement("link"));
        settings.useNativeImports = settings.hasNativeImports;
        settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
        settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
        settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
        settings.hasNativeCSSProperties = !navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports("box-shadow", "0 0 0 var(--foo)");
        settings.useNativeCSSProperties = settings.hasNativeCSSProperties && settings.lazyRegister && settings.useNativeCSSProperties;
        settings.isIE = navigator.userAgent.match("Trident");
        settings.passiveTouchGestures = settings.passiveTouchGestures || false;
        return settings
    }()
};
(function() {
    var userPolymer = window.Polymer;
    window.Polymer = function(prototype) {
        if (typeof prototype === "function")
            prototype = prototype.prototype;
        if (!prototype)
            prototype = {};
        prototype = desugar(prototype);
        var customCtor = prototype === prototype.constructor.prototype ? prototype.constructor : null;
        var options = {
            prototype: prototype
        };
        if (prototype["extends"])
            options["extends"] = prototype["extends"];
        Polymer.telemetry._registrate(prototype);
        var ctor = document.registerElement(prototype.is, options);
        return customCtor || ctor
    }
    ;
    var desugar = function(prototype) {
        var base = Polymer.Base;
        if (prototype["extends"])
            base = Polymer.Base._getExtendedPrototype(prototype["extends"]);
        prototype = Polymer.Base.chainObject(prototype, base);
        prototype.registerCallback();
        return prototype
    };
    if (userPolymer)
        for (var i in userPolymer)
            Polymer[i] = userPolymer[i];
    Polymer.Class = function(prototype) {
        if (!prototype.factoryImpl)
            prototype.factoryImpl = function() {}
            ;
        return desugar(prototype).constructor
    }
}
)();
Polymer.telemetry = {
    registrations: [],
    _regLog: function(prototype) {
        console.log("[" + prototype.is + "]: registered")
    },
    _registrate: function(prototype) {
        this.registrations.push(prototype);
        Polymer.log && this._regLog(prototype)
    },
    dumpRegistrations: function() {
        this.registrations.forEach(this._regLog)
    }
};
Object.defineProperty(window, "currentImport", {
    enumerable: true,
    configurable: true,
    get: function() {
        return (document._currentScript || document.currentScript || {}).ownerDocument
    }
});
Polymer.RenderStatus = {
    _ready: false,
    _callbacks: [],
    whenReady: function(cb) {
        if (this._ready)
            cb();
        else
            this._callbacks.push(cb)
    },
    _makeReady: function() {
        this._ready = true;
        for (var i = 0; i < this._callbacks.length; i++)
            this._callbacks[i]();
        this._callbacks = []
    },
    _catchFirstRender: function() {
        requestAnimationFrame(function() {
            Polymer.RenderStatus._makeReady()
        })
    },
    _afterNextRenderQueue: [],
    _waitingNextRender: false,
    afterNextRender: function(element, fn, args) {
        this._watchNextRender();
        this._afterNextRenderQueue.push([element, fn, args])
    },
    hasRendered: function() {
        return this._ready
    },
    _watchNextRender: function() {
        if (!this._waitingNextRender) {
            this._waitingNextRender = true;
            var fn = function() {
                Polymer.RenderStatus._flushNextRender()
            };
            if (!this._ready)
                this.whenReady(fn);
            else
                requestAnimationFrame(fn)
        }
    },
    _flushNextRender: function() {
        var self = this;
        setTimeout(function() {
            self._flushRenderCallbacks(self._afterNextRenderQueue);
            self._afterNextRenderQueue = [];
            self._waitingNextRender = false
        })
    },
    _flushRenderCallbacks: function(callbacks) {
        for (var i = 0, h; i < callbacks.length; i++) {
            h = callbacks[i];
            h[1].apply(h[0], h[2] || Polymer.nar)
        }
    }
};
if (window.HTMLImports)
    HTMLImports.whenReady(function() {
        Polymer.RenderStatus._catchFirstRender()
    });
else
    Polymer.RenderStatus._catchFirstRender();
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;
(function() {
    var settings = Polymer.Settings;
    Polymer.Base = {
        __isPolymerInstance__: true,
        _addFeature: function(feature) {
            this.mixin(this, feature)
        },
        registerCallback: function() {
            if (settings.lazyRegister === "max") {
                if (this.beforeRegister)
                    this.beforeRegister()
            } else {
                this._desugarBehaviors();
                for (var i = 0, b; i < this.behaviors.length; i++) {
                    b = this.behaviors[i];
                    if (b.beforeRegister)
                        b.beforeRegister.call(this)
                }
                if (this.beforeRegister)
                    this.beforeRegister()
            }
            this._registerFeatures();
            if (!settings.lazyRegister)
                this.ensureRegisterFinished()
        },
        createdCallback: function() {
            if (settings.disableUpgradeEnabled)
                if (this.hasAttribute("disable-upgrade")) {
                    this._propertySetter = disableUpgradePropertySetter;
                    this._configValue = null;
                    this.__data__ = {};
                    return
                } else
                    this.__hasInitialized = true;
            this.__initialize()
        },
        __initialize: function() {
            if (!this.__hasRegisterFinished)
                this._ensureRegisterFinished(this.__proto__);
            Polymer.telemetry.instanceCount++;
            this.root = this;
            for (var i = 0, b; i < this.behaviors.length; i++) {
                b = this.behaviors[i];
                if (b.created)
                    b.created.call(this)
            }
            if (this.created)
                this.created();
            this._initFeatures()
        },
        ensureRegisterFinished: function() {
            this._ensureRegisterFinished(this)
        },
        _ensureRegisterFinished: function(proto) {
            if (proto.__hasRegisterFinished !== proto.is || !proto.is) {
                if (settings.lazyRegister === "max") {
                    proto._desugarBehaviors();
                    for (var i = 0, b; i < proto.behaviors.length; i++) {
                        b = proto.behaviors[i];
                        if (b.beforeRegister)
                            b.beforeRegister.call(proto)
                    }
                }
                proto.__hasRegisterFinished = proto.is;
                if (proto._finishRegisterFeatures)
                    proto._finishRegisterFeatures();
                for (var j = 0, pb; j < proto.behaviors.length; j++) {
                    pb = proto.behaviors[j];
                    if (pb.registered)
                        pb.registered.call(proto)
                }
                if (proto.registered)
                    proto.registered();
                if (settings.usePolyfillProto && proto !== this)
                    proto.extend(this, proto)
            }
        },
        attachedCallback: function() {
            var self = this;
            Polymer.RenderStatus.whenReady(function() {
                self.isAttached = true;
                for (var i = 0, b; i < self.behaviors.length; i++) {
                    b = self.behaviors[i];
                    if (b.attached)
                        b.attached.call(self)
                }
                if (self.attached)
                    self.attached()
            })
        },
        detachedCallback: function() {
            var self = this;
            Polymer.RenderStatus.whenReady(function() {
                self.isAttached = false;
                for (var i = 0, b; i < self.behaviors.length; i++) {
                    b = self.behaviors[i];
                    if (b.detached)
                        b.detached.call(self)
                }
                if (self.detached)
                    self.detached()
            })
        },
        attributeChangedCallback: function(name, oldValue, newValue) {
            this._attributeChangedImpl(name);
            for (var i = 0, b; i < this.behaviors.length; i++) {
                b = this.behaviors[i];
                if (b.attributeChanged)
                    b.attributeChanged.call(this, name, oldValue, newValue)
            }
            if (this.attributeChanged)
                this.attributeChanged(name, oldValue, newValue)
        },
        _attributeChangedImpl: function(name) {
            this._setAttributeToProperty(this, name)
        },
        extend: function(target, source) {
            if (target && source) {
                var n$ = Object.getOwnPropertyNames(source);
                for (var i = 0, n; i < n$.length && (n = n$[i]); i++)
                    this.copyOwnProperty(n, source, target)
            }
            return target || source
        },
        mixin: function(target, source) {
            for (var i in source)
                target[i] = source[i];
            return target
        },
        copyOwnProperty: function(name, source, target) {
            var pd = Object.getOwnPropertyDescriptor(source, name);
            if (pd)
                Object.defineProperty(target, name, pd)
        },
        _logger: function(level, args) {
            if (args.length === 1 && Array.isArray(args[0]))
                args = args[0];
            switch (level) {
            case "log":
            case "warn":
            case "error":
                console[level].apply(console, args);
                break
            }
        },
        _log: function() {
            var args = Array.prototype.slice.call(arguments, 0);
            this._logger("log", args)
        },
        _warn: function() {
            var args = Array.prototype.slice.call(arguments, 0);
            this._logger("warn", args)
        },
        _error: function() {
            var args = Array.prototype.slice.call(arguments, 0);
            this._logger("error", args)
        },
        _logf: function() {
            return this._logPrefix.concat(this.is).concat(Array.prototype.slice.call(arguments, 0))
        }
    };
    Polymer.Base._logPrefix = function() {
        var color = window.chrome && !/edge/i.test(navigator.userAgent) || /firefox/i.test(navigator.userAgent);
        return color ? ["%c[%s::%s]:", "font-weight: bold; background-color:#EEEE00;"] : ["[%s::%s]:"]
    }();
    Polymer.Base.chainObject = function(object, inherited) {
        if (object && inherited && object !== inherited) {
            if (!Object.__proto__)
                object = Polymer.Base.extend(Object.create(inherited), object);
            object.__proto__ = inherited
        }
        return object
    }
    ;
    Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
    Polymer.BaseDescriptors = {};
    var disableUpgradePropertySetter;
    if (settings.disableUpgradeEnabled) {
        disableUpgradePropertySetter = function(property, value) {
            this.__data__[property] = value
        }
        ;
        var origAttributeChangedCallback = Polymer.Base.attributeChangedCallback;
        Polymer.Base.attributeChangedCallback = function(name, oldValue, newValue) {
            if (!this.__hasInitialized && name === "disable-upgrade") {
                this.__hasInitialized = true;
                this._propertySetter = Polymer.Bind._modelApi._propertySetter;
                this._configValue = Polymer.Base._configValue;
                this.__initialize()
            }
            origAttributeChangedCallback.call(this, name, oldValue, newValue)
        }
    }
    if (window.CustomElements)
        Polymer["instanceof"] = CustomElements["instanceof"];
    else
        Polymer["instanceof"] = function(obj, ctor) {
            return obj instanceof ctor
        }
        ;
    Polymer.isInstance = function(obj) {
        return Boolean(obj && obj.__isPolymerInstance__)
    }
    ;
    Polymer.telemetry.instanceCount = 0
}
)();
(function() {
    var modules = {};
    var lcModules = {};
    var findModule = function(id) {
        return modules[id] || lcModules[id.toLowerCase()]
    };
    var DomModule = function() {
        return document.createElement("dom-module")
    };
    DomModule.prototype = Object.create(HTMLElement.prototype);
    Polymer.Base.mixin(DomModule.prototype, {
        createdCallback: function() {
            this.register()
        },
        register: function(id) {
            id = id || this.id || this.getAttribute("name") || this.getAttribute("is");
            if (id) {
                this.id = id;
                modules[id] = this;
                lcModules[id.toLowerCase()] = this
            }
        },
        "import": function(id, selector) {
            if (id) {
                var m = findModule(id);
                if (!m) {
                    forceDomModulesUpgrade();
                    m = findModule(id)
                }
                if (m && selector)
                    m = m.querySelector(selector);
                return m
            }
        }
    });
    Object.defineProperty(DomModule.prototype, "constructor", {
        value: DomModule,
        configurable: true,
        writable: true
    });
    var cePolyfill = window.CustomElements && !CustomElements.useNative;
    document.registerElement("dom-module", DomModule);
    function forceDomModulesUpgrade() {
        if (cePolyfill) {
            var script = document._currentScript || document.currentScript;
            var doc = script && script.ownerDocument || document;
            var modules = doc.querySelectorAll("dom-module");
            for (var i = modules.length - 1, m; i >= 0 && (m = modules[i]); i--)
                if (m.__upgraded__)
                    return;
                else
                    CustomElements.upgrade(m)
        }
    }
}
)();
Polymer.Base._addFeature({
    _prepIs: function() {
        if (!this.is) {
            var module = (document._currentScript || document.currentScript).parentNode;
            if (module.localName === "dom-module") {
                var id = module.id || module.getAttribute("name") || module.getAttribute("is");
                this.is = id
            }
        }
        if (this.is)
            this.is = this.is.toLowerCase()
    }
});
Polymer.Base._addFeature({
    behaviors: [],
    _desugarBehaviors: function() {
        if (this.behaviors.length)
            this.behaviors = this._desugarSomeBehaviors(this.behaviors)
    },
    _desugarSomeBehaviors: function(behaviors) {
        var behaviorSet = [];
        behaviors = this._flattenBehaviorsList(behaviors);
        for (var i = behaviors.length - 1; i >= 0; i--) {
            var b = behaviors[i];
            if (behaviorSet.indexOf(b) === -1) {
                this._mixinBehavior(b);
                behaviorSet.unshift(b)
            }
        }
        return behaviorSet
    },
    _flattenBehaviorsList: function(behaviors) {
        var flat = [];
        for (var i = 0; i < behaviors.length; i++) {
            var b = behaviors[i];
            if (b instanceof Array)
                flat = flat.concat(this._flattenBehaviorsList(b));
            else if (b)
                flat.push(b);
            else
                this._warn(this._logf("_flattenBehaviorsList", "behavior is null, check for missing or 404 import"))
        }
        return flat
    },
    _mixinBehavior: function(b) {
        var n$ = Object.getOwnPropertyNames(b);
        var useAssignment = b._noAccessors;
        for (var i = 0, n; i < n$.length && (n = n$[i]); i++)
            if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n))
                if (useAssignment)
                    this[n] = b[n];
                else
                    this.copyOwnProperty(n, b, this)
    },
    _prepBehaviors: function() {
        this._prepFlattenedBehaviors(this.behaviors)
    },
    _prepFlattenedBehaviors: function(behaviors) {
        for (var i = 0, l = behaviors.length; i < l; i++)
            this._prepBehavior(behaviors[i]);
        this._prepBehavior(this)
    },
    _marshalBehaviors: function() {
        for (var i = 0; i < this.behaviors.length; i++)
            this._marshalBehavior(this.behaviors[i]);
        this._marshalBehavior(this)
    }
});
Polymer.Base._behaviorProperties = {
    hostAttributes: true,
    beforeRegister: true,
    registered: true,
    properties: true,
    observers: true,
    listeners: true,
    created: true,
    attached: true,
    detached: true,
    attributeChanged: true,
    ready: true,
    _noAccessors: true
};
Polymer.Base._addFeature({
    _getExtendedPrototype: function(tag) {
        return this._getExtendedNativePrototype(tag)
    },
    _nativePrototypes: {},
    _getExtendedNativePrototype: function(tag) {
        var p = this._nativePrototypes[tag];
        if (!p) {
            p = Object.create(this.getNativePrototype(tag));
            var p$ = Object.getOwnPropertyNames(Polymer.Base);
            for (var i = 0, n; i < p$.length && (n = p$[i]); i++)
                if (!Polymer.BaseDescriptors[n])
                    p[n] = Polymer.Base[n];
            Object.defineProperties(p, Polymer.BaseDescriptors);
            this._nativePrototypes[tag] = p
        }
        return p
    },
    getNativePrototype: function(tag) {
        return Object.getPrototypeOf(document.createElement(tag))
    }
});
Polymer.Base._addFeature({
    _prepConstructor: function() {
        this._factoryArgs = this["extends"] ? [this["extends"], this.is] : [this.is];
        var ctor = function() {
            return this._factory(arguments)
        };
        if (this.hasOwnProperty("extends"))
            ctor["extends"] = this["extends"];
        Object.defineProperty(this, "constructor", {
            value: ctor,
            writable: true,
            configurable: true
        });
        ctor.prototype = this
    },
    _factory: function(args) {
        var elt = document.createElement.apply(document, this._factoryArgs);
        if (this.factoryImpl)
            this.factoryImpl.apply(elt, args);
        return elt
    }
});
Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
    getPropertyInfo: function(property) {
        var info = this._getPropertyInfo(property, this.properties);
        if (!info)
            for (var i = 0; i < this.behaviors.length; i++) {
                info = this._getPropertyInfo(property, this.behaviors[i].properties);
                if (info)
                    return info
            }
        return info || Polymer.nob
    },
    _getPropertyInfo: function(property, properties) {
        var p = properties && properties[property];
        if (typeof p === "function")
            p = properties[property] = {
                type: p
            };
        if (p)
            p.defined = true;
        return p
    },
    _prepPropertyInfo: function() {
        this._propertyInfo = {};
        for (var i = 0; i < this.behaviors.length; i++)
            this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
        this._addPropertyInfo(this._propertyInfo, this.properties);
        this._addPropertyInfo(this._propertyInfo, this._propertyEffects)
    },
    _addPropertyInfo: function(target, source) {
        if (source) {
            var t, s;
            for (var i in source) {
                t = target[i];
                s = source[i];
                if (i[0] === "_" && !s.readOnly)
                    continue;
                if (!target[i])
                    target[i] = {
                        type: typeof s === "function" ? s : s.type,
                        readOnly: s.readOnly,
                        attribute: Polymer.CaseMap.camelToDashCase(i)
                    };
                else {
                    if (!t.type)
                        t.type = s.type;
                    if (!t.readOnly)
                        t.readOnly = s.readOnly
                }
            }
        }
    }
});
(function() {
    var propertiesDesc = {
        configurable: true,
        writable: true,
        enumerable: true,
        value: {}
    };
    Polymer.BaseDescriptors.properties = propertiesDesc;
    Object.defineProperty(Polymer.Base, "properties", propertiesDesc)
}
)();
Polymer.CaseMap = {
    _caseMap: {},
    _rx: {
        dashToCamel: /-[a-z]/g,
        camelToDash: /([A-Z])/g
    },
    dashToCamelCase: function(dash) {
        return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf("-") < 0 ? dash : dash.replace(this._rx.dashToCamel, function(m) {
            return m[1].toUpperCase()
        }))
    },
    camelToDashCase: function(camel) {
        return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, "-$1").toLowerCase())
    }
};
Polymer.Base._addFeature({
    _addHostAttributes: function(attributes) {
        if (!this._aggregatedAttributes)
            this._aggregatedAttributes = {};
        if (attributes)
            this.mixin(this._aggregatedAttributes, attributes)
    },
    _marshalHostAttributes: function() {
        if (this._aggregatedAttributes)
            this._applyAttributes(this, this._aggregatedAttributes)
    },
    _applyAttributes: function(node, attr$) {
        for (var n in attr$)
            if (!this.hasAttribute(n) && n !== "class") {
                var v = attr$[n];
                this.serializeValueToAttribute(v, n, this)
            }
    },
    _marshalAttributes: function() {
        this._takeAttributesToModel(this)
    },
    _takeAttributesToModel: function(model) {
        if (this.hasAttributes())
            for (var i in this._propertyInfo) {
                var info = this._propertyInfo[i];
                if (this.hasAttribute(info.attribute))
                    this._setAttributeToProperty(model, info.attribute, i, info)
            }
    },
    _setAttributeToProperty: function(model, attribute, property, info) {
        if (!this._serializing) {
            property = property || Polymer.CaseMap.dashToCamelCase(attribute);
            info = info || this._propertyInfo && this._propertyInfo[property];
            if (info && !info.readOnly) {
                var v = this.getAttribute(attribute);
                model[property] = this.deserialize(v, info.type)
            }
        }
    },
    _serializing: false,
    reflectPropertyToAttribute: function(property, attribute, value) {
        this._serializing = true;
        value = value === undefined ? this[property] : value;
        this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
        this._serializing = false
    },
    serializeValueToAttribute: function(value, attribute, node) {
        var str = this.serialize(value);
        node = node || this;
        if (str === undefined)
            node.removeAttribute(attribute);
        else
            node.setAttribute(attribute, str)
    },
    deserialize: function(value, type) {
        switch (type) {
        case Number:
            value = Number(value);
            break;
        case Boolean:
            value = value != null;
            break;
        case Object:
            try {
                value = JSON.parse(value)
            } catch (x) {}
            break;
        case Array:
            try {
                value = JSON.parse(value)
            } catch (x$0) {
                value = null;
                console.warn("Polymer::Attributes: couldn`t decode Array as JSON")
            }
            break;
        case Date:
            value = new Date(value);
            break;
        case String:
        default:
            break
        }
        return value
    },
    serialize: function(value) {
        switch (typeof value) {
        case "boolean":
            return value ? "" : undefined;
        case "object":
            if (value instanceof Date)
                return value.toString();
            else if (value)
                try {
                    return JSON.stringify(value)
                } catch (x) {
                    return ""
                }
        default:
            return value != null ? value : undefined
        }
    }
});
Polymer.version = "1.11.0";
Polymer.Base._addFeature({
    _registerFeatures: function() {
        this._prepIs();
        this._prepBehaviors();
        this._prepConstructor();
        this._prepPropertyInfo()
    },
    _prepBehavior: function(b) {
        this._addHostAttributes(b.hostAttributes)
    },
    _marshalBehavior: function(b) {},
    _initFeatures: function() {
        this._marshalHostAttributes();
        this._marshalBehaviors()
    }
});
(function() {
    function resolveCss(cssText, ownerDocument) {
        return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
            return pre + "'" + resolve(url.replace(/["']/g, ""), ownerDocument) + "'" + post
        })
    }
    function resolveAttrs(element, ownerDocument) {
        for (var name in URL_ATTRS) {
            var a$ = URL_ATTRS[name];
            for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++)
                if (name === "*" || element.localName === name) {
                    at = element.attributes[a];
                    v = at && at.value;
                    if (v && v.search(BINDING_RX) < 0)
                        at.value = a === "style" ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument)
                }
        }
    }
    function resolve(url, ownerDocument) {
        if (url && ABS_URL.test(url))
            return url;
        var resolver = getUrlResolver(ownerDocument);
        resolver.href = url;
        return resolver.href || url
    }
    var tempDoc;
    var tempDocBase;
    function resolveUrl(url, baseUri) {
        if (!tempDoc) {
            tempDoc = document.implementation.createHTMLDocument("temp");
            tempDocBase = tempDoc.createElement("base");
            tempDoc.head.appendChild(tempDocBase)
        }
        tempDocBase.href = baseUri;
        return resolve(url, tempDoc)
    }
    function getUrlResolver(ownerDocument) {
        return ownerDocument.body.__urlResolver || (ownerDocument.body.__urlResolver = ownerDocument.createElement("a"))
    }
    function pathFromUrl(url) {
        return url.substring(0, url.lastIndexOf("/") + 1)
    }
    var CSS_URL_RX = /(url\()([^)]*)(\))/g;
    var URL_ATTRS = {
        "*": ["href", "src", "style", "url"],
        form: ["action"]
    };
    var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
    var BINDING_RX = /\{\{|\[\[/;
    Polymer.ResolveUrl = {
        resolveCss: resolveCss,
        resolveAttrs: resolveAttrs,
        resolveUrl: resolveUrl,
        pathFromUrl: pathFromUrl
    };
    Polymer.rootPath = Polymer.Settings.rootPath || pathFromUrl(document.baseURI || window.location.href)
}
)();
Polymer.Base._addFeature({
    _prepTemplate: function() {
        var module;
        if (this._template === undefined) {
            module = Polymer.DomModule["import"](this.is);
            this._template = module && module.querySelector("template")
        }
        if (module) {
            var assetPath = module.getAttribute("assetpath") || "";
            var importURL = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
            this._importPath = Polymer.ResolveUrl.pathFromUrl(importURL)
        } else
            this._importPath = "";
        if (this._template && this._template.hasAttribute("is"))
            this._warn(this._logf("_prepTemplate", "top-level Polymer template " + "must not be a type-extension, found", this._template, "Move inside simple <template>."));
        if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate)
            HTMLTemplateElement.decorate(this._template)
    },
    _stampTemplate: function() {
        if (this._template)
            this.root = this.instanceTemplate(this._template)
    },
    instanceTemplate: function(template) {
        var dom = document.importNode(template._content || template.content, true);
        return dom
    }
});
(function() {
    var baseAttachedCallback = Polymer.Base.attachedCallback;
    var baseDetachedCallback = Polymer.Base.detachedCallback;
    Polymer.Base._addFeature({
        _hostStack: [],
        ready: function() {},
        _registerHost: function(host) {
            this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
            if (host && host._clients)
                host._clients.push(this);
            this._clients = null;
            this._clientsReadied = false
        },
        _beginHosting: function() {
            Polymer.Base._hostStack.push(this);
            if (!this._clients)
                this._clients = []
        },
        _endHosting: function() {
            Polymer.Base._hostStack.pop()
        },
        _tryReady: function() {
            this._readied = false;
            if (this._canReady())
                this._ready()
        },
        _canReady: function() {
            return !this.dataHost || this.dataHost._clientsReadied
        },
        _ready: function() {
            this._beforeClientsReady();
            if (this._template) {
                this._setupRoot();
                this._readyClients()
            }
            this._clientsReadied = true;
            this._clients = null;
            this._afterClientsReady();
            this._readySelf()
        },
        _readyClients: function() {
            this._beginDistribute();
            var c$ = this._clients;
            if (c$)
                for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++)
                    c._ready();
            this._finishDistribute()
        },
        _readySelf: function() {
            for (var i = 0, b; i < this.behaviors.length; i++) {
                b = this.behaviors[i];
                if (b.ready)
                    b.ready.call(this)
            }
            if (this.ready)
                this.ready();
            this._readied = true;
            if (this._attachedPending) {
                this._attachedPending = false;
                this.attachedCallback()
            }
        },
        _beforeClientsReady: function() {},
        _afterClientsReady: function() {},
        _beforeAttached: function() {},
        attachedCallback: function() {
            if (this._readied) {
                this._beforeAttached();
                baseAttachedCallback.call(this)
            } else
                this._attachedPending = true
        },
        detachedCallback: function() {
            if (this._readied)
                baseDetachedCallback.call(this);
            else
                this._attachedPending = false
        }
    })
}
)();
Polymer.ArraySplice = function() {
    function newSplice(index, removed, addedCount) {
        return {
            index: index,
            removed: removed,
            addedCount: addedCount
        }
    }
    var EDIT_LEAVE = 0;
    var EDIT_UPDATE = 1;
    var EDIT_ADD = 2;
    var EDIT_DELETE = 3;
    function ArraySplice() {}
    ArraySplice.prototype = {
        calcEditDistances: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {
            var rowCount = oldEnd - oldStart + 1;
            var columnCount = currentEnd - currentStart + 1;
            var distances = new Array(rowCount);
            for (var i = 0; i < rowCount; i++) {
                distances[i] = new Array(columnCount);
                distances[i][0] = i
            }
            for (var j = 0; j < columnCount; j++)
                distances[0][j] = j;
            for (i = 1; i < rowCount; i++)
                for (j = 1; j < columnCount; j++)
                    if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
                        distances[i][j] = distances[i - 1][j - 1];
                    else {
                        var north = distances[i - 1][j] + 1;
                        var west = distances[i][j - 1] + 1;
                        distances[i][j] = north < west ? north : west
                    }
            return distances
        },
        spliceOperationsFromEditDistances: function(distances) {
            var i = distances.length - 1;
            var j = distances[0].length - 1;
            var current = distances[i][j];
            var edits = [];
            while (i > 0 || j > 0) {
                if (i == 0) {
                    edits.push(EDIT_ADD);
                    j--;
                    continue
                }
                if (j == 0) {
                    edits.push(EDIT_DELETE);
                    i--;
                    continue
                }
                var northWest = distances[i - 1][j - 1];
                var west = distances[i - 1][j];
                var north = distances[i][j - 1];
                var min;
                if (west < north)
                    min = west < northWest ? west : northWest;
                else
                    min = north < northWest ? north : northWest;
                if (min == northWest) {
                    if (northWest == current)
                        edits.push(EDIT_LEAVE);
                    else {
                        edits.push(EDIT_UPDATE);
                        current = northWest
                    }
                    i--;
                    j--
                } else if (min == west) {
                    edits.push(EDIT_DELETE);
                    i--;
                    current = west
                } else {
                    edits.push(EDIT_ADD);
                    j--;
                    current = north
                }
            }
            edits.reverse();
            return edits
        },
        calcSplices: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {
            var prefixCount = 0;
            var suffixCount = 0;
            var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
            if (currentStart == 0 && oldStart == 0)
                prefixCount = this.sharedPrefix(current, old, minLength);
            if (currentEnd == current.length && oldEnd == old.length)
                suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
            currentStart += prefixCount;
            oldStart += prefixCount;
            currentEnd -= suffixCount;
            oldEnd -= suffixCount;
            if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
                return [];
            if (currentStart == currentEnd) {
                var splice = newSplice(currentStart, [], 0);
                while (oldStart < oldEnd)
                    splice.removed.push(old[oldStart++]);
                return [splice]
            } else if (oldStart == oldEnd)
                return [newSplice(currentStart, [], currentEnd - currentStart)];
            var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
            splice = undefined;
            var splices = [];
            var index = currentStart;
            var oldIndex = oldStart;
            for (var i = 0; i < ops.length; i++)
                switch (ops[i]) {
                case EDIT_LEAVE:
                    if (splice) {
                        splices.push(splice);
                        splice = undefined
                    }
                    index++;
                    oldIndex++;
                    break;
                case EDIT_UPDATE:
                    if (!splice)
                        splice = newSplice(index, [], 0);
                    splice.addedCount++;
                    index++;
                    splice.removed.push(old[oldIndex]);
                    oldIndex++;
                    break;
                case EDIT_ADD:
                    if (!splice)
                        splice = newSplice(index, [], 0);
                    splice.addedCount++;
                    index++;
                    break;
                case EDIT_DELETE:
                    if (!splice)
                        splice = newSplice(index, [], 0);
                    splice.removed.push(old[oldIndex]);
                    oldIndex++;
                    break
                }
            if (splice)
                splices.push(splice);
            return splices
        },
        sharedPrefix: function(current, old, searchLength) {
            for (var i = 0; i < searchLength; i++)
                if (!this.equals(current[i], old[i]))
                    return i;
            return searchLength
        },
        sharedSuffix: function(current, old, searchLength) {
            var index1 = current.length;
            var index2 = old.length;
            var count = 0;
            while (count < searchLength && this.equals(current[--index1], old[--index2]))
                count++;
            return count
        },
        calculateSplices: function(current, previous) {
            return this.calcSplices(current, 0, current.length, previous, 0, previous.length)
        },
        equals: function(currentValue, previousValue) {
            return currentValue === previousValue
        }
    };
    return new ArraySplice
}();
Polymer.domInnerHTML = function() {
    var escapeAttrRegExp = /[&\u00A0"]/g;
    var escapeDataRegExp = /[&\u00A0<>]/g;
    function escapeReplace(c) {
        switch (c) {
        case "&":
            return "&amp;";
        case "<":
            return "&lt;";
        case ">":
            return "&gt;";
        case '"':
            return "&quot;";
        case "\u00a0":
            return "&nbsp;"
        }
    }
    function escapeAttr(s) {
        return s.replace(escapeAttrRegExp, escapeReplace)
    }
    function escapeData(s) {
        return s.replace(escapeDataRegExp, escapeReplace)
    }
    function makeSet(arr) {
        var set = {};
        for (var i = 0; i < arr.length; i++)
            set[arr[i]] = true;
        return set
    }
    var voidElements = makeSet(["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
    var plaintextParents = makeSet(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
    function getOuterHTML(node, parentNode, composed) {
        switch (node.nodeType) {
        case Node.ELEMENT_NODE:
            var tagName = node.localName;
            var s = "<" + tagName;
            var attrs = node.attributes;
            for (var i = 0, attr; attr = attrs[i]; i++)
                s += " " + attr.name + '="' + escapeAttr(attr.value) + '"';
            s += ">";
            if (voidElements[tagName])
                return s;
            return s + getInnerHTML(node, composed) + "</" + tagName + ">";
        case Node.TEXT_NODE:
            var data = node.data;
            if (parentNode && plaintextParents[parentNode.localName])
                return data;
            return escapeData(data);
        case Node.COMMENT_NODE:
            return "\x3c!--" + node.data + "--\x3e";
        default:
            console.error(node);
            throw new Error("not implemented");
        }
    }
    function getInnerHTML(node, composed) {
        if (node instanceof HTMLTemplateElement)
            node = node.content;
        var s = "";
        var c$ = Polymer.dom(node).childNodes;
        for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++)
            s += getOuterHTML(child, node, composed);
        return s
    }
    return {
        getInnerHTML: getInnerHTML
    }
}();
(function() {
    var nativeInsertBefore = Element.prototype.insertBefore;
    var nativeAppendChild = Element.prototype.appendChild;
    var nativeRemoveChild = Element.prototype.removeChild;
    Polymer.TreeApi = {
        arrayCopyChildNodes: function(parent) {
            var copy = []
              , i = 0;
            for (var n = parent.firstChild; n; n = n.nextSibling)
                copy[i++] = n;
            return copy
        },
        arrayCopyChildren: function(parent) {
            var copy = []
              , i = 0;
            for (var n = parent.firstElementChild; n; n = n.nextElementSibling)
                copy[i++] = n;
            return copy
        },
        arrayCopy: function(a$) {
            var l = a$.length;
            var copy = new Array(l);
            for (var i = 0; i < l; i++)
                copy[i] = a$[i];
            return copy
        }
    };
    Polymer.TreeApi.Logical = {
        hasParentNode: function(node) {
            return Boolean(node.__dom && node.__dom.parentNode)
        },
        hasChildNodes: function(node) {
            return Boolean(node.__dom && node.__dom.childNodes !== undefined)
        },
        getChildNodes: function(node) {
            return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes
        },
        _getChildNodes: function(node) {
            if (!node.__dom.childNodes) {
                node.__dom.childNodes = [];
                for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling)
                    node.__dom.childNodes.push(n)
            }
            return node.__dom.childNodes
        },
        getParentNode: function(node) {
            return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode
        },
        getFirstChild: function(node) {
            return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild
        },
        getLastChild: function(node) {
            return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild
        },
        getNextSibling: function(node) {
            return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling
        },
        getPreviousSibling: function(node) {
            return node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling
        },
        getFirstElementChild: function(node) {
            return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild
        },
        _getFirstElementChild: function(node) {
            var n = node.__dom.firstChild;
            while (n && n.nodeType !== Node.ELEMENT_NODE)
                n = n.__dom.nextSibling;
            return n
        },
        getLastElementChild: function(node) {
            return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild
        },
        _getLastElementChild: function(node) {
            var n = node.__dom.lastChild;
            while (n && n.nodeType !== Node.ELEMENT_NODE)
                n = n.__dom.previousSibling;
            return n
        },
        getNextElementSibling: function(node) {
            return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling
        },
        _getNextElementSibling: function(node) {
            var n = node.__dom.nextSibling;
            while (n && n.nodeType !== Node.ELEMENT_NODE)
                n = n.__dom.nextSibling;
            return n
        },
        getPreviousElementSibling: function(node) {
            return node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling
        },
        _getPreviousElementSibling: function(node) {
            var n = node.__dom.previousSibling;
            while (n && n.nodeType !== Node.ELEMENT_NODE)
                n = n.__dom.previousSibling;
            return n
        },
        saveChildNodes: function(node) {
            if (!this.hasChildNodes(node)) {
                node.__dom = node.__dom || {};
                node.__dom.firstChild = node.firstChild;
                node.__dom.lastChild = node.lastChild;
                node.__dom.childNodes = [];
                for (var n = node.firstChild; n; n = n.nextSibling) {
                    n.__dom = n.__dom || {};
                    n.__dom.parentNode = node;
                    node.__dom.childNodes.push(n);
                    n.__dom.nextSibling = n.nextSibling;
                    n.__dom.previousSibling = n.previousSibling
                }
            }
        },
        recordInsertBefore: function(node, container, ref_node) {
            container.__dom.childNodes = null;
            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
                for (var n = node.firstChild; n; n = n.nextSibling)
                    this._linkNode(n, container, ref_node);
            else
                this._linkNode(node, container, ref_node)
        },
        _linkNode: function(node, container, ref_node) {
            node.__dom = node.__dom || {};
            container.__dom = container.__dom || {};
            if (ref_node)
                ref_node.__dom = ref_node.__dom || {};
            node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
            if (node.__dom.previousSibling)
                node.__dom.previousSibling.__dom.nextSibling = node;
            node.__dom.nextSibling = ref_node || null;
            if (node.__dom.nextSibling)
                node.__dom.nextSibling.__dom.previousSibling = node;
            node.__dom.parentNode = container;
            if (ref_node) {
                if (ref_node === container.__dom.firstChild)
                    container.__dom.firstChild = node
            } else {
                container.__dom.lastChild = node;
                if (!container.__dom.firstChild)
                    container.__dom.firstChild = node
            }
            container.__dom.childNodes = null
        },
        recordRemoveChild: function(node, container) {
            node.__dom = node.__dom || {};
            container.__dom = container.__dom || {};
            if (node === container.__dom.firstChild)
                container.__dom.firstChild = node.__dom.nextSibling;
            if (node === container.__dom.lastChild)
                container.__dom.lastChild = node.__dom.previousSibling;
            var p = node.__dom.previousSibling;
            var n = node.__dom.nextSibling;
            if (p)
                p.__dom.nextSibling = n;
            if (n)
                n.__dom.previousSibling = p;
            node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;
            container.__dom.childNodes = null
        }
    };
    Polymer.TreeApi.Composed = {
        getChildNodes: function(node) {
            return Polymer.TreeApi.arrayCopyChildNodes(node)
        },
        getParentNode: function(node) {
            return node.parentNode
        },
        clearChildNodes: function(node) {
            node.textContent = ""
        },
        insertBefore: function(parentNode, newChild, refChild) {
            return nativeInsertBefore.call(parentNode, newChild, refChild || null)
        },
        appendChild: function(parentNode, newChild) {
            return nativeAppendChild.call(parentNode, newChild)
        },
        removeChild: function(parentNode, node) {
            return nativeRemoveChild.call(parentNode, node)
        }
    }
}
)();
Polymer.DomApi = function() {
    var Settings = Polymer.Settings;
    var TreeApi = Polymer.TreeApi;
    var DomApi = function(node) {
        this.node = needsToWrap ? DomApi.wrap(node) : node
    };
    var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
    DomApi.wrap = window.wrap ? window.wrap : function(node) {
        return node
    }
    ;
    DomApi.prototype = {
        flush: function() {
            Polymer.dom.flush()
        },
        deepContains: function(node) {
            if (this.node.contains(node))
                return true;
            var n = node;
            var doc = node.ownerDocument;
            while (n && n !== doc && n !== this.node)
                n = Polymer.dom(n).parentNode || n.host;
            return n === this.node
        },
        queryDistributedElements: function(selector) {
            var c$ = this.getEffectiveChildNodes();
            var list = [];
            for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++)
                if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector))
                    list.push(c);
            return list
        },
        getEffectiveChildNodes: function() {
            var list = [];
            var c$ = this.childNodes;
            for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++)
                if (c.localName === CONTENT) {
                    var d$ = dom(c).getDistributedNodes();
                    for (var j = 0; j < d$.length; j++)
                        list.push(d$[j])
                } else
                    list.push(c);
            return list
        },
        observeNodes: function(callback) {
            if (callback) {
                if (!this.observer)
                    this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
                return this.observer.addListener(callback)
            }
        },
        unobserveNodes: function(handle) {
            if (this.observer)
                this.observer.removeListener(handle)
        },
        notifyObserver: function() {
            if (this.observer)
                this.observer.notify()
        },
        _query: function(matcher, node, halter) {
            node = node || this.node;
            var list = [];
            this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);
            return list
        },
        _queryElements: function(elements, matcher, halter, list) {
            for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++)
                if (c.nodeType === Node.ELEMENT_NODE)
                    if (this._queryElement(c, matcher, halter, list))
                        return true
        },
        _queryElement: function(node, matcher, halter, list) {
            var result = matcher(node);
            if (result)
                list.push(node);
            if (halter && halter(result))
                return result;
            this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list)
        }
    };
    var CONTENT = DomApi.CONTENT = "content";
    var dom = DomApi.factory = function(node) {
        node = node || document;
        if (!node.__domApi)
            node.__domApi = new DomApi.ctor(node);
        return node.__domApi
    }
    ;
    DomApi.hasApi = function(node) {
        return Boolean(node.__domApi)
    }
    ;
    DomApi.ctor = DomApi;
    Polymer.dom = function(obj, patch) {
        if (obj instanceof Event)
            return Polymer.EventApi.factory(obj);
        else
            return DomApi.factory(obj, patch)
    }
    ;
    var p = Element.prototype;
    DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
    return DomApi
}();
(function() {
    var Settings = Polymer.Settings;
    var DomApi = Polymer.DomApi;
    var dom = DomApi.factory;
    var TreeApi = Polymer.TreeApi;
    var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
    var CONTENT = DomApi.CONTENT;
    if (Settings.useShadow)
        return;
    var nativeCloneNode = Element.prototype.cloneNode;
    var nativeImportNode = Document.prototype.importNode;
    Polymer.Base.mixin(DomApi.prototype, {
        _lazyDistribute: function(host) {
            if (host.shadyRoot && host.shadyRoot._distributionClean) {
                host.shadyRoot._distributionClean = false;
                Polymer.dom.addDebouncer(host.debounce("_distribute", host._distributeContent))
            }
        },
        appendChild: function(node) {
            return this.insertBefore(node)
        },
        insertBefore: function(node, ref_node) {
            if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node)
                throw Error("The ref_node to be inserted before is not a child " + "of this node");
            if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                var parent = TreeApi.Logical.getParentNode(node);
                if (parent) {
                    if (DomApi.hasApi(parent))
                        dom(parent).notifyObserver();
                    this._removeNode(node)
                } else
                    this._removeOwnerShadyRoot(node)
            }
            if (!this._addNode(node, ref_node)) {
                if (ref_node)
                    ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
                var container = this.node._isShadyRoot ? this.node.host : this.node;
                if (ref_node)
                    TreeApi.Composed.insertBefore(container, node, ref_node);
                else
                    TreeApi.Composed.appendChild(container, node)
            }
            this.notifyObserver();
            return node
        },
        _addNode: function(node, ref_node) {
            var root = this.getOwnerRoot();
            if (root) {
                var ipAdded = this._maybeAddInsertionPoint(node, this.node);
                if (!root._invalidInsertionPoints)
                    root._invalidInsertionPoints = ipAdded;
                this._addNodeToHost(root.host, node)
            }
            if (TreeApi.Logical.hasChildNodes(this.node))
                TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
            var handled = this._maybeDistribute(node) || this.node.shadyRoot;
            if (handled)
                if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
                    while (node.firstChild)
                        TreeApi.Composed.removeChild(node, node.firstChild);
                else {
                    var parent = TreeApi.Composed.getParentNode(node);
                    if (parent)
                        TreeApi.Composed.removeChild(parent, node)
                }
            return handled
        },
        removeChild: function(node) {
            if (TreeApi.Logical.getParentNode(node) !== this.node)
                throw Error("The node to be removed is not a child of this node: " + node);
            if (!this._removeNode(node)) {
                var container = this.node._isShadyRoot ? this.node.host : this.node;
                var parent = TreeApi.Composed.getParentNode(node);
                if (container === parent)
                    TreeApi.Composed.removeChild(container, node)
            }
            this.notifyObserver();
            return node
        },
        _removeNode: function(node) {
            var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
            var distributed;
            var root = this._ownerShadyRootForNode(node);
            if (logicalParent) {
                distributed = dom(node)._maybeDistributeParent();
                TreeApi.Logical.recordRemoveChild(node, logicalParent);
                if (root && this._removeDistributedChildren(root, node)) {
                    root._invalidInsertionPoints = true;
                    this._lazyDistribute(root.host)
                }
            }
            this._removeOwnerShadyRoot(node);
            if (root)
                this._removeNodeFromHost(root.host, node);
            return distributed
        },
        replaceChild: function(node, ref_node) {
            this.insertBefore(node, ref_node);
            this.removeChild(ref_node);
            return node
        },
        _hasCachedOwnerRoot: function(node) {
            return Boolean(node._ownerShadyRoot !== undefined)
        },
        getOwnerRoot: function() {
            return this._ownerShadyRootForNode(this.node)
        },
        _ownerShadyRootForNode: function(node) {
            if (!node)
                return;
            var root = node._ownerShadyRoot;
            if (root === undefined) {
                if (node._isShadyRoot)
                    root = node;
                else {
                    var parent = TreeApi.Logical.getParentNode(node);
                    if (parent)
                        root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
                    else
                        root = null
                }
                if (root || document.documentElement.contains(node))
                    node._ownerShadyRoot = root
            }
            return root
        },
        _maybeDistribute: function(node) {
            var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
            var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
            var hasContent = fragContent || node.localName === CONTENT;
            if (hasContent) {
                var root = this.getOwnerRoot();
                if (root)
                    this._lazyDistribute(root.host)
            }
            var needsDist = this._nodeNeedsDistribution(this.node);
            if (needsDist)
                this._lazyDistribute(this.node);
            return needsDist || hasContent && !wrappedContent
        },
        _maybeAddInsertionPoint: function(node, parent) {
            var added;
            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
                var c$ = dom(node).querySelectorAll(CONTENT);
                for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
                    np = TreeApi.Logical.getParentNode(n);
                    if (np === node)
                        np = parent;
                    na = this._maybeAddInsertionPoint(n, np);
                    added = added || na
                }
            } else if (node.localName === CONTENT) {
                TreeApi.Logical.saveChildNodes(parent);
                TreeApi.Logical.saveChildNodes(node);
                added = true
            }
            return added
        },
        _updateInsertionPoints: function(host) {
            var i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);
            for (var i = 0, c; i < i$.length; i++) {
                c = i$[i];
                TreeApi.Logical.saveChildNodes(c);
                TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c))
            }
        },
        _nodeNeedsDistribution: function(node) {
            return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot)
        },
        _addNodeToHost: function(host, node) {
            if (host._elementAdd)
                host._elementAdd(node)
        },
        _removeNodeFromHost: function(host, node) {
            if (host._elementRemove)
                host._elementRemove(node)
        },
        _removeDistributedChildren: function(root, container) {
            var hostNeedsDist;
            var ip$ = root._insertionPoints;
            for (var i = 0; i < ip$.length; i++) {
                var content = ip$[i];
                if (this._contains(container, content)) {
                    var dc$ = dom(content).getDistributedNodes();
                    for (var j = 0; j < dc$.length; j++) {
                        hostNeedsDist = true;
                        var node = dc$[j];
                        var parent = TreeApi.Composed.getParentNode(node);
                        if (parent)
                            TreeApi.Composed.removeChild(parent, node)
                    }
                }
            }
            return hostNeedsDist
        },
        _contains: function(container, node) {
            while (node) {
                if (node == container)
                    return true;
                node = TreeApi.Logical.getParentNode(node)
            }
        },
        _removeOwnerShadyRoot: function(node) {
            if (this._hasCachedOwnerRoot(node)) {
                var c$ = TreeApi.Logical.getChildNodes(node);
                for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++)
                    this._removeOwnerShadyRoot(n)
            }
            node._ownerShadyRoot = undefined
        },
        _firstComposedNode: function(content) {
            var n$ = dom(content).getDistributedNodes();
            for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
                p$ = dom(n).getDestinationInsertionPoints();
                if (p$[p$.length - 1] === content)
                    return n
            }
        },
        querySelector: function(selector) {
            var result = this._query(function(n) {
                return DomApi.matchesSelector.call(n, selector)
            }, this.node, function(n) {
                return Boolean(n)
            })[0];
            return result || null
        },
        querySelectorAll: function(selector) {
            return this._query(function(n) {
                return DomApi.matchesSelector.call(n, selector)
            }, this.node)
        },
        getDestinationInsertionPoints: function() {
            return this.node._destinationInsertionPoints || []
        },
        getDistributedNodes: function() {
            return this.node._distributedNodes || []
        },
        _clear: function() {
            while (this.childNodes.length)
                this.removeChild(this.childNodes[0])
        },
        setAttribute: function(name, value) {
            this.node.setAttribute(name, value);
            this._maybeDistributeParent()
        },
        removeAttribute: function(name) {
            this.node.removeAttribute(name);
            this._maybeDistributeParent()
        },
        _maybeDistributeParent: function() {
            if (this._nodeNeedsDistribution(this.parentNode)) {
                this._lazyDistribute(this.parentNode);
                return true
            }
        },
        cloneNode: function(deep) {
            var n = nativeCloneNode.call(this.node, false);
            if (deep) {
                var c$ = this.childNodes;
                var d = dom(n);
                for (var i = 0, nc; i < c$.length; i++) {
                    nc = dom(c$[i]).cloneNode(true);
                    d.appendChild(nc)
                }
            }
            return n
        },
        importNode: function(externalNode, deep) {
            var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
            var n = nativeImportNode.call(doc, externalNode, false);
            if (deep) {
                var c$ = TreeApi.Logical.getChildNodes(externalNode);
                var d = dom(n);
                for (var i = 0, nc; i < c$.length; i++) {
                    nc = dom(doc).importNode(c$[i], true);
                    d.appendChild(nc)
                }
            }
            return n
        },
        _getComposedInnerHTML: function() {
            return getInnerHTML(this.node, true)
        }
    });
    Object.defineProperties(DomApi.prototype, {
        activeElement: {
            get: function() {
                var active = document.activeElement;
                if (!active)
                    return null;
                var isShadyRoot = !!this.node._isShadyRoot;
                if (this.node !== document) {
                    if (!isShadyRoot)
                        return null;
                    if (this.node.host === active || !this.node.host.contains(active))
                        return null
                }
                var activeRoot = dom(active).getOwnerRoot();
                while (activeRoot && activeRoot !== this.node) {
                    active = activeRoot.host;
                    activeRoot = dom(active).getOwnerRoot()
                }
                if (this.node === document)
                    return activeRoot ? null : active;
                else
                    return activeRoot === this.node ? active : null
            },
            configurable: true
        },
        childNodes: {
            get: function() {
                var c$ = TreeApi.Logical.getChildNodes(this.node);
                return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node)
            },
            configurable: true
        },
        children: {
            get: function() {
                if (TreeApi.Logical.hasChildNodes(this.node))
                    return Array.prototype.filter.call(this.childNodes, function(n) {
                        return n.nodeType === Node.ELEMENT_NODE
                    });
                else
                    return TreeApi.arrayCopyChildren(this.node)
            },
            configurable: true
        },
        parentNode: {
            get: function() {
                return TreeApi.Logical.getParentNode(this.node)
            },
            configurable: true
        },
        firstChild: {
            get: function() {
                return TreeApi.Logical.getFirstChild(this.node)
            },
            configurable: true
        },
        lastChild: {
            get: function() {
                return TreeApi.Logical.getLastChild(this.node)
            },
            configurable: true
        },
        nextSibling: {
            get: function() {
                return TreeApi.Logical.getNextSibling(this.node)
            },
            configurable: true
        },
        previousSibling: {
            get: function() {
                return TreeApi.Logical.getPreviousSibling(this.node)
            },
            configurable: true
        },
        firstElementChild: {
            get: function() {
                return TreeApi.Logical.getFirstElementChild(this.node)
            },
            configurable: true
        },
        lastElementChild: {
            get: function() {
                return TreeApi.Logical.getLastElementChild(this.node)
            },
            configurable: true
        },
        nextElementSibling: {
            get: function() {
                return TreeApi.Logical.getNextElementSibling(this.node)
            },
            configurable: true
        },
        previousElementSibling: {
            get: function() {
                return TreeApi.Logical.getPreviousElementSibling(this.node)
            },
            configurable: true
        },
        textContent: {
            get: function() {
                var nt = this.node.nodeType;
                if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE)
                    return this.node.textContent;
                else {
                    var tc = [];
                    for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++)
                        if (c.nodeType !== Node.COMMENT_NODE)
                            tc.push(c.textContent);
                    return tc.join("")
                }
            },
            set: function(text) {
                var nt = this.node.nodeType;
                if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE)
                    this.node.textContent = text;
                else {
                    this._clear();
                    if (text)
                        this.appendChild(document.createTextNode(text))
                }
            },
            configurable: true
        },
        innerHTML: {
            get: function() {
                var nt = this.node.nodeType;
                if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE)
                    return null;
                else
                    return getInnerHTML(this.node)
            },
            set: function(text) {
                var nt = this.node.nodeType;
                if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
                    this._clear();
                    var d = document.createElement("div");
                    d.innerHTML = text;
                    var c$ = TreeApi.arrayCopyChildNodes(d);
                    for (var i = 0; i < c$.length; i++)
                        this.appendChild(c$[i])
                }
            },
            configurable: true
        }
    });
    DomApi.hasInsertionPoint = function(root) {
        return Boolean(root && root._insertionPoints.length)
    }
}
)();
(function() {
    var Settings = Polymer.Settings;
    var TreeApi = Polymer.TreeApi;
    var DomApi = Polymer.DomApi;
    if (!Settings.useShadow)
        return;
    Polymer.Base.mixin(DomApi.prototype, {
        querySelectorAll: function(selector) {
            return TreeApi.arrayCopy(this.node.querySelectorAll(selector))
        },
        getOwnerRoot: function() {
            var n = this.node;
            while (n) {
                if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host)
                    return n;
                n = n.parentNode
            }
        },
        importNode: function(externalNode, deep) {
            var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
            return doc.importNode(externalNode, deep)
        },
        getDestinationInsertionPoints: function() {
            var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
            return n$ ? TreeApi.arrayCopy(n$) : []
        },
        getDistributedNodes: function() {
            var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
            return n$ ? TreeApi.arrayCopy(n$) : []
        }
    });
    Object.defineProperties(DomApi.prototype, {
        activeElement: {
            get: function() {
                var node = DomApi.wrap(this.node);
                var activeElement = node.activeElement;
                return node.contains(activeElement) ? activeElement : null
            },
            configurable: true
        },
        childNodes: {
            get: function() {
                return TreeApi.arrayCopyChildNodes(this.node)
            },
            configurable: true
        },
        children: {
            get: function() {
                return TreeApi.arrayCopyChildren(this.node)
            },
            configurable: true
        },
        textContent: {
            get: function() {
                return this.node.textContent
            },
            set: function(value) {
                return this.node.textContent = value
            },
            configurable: true
        },
        innerHTML: {
            get: function() {
                return this.node.innerHTML
            },
            set: function(value) {
                return this.node.innerHTML = value
            },
            configurable: true
        }
    });
    var forwardMethods = function(m$) {
        for (var i = 0; i < m$.length; i++)
            forwardMethod(m$[i])
    };
    var forwardMethod = function(method) {
        DomApi.prototype[method] = function() {
            return this.node[method].apply(this.node, arguments)
        }
    };
    forwardMethods(["cloneNode", "appendChild", "insertBefore", "removeChild", "replaceChild", "setAttribute", "removeAttribute", "querySelector"]);
    var forwardProperties = function(f$) {
        for (var i = 0; i < f$.length; i++)
            forwardProperty(f$[i])
    };
    var forwardProperty = function(name) {
        Object.defineProperty(DomApi.prototype, name, {
            get: function() {
                return this.node[name]
            },
            configurable: true
        })
    };
    forwardProperties(["parentNode", "firstChild", "lastChild", "nextSibling", "previousSibling", "firstElementChild", "lastElementChild", "nextElementSibling", "previousElementSibling"])
}
)();
Polymer.Base.mixin(Polymer.dom, {
    _flushGuard: 0,
    _FLUSH_MAX: 100,
    _needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
    _debouncers: [],
    _staticFlushList: [],
    _finishDebouncer: null,
    flush: function() {
        this._flushGuard = 0;
        this._prepareFlush();
        while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
            while (this._debouncers.length)
                this._debouncers.shift().complete();
            if (this._finishDebouncer)
                this._finishDebouncer.complete();
            this._prepareFlush();
            this._flushGuard++
        }
        if (this._flushGuard >= this._FLUSH_MAX)
            console.warn("Polymer.dom.flush aborted. Flush may not be complete.")
    },
    _prepareFlush: function() {
        if (this._needsTakeRecords)
            CustomElements.takeRecords();
        for (var i = 0; i < this._staticFlushList.length; i++)
            this._staticFlushList[i]()
    },
    addStaticFlush: function(fn) {
        this._staticFlushList.push(fn)
    },
    removeStaticFlush: function(fn) {
        var i = this._staticFlushList.indexOf(fn);
        if (i >= 0)
            this._staticFlushList.splice(i, 1)
    },
    addDebouncer: function(debouncer) {
        this._debouncers.push(debouncer);
        this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush)
    },
    _finishFlush: function() {
        Polymer.dom._debouncers = []
    }
});
Polymer.EventApi = function() {
    var DomApi = Polymer.DomApi.ctor;
    var Settings = Polymer.Settings;
    DomApi.Event = function(event) {
        this.event = event
    }
    ;
    if (Settings.useShadow)
        DomApi.Event.prototype = {
            get rootTarget() {
                return this.event.path[0]
            },
            get localTarget() {
                return this.event.target
            },
            get path() {
                var path = this.event.path;
                if (!Array.isArray(path))
                    path = Array.prototype.slice.call(path);
                return path
            }
        };
    else
        DomApi.Event.prototype = {
            get rootTarget() {
                return this.event.target
            },
            get localTarget() {
                var current = this.event.currentTarget;
                var currentRoot = current && Polymer.dom(current).getOwnerRoot();
                var p$ = this.path;
                for (var i = 0; i < p$.length; i++)
                    if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot)
                        return p$[i]
            },
            get path() {
                if (!this.event._path) {
                    var path = [];
                    var current = this.rootTarget;
                    while (current) {
                        path.push(current);
                        var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
                        if (insertionPoints.length) {
                            for (var i = 0; i < insertionPoints.length - 1; i++)
                                path.push(insertionPoints[i]);
                            current = insertionPoints[insertionPoints.length - 1]
                        } else
                            current = Polymer.dom(current).parentNode || current.host
                    }
                    path.push(window);
                    this.event._path = path
                }
                return this.event._path
            }
        };
    var factory = function(event) {
        if (!event.__eventApi)
            event.__eventApi = new DomApi.Event(event);
        return event.__eventApi
    };
    return {
        factory: factory
    }
}();
(function() {
    var DomApi = Polymer.DomApi.ctor;
    var useShadow = Polymer.Settings.useShadow;
    Object.defineProperty(DomApi.prototype, "classList", {
        get: function() {
            if (!this._classList)
                this._classList = new DomApi.ClassList(this);
            return this._classList
        },
        configurable: true
    });
    DomApi.ClassList = function(host) {
        this.domApi = host;
        this.node = host.node
    }
    ;
    DomApi.ClassList.prototype = {
        add: function() {
            this.node.classList.add.apply(this.node.classList, arguments);
            this._distributeParent()
        },
        remove: function() {
            this.node.classList.remove.apply(this.node.classList, arguments);
            this._distributeParent()
        },
        toggle: function() {
            this.node.classList.toggle.apply(this.node.classList, arguments);
            this._distributeParent()
        },
        _distributeParent: function() {
            if (!useShadow)
                this.domApi._maybeDistributeParent()
        },
        contains: function() {
            return this.node.classList.contains.apply(this.node.classList, arguments)
        }
    }
}
)();
(function() {
    var DomApi = Polymer.DomApi.ctor;
    var Settings = Polymer.Settings;
    DomApi.EffectiveNodesObserver = function(domApi) {
        this.domApi = domApi;
        this.node = this.domApi.node;
        this._listeners = []
    }
    ;
    DomApi.EffectiveNodesObserver.prototype = {
        addListener: function(callback) {
            if (!this._isSetup) {
                this._setup();
                this._isSetup = true
            }
            var listener = {
                fn: callback,
                _nodes: []
            };
            this._listeners.push(listener);
            this._scheduleNotify();
            return listener
        },
        removeListener: function(handle) {
            var i = this._listeners.indexOf(handle);
            if (i >= 0) {
                this._listeners.splice(i, 1);
                handle._nodes = []
            }
            if (!this._hasListeners()) {
                this._cleanup();
                this._isSetup = false
            }
        },
        _setup: function() {
            this._observeContentElements(this.domApi.childNodes)
        },
        _cleanup: function() {
            this._unobserveContentElements(this.domApi.childNodes)
        },
        _hasListeners: function() {
            return Boolean(this._listeners.length)
        },
        _scheduleNotify: function() {
            if (this._debouncer)
                this._debouncer.stop();
            this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
            this._debouncer.context = this;
            Polymer.dom.addDebouncer(this._debouncer)
        },
        notify: function() {
            if (this._hasListeners())
                this._scheduleNotify()
        },
        _notify: function() {
            this._beforeCallListeners();
            this._callListeners()
        },
        _beforeCallListeners: function() {
            this._updateContentElements()
        },
        _updateContentElements: function() {
            this._observeContentElements(this.domApi.childNodes)
        },
        _observeContentElements: function(elements) {
            for (var i = 0, n; i < elements.length && (n = elements[i]); i++)
                if (this._isContent(n)) {
                    n.__observeNodesMap = n.__observeNodesMap || new WeakMap;
                    if (!n.__observeNodesMap.has(this))
                        n.__observeNodesMap.set(this, this._observeContent(n))
                }
        },
        _observeContent: function(content) {
            var self = this;
            var h = Polymer.dom(content).observeNodes(function() {
                self._scheduleNotify()
            });
            h._avoidChangeCalculation = true;
            return h
        },
        _unobserveContentElements: function(elements) {
            for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++)
                if (this._isContent(n)) {
                    h = n.__observeNodesMap.get(this);
                    if (h) {
                        Polymer.dom(n).unobserveNodes(h);
                        n.__observeNodesMap["delete"](this)
                    }
                }
        },
        _isContent: function(node) {
            return node.localName === "content"
        },
        _callListeners: function() {
            var o$ = this._listeners;
            var nodes = this._getEffectiveNodes();
            for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
                var info = this._generateListenerInfo(o, nodes);
                if (info || o._alwaysNotify)
                    this._callListener(o, info)
            }
        },
        _getEffectiveNodes: function() {
            return this.domApi.getEffectiveChildNodes()
        },
        _generateListenerInfo: function(listener, newNodes) {
            if (listener._avoidChangeCalculation)
                return true;
            var oldNodes = listener._nodes;
            var info = {
                target: this.node,
                addedNodes: [],
                removedNodes: []
            };
            var splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);
            for (var i = 0, s; i < splices.length && (s = splices[i]); i++)
                for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++)
                    info.removedNodes.push(n);
            for (i = 0,
            s; i < splices.length && (s = splices[i]); i++)
                for (j = s.index; j < s.index + s.addedCount; j++)
                    info.addedNodes.push(newNodes[j]);
            listener._nodes = newNodes;
            if (info.addedNodes.length || info.removedNodes.length)
                return info
        },
        _callListener: function(listener, info) {
            return listener.fn.call(this.node, info)
        },
        enableShadowAttributeTracking: function() {}
    };
    if (Settings.useShadow) {
        var baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;
        var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
        Polymer.Base.mixin(DomApi.EffectiveNodesObserver.prototype, {
            _setup: function() {
                if (!this._observer) {
                    var self = this;
                    this._mutationHandler = function(mxns) {
                        if (mxns && mxns.length)
                            self._scheduleNotify()
                    }
                    ;
                    this._observer = new MutationObserver(this._mutationHandler);
                    this._boundFlush = function() {
                        self._flush()
                    }
                    ;
                    Polymer.dom.addStaticFlush(this._boundFlush);
                    this._observer.observe(this.node, {
                        childList: true
                    })
                }
                baseSetup.call(this)
            },
            _cleanup: function() {
                this._observer.disconnect();
                this._observer = null;
                this._mutationHandler = null;
                Polymer.dom.removeStaticFlush(this._boundFlush);
                baseCleanup.call(this)
            },
            _flush: function() {
                if (this._observer)
                    this._mutationHandler(this._observer.takeRecords())
            },
            enableShadowAttributeTracking: function() {
                if (this._observer) {
                    this._makeContentListenersAlwaysNotify();
                    this._observer.disconnect();
                    this._observer.observe(this.node, {
                        childList: true,
                        attributes: true,
                        subtree: true
                    });
                    var root = this.domApi.getOwnerRoot();
                    var host = root && root.host;
                    if (host && Polymer.dom(host).observer)
                        Polymer.dom(host).observer.enableShadowAttributeTracking()
                }
            },
            _makeContentListenersAlwaysNotify: function() {
                for (var i = 0, h; i < this._listeners.length; i++) {
                    h = this._listeners[i];
                    h._alwaysNotify = h._isContentListener
                }
            }
        })
    }
}
)();
(function() {
    var DomApi = Polymer.DomApi.ctor;
    var Settings = Polymer.Settings;
    DomApi.DistributedNodesObserver = function(domApi) {
        DomApi.EffectiveNodesObserver.call(this, domApi)
    }
    ;
    DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
    Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
        _setup: function() {},
        _cleanup: function() {},
        _beforeCallListeners: function() {},
        _getEffectiveNodes: function() {
            return this.domApi.getDistributedNodes()
        }
    });
    if (Settings.useShadow)
        Polymer.Base.mixin(DomApi.DistributedNodesObserver.prototype, {
            _setup: function() {
                if (!this._observer) {
                    var root = this.domApi.getOwnerRoot();
                    var host = root && root.host;
                    if (host) {
                        var self = this;
                        this._observer = Polymer.dom(host).observeNodes(function() {
                            self._scheduleNotify()
                        });
                        this._observer._isContentListener = true;
                        if (this._hasAttrSelect())
                            Polymer.dom(host).observer.enableShadowAttributeTracking()
                    }
                }
            },
            _hasAttrSelect: function() {
                var select = this.node.getAttribute("select");
                return select && select.match(/[[.]+/)
            },
            _cleanup: function() {
                var root = this.domApi.getOwnerRoot();
                var host = root && root.host;
                if (host)
                    Polymer.dom(host).unobserveNodes(this._observer);
                this._observer = null
            }
        })
}
)();
(function() {
    var DomApi = Polymer.DomApi;
    var TreeApi = Polymer.TreeApi;
    Polymer.Base._addFeature({
        _prepShady: function() {
            this._useContent = this._useContent || Boolean(this._template)
        },
        _setupShady: function() {
            this.shadyRoot = null;
            if (!this.__domApi)
                this.__domApi = null;
            if (!this.__dom)
                this.__dom = null;
            if (!this._ownerShadyRoot)
                this._ownerShadyRoot = undefined
        },
        _poolContent: function() {
            if (this._useContent)
                TreeApi.Logical.saveChildNodes(this)
        },
        _setupRoot: function() {
            if (this._useContent) {
                this._createLocalRoot();
                if (!this.dataHost)
                    upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this))
            }
        },
        _createLocalRoot: function() {
            this.shadyRoot = this.root;
            this.shadyRoot._distributionClean = false;
            this.shadyRoot._hasDistributed = false;
            this.shadyRoot._isShadyRoot = true;
            this.shadyRoot._dirtyRoots = [];
            var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll("content") : [];
            TreeApi.Logical.saveChildNodes(this.shadyRoot);
            for (var i = 0, c; i < i$.length; i++) {
                c = i$[i];
                TreeApi.Logical.saveChildNodes(c);
                TreeApi.Logical.saveChildNodes(c.parentNode)
            }
            this.shadyRoot.host = this
        },
        distributeContent: function(updateInsertionPoints) {
            if (this.shadyRoot) {
                this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
                var host = getTopDistributingHost(this);
                Polymer.dom(this)._lazyDistribute(host)
            }
        },
        _distributeContent: function() {
            if (this._useContent && !this.shadyRoot._distributionClean) {
                if (this.shadyRoot._invalidInsertionPoints) {
                    Polymer.dom(this)._updateInsertionPoints(this);
                    this.shadyRoot._invalidInsertionPoints = false
                }
                this._beginDistribute();
                this._distributeDirtyRoots();
                this._finishDistribute()
            }
        },
        _beginDistribute: function() {
            if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
                this._resetDistribution();
                this._distributePool(this.shadyRoot, this._collectPool())
            }
        },
        _distributeDirtyRoots: function() {
            var c$ = this.shadyRoot._dirtyRoots;
            for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++)
                c._distributeContent();
            this.shadyRoot._dirtyRoots = []
        },
        _finishDistribute: function() {
            if (this._useContent) {
                this.shadyRoot._distributionClean = true;
                if (DomApi.hasInsertionPoint(this.shadyRoot)) {
                    this._composeTree();
                    notifyContentObservers(this.shadyRoot)
                } else if (!this.shadyRoot._hasDistributed) {
                    TreeApi.Composed.clearChildNodes(this);
                    this.appendChild(this.shadyRoot)
                } else {
                    var children = this._composeNode(this);
                    this._updateChildNodes(this, children)
                }
                if (!this.shadyRoot._hasDistributed)
                    notifyInitialDistribution(this);
                this.shadyRoot._hasDistributed = true
            }
        },
        elementMatches: function(selector, node) {
            node = node || this;
            return DomApi.matchesSelector.call(node, selector)
        },
        _resetDistribution: function() {
            var children = TreeApi.Logical.getChildNodes(this);
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child._destinationInsertionPoints)
                    child._destinationInsertionPoints = undefined;
                if (isInsertionPoint(child))
                    clearDistributedDestinationInsertionPoints(child)
            }
            var root = this.shadyRoot;
            var p$ = root._insertionPoints;
            for (var j = 0; j < p$.length; j++)
                p$[j]._distributedNodes = []
        },
        _collectPool: function() {
            var pool = [];
            var children = TreeApi.Logical.getChildNodes(this);
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (isInsertionPoint(child))
                    pool.push.apply(pool, child._distributedNodes);
                else
                    pool.push(child)
            }
            return pool
        },
        _distributePool: function(node, pool) {
            var p$ = node._insertionPoints;
            for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
                this._distributeInsertionPoint(p, pool);
                maybeRedistributeParent(p, this)
            }
        },
        _distributeInsertionPoint: function(content, pool) {
            var anyDistributed = false;
            for (var i = 0, l = pool.length, node; i < l; i++) {
                node = pool[i];
                if (!node)
                    continue;
                if (this._matchesContentSelect(node, content)) {
                    distributeNodeInto(node, content);
                    pool[i] = undefined;
                    anyDistributed = true
                }
            }
            if (!anyDistributed) {
                var children = TreeApi.Logical.getChildNodes(content);
                for (var j = 0; j < children.length; j++)
                    distributeNodeInto(children[j], content)
            }
        },
        _composeTree: function() {
            this._updateChildNodes(this, this._composeNode(this));
            var p$ = this.shadyRoot._insertionPoints;
            for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
                parent = TreeApi.Logical.getParentNode(p);
                if (!parent._useContent && parent !== this && parent !== this.shadyRoot)
                    this._updateChildNodes(parent, this._composeNode(parent))
            }
        },
        _composeNode: function(node) {
            var children = [];
            var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
            for (var i = 0; i < c$.length; i++) {
                var child = c$[i];
                if (isInsertionPoint(child)) {
                    var distributedNodes = child._distributedNodes;
                    for (var j = 0; j < distributedNodes.length; j++) {
                        var distributedNode = distributedNodes[j];
                        if (isFinalDestination(child, distributedNode))
                            children.push(distributedNode)
                    }
                } else
                    children.push(child)
            }
            return children
        },
        _updateChildNodes: function(container, children) {
            var composed = TreeApi.Composed.getChildNodes(container);
            var splices = Polymer.ArraySplice.calculateSplices(children, composed);
            for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
                for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
                    if (TreeApi.Composed.getParentNode(n) === container)
                        TreeApi.Composed.removeChild(container, n);
                    composed.splice(s.index + d, 1)
                }
                d -= s.addedCount
            }
            for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
                next = composed[s.index];
                for (j = s.index,
                n; j < s.index + s.addedCount; j++) {
                    n = children[j];
                    TreeApi.Composed.insertBefore(container, n, next);
                    composed.splice(j, 0, n)
                }
            }
        },
        _matchesContentSelect: function(node, contentElement) {
            var select = contentElement.getAttribute("select");
            if (!select)
                return true;
            select = select.trim();
            if (!select)
                return true;
            if (!(node instanceof Element))
                return false;
            var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
            if (!validSelectors.test(select))
                return false;
            return this.elementMatches(select, node)
        },
        _elementAdd: function() {},
        _elementRemove: function() {}
    });
    var domHostDesc = {
        get: function() {
            var root = Polymer.dom(this).getOwnerRoot();
            return root && root.host
        },
        configurable: true
    };
    Object.defineProperty(Polymer.Base, "domHost", domHostDesc);
    Polymer.BaseDescriptors.domHost = domHostDesc;
    function distributeNodeInto(child, insertionPoint) {
        insertionPoint._distributedNodes.push(child);
        var points = child._destinationInsertionPoints;
        if (!points)
            child._destinationInsertionPoints = [insertionPoint];
        else
            points.push(insertionPoint)
    }
    function clearDistributedDestinationInsertionPoints(content) {
        var e$ = content._distributedNodes;
        if (e$)
            for (var i = 0; i < e$.length; i++) {
                var d = e$[i]._destinationInsertionPoints;
                if (d)
                    d.splice(d.indexOf(content) + 1, d.length)
            }
    }
    function maybeRedistributeParent(content, host) {
        var parent = TreeApi.Logical.getParentNode(content);
        if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
            parent.shadyRoot._distributionClean = false;
            host.shadyRoot._dirtyRoots.push(parent)
        }
    }
    function isFinalDestination(insertionPoint, node) {
        var points = node._destinationInsertionPoints;
        return points && points[points.length - 1] === insertionPoint
    }
    function isInsertionPoint(node) {
        return node.localName == "content"
    }
    function getTopDistributingHost(host) {
        while (host && hostNeedsRedistribution(host))
            host = host.domHost;
        return host
    }
    function hostNeedsRedistribution(host) {
        var c$ = TreeApi.Logical.getChildNodes(host);
        for (var i = 0, c; i < c$.length; i++) {
            c = c$[i];
            if (c.localName && c.localName === "content")
                return host.domHost
        }
    }
    function notifyContentObservers(root) {
        for (var i = 0, c; i < root._insertionPoints.length; i++) {
            c = root._insertionPoints[i];
            if (DomApi.hasApi(c))
                Polymer.dom(c).notifyObserver()
        }
    }
    function notifyInitialDistribution(host) {
        if (DomApi.hasApi(host))
            Polymer.dom(host).notifyObserver()
    }
    var needsUpgrade = window.CustomElements && !CustomElements.useNative;
    function upgradeLogicalChildren(children) {
        if (needsUpgrade && children)
            for (var i = 0; i < children.length; i++)
                CustomElements.upgrade(children[i])
    }
}
)();
if (Polymer.Settings.useShadow)
    Polymer.Base._addFeature({
        _poolContent: function() {},
        _beginDistribute: function() {},
        distributeContent: function() {},
        _distributeContent: function() {},
        _finishDistribute: function() {},
        _createLocalRoot: function() {
            this.createShadowRoot();
            this.shadowRoot.appendChild(this.root);
            this.root = this.shadowRoot
        }
    });
Polymer.Async = {
    _currVal: 0,
    _lastVal: 0,
    _callbacks: [],
    _twiddleContent: 0,
    _twiddle: document.createTextNode(""),
    run: function(callback, waitTime) {
        if (waitTime > 0)
            return ~setTimeout(callback, waitTime);
        else {
            this._twiddle.textContent = this._twiddleContent++;
            this._callbacks.push(callback);
            return this._currVal++
        }
    },
    cancel: function(handle) {
        if (handle < 0)
            clearTimeout(~handle);
        else {
            var idx = handle - this._lastVal;
            if (idx >= 0) {
                if (!this._callbacks[idx])
                    throw "invalid async handle: " + handle;
                this._callbacks[idx] = null
            }
        }
    },
    _atEndOfMicrotask: function() {
        var len = this._callbacks.length;
        for (var i = 0; i < len; i++) {
            var cb = this._callbacks[i];
            if (cb)
                try {
                    cb()
                } catch (e) {
                    i++;
                    this._callbacks.splice(0, i);
                    this._lastVal += i;
                    this._twiddle.textContent = this._twiddleContent++;
                    throw e;
                }
        }
        this._callbacks.splice(0, len);
        this._lastVal += len
    }
};
(new window.MutationObserver(function() {
    Polymer.Async._atEndOfMicrotask()
}
)).observe(Polymer.Async._twiddle, {
    characterData: true
});
Polymer.Debounce = function() {
    var Async = Polymer.Async;
    var Debouncer = function(context) {
        this.context = context;
        var self = this;
        this.boundComplete = function() {
            self.complete()
        }
    };
    Debouncer.prototype = {
        go: function(callback, wait) {
            var h;
            this.finish = function() {
                Async.cancel(h)
            }
            ;
            h = Async.run(this.boundComplete, wait);
            this.callback = callback
        },
        stop: function() {
            if (this.finish) {
                this.finish();
                this.finish = null;
                this.callback = null
            }
        },
        complete: function() {
            if (this.finish) {
                var callback = this.callback;
                this.stop();
                callback.call(this.context)
            }
        }
    };
    function debounce(debouncer, callback, wait) {
        if (debouncer)
            debouncer.stop();
        else
            debouncer = new Debouncer(this);
        debouncer.go(callback, wait);
        return debouncer
    }
    return debounce
}();
Polymer.Base._addFeature({
    _setupDebouncers: function() {
        this._debouncers = {}
    },
    debounce: function(jobName, callback, wait) {
        return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait)
    },
    isDebouncerActive: function(jobName) {
        var debouncer = this._debouncers[jobName];
        return !!(debouncer && debouncer.finish)
    },
    flushDebouncer: function(jobName) {
        var debouncer = this._debouncers[jobName];
        if (debouncer)
            debouncer.complete()
    },
    cancelDebouncer: function(jobName) {
        var debouncer = this._debouncers[jobName];
        if (debouncer)
            debouncer.stop()
    }
});
Polymer.DomModule = document.createElement("dom-module");
Polymer.Base._addFeature({
    _registerFeatures: function() {
        this._prepIs();
        this._prepBehaviors();
        this._prepConstructor();
        this._prepTemplate();
        this._prepShady();
        this._prepPropertyInfo()
    },
    _prepBehavior: function(b) {
        this._addHostAttributes(b.hostAttributes)
    },
    _initFeatures: function() {
        this._registerHost();
        if (this._template) {
            this._poolContent();
            this._beginHosting();
            this._stampTemplate();
            this._endHosting()
        }
        this._marshalHostAttributes();
        this._setupDebouncers();
        this._marshalBehaviors();
        this._tryReady()
    },
    _marshalBehavior: function(b) {}
});
(function() {
    Polymer.nar = [];
    var disableUpgradeEnabled = Polymer.Settings.disableUpgradeEnabled;
    Polymer.Annotations = {
        parseAnnotations: function(template, stripWhiteSpace) {
            var list = [];
            var content = template._content || template.content;
            this._parseNodeAnnotations(content, list, stripWhiteSpace || template.hasAttribute("strip-whitespace"));
            return list
        },
        _parseNodeAnnotations: function(node, list, stripWhiteSpace) {
            return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace)
        },
        _bindingRegex: function() {
            var IDENT = "(?:" + "[a-zA-Z_$][\\w.:$\\-*]*" + ")";
            var NUMBER = "(?:" + "[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?" + ")";
            var SQUOTE_STRING = "(?:" + "'(?:[^'\\\\]|\\\\.)*'" + ")";
            var DQUOTE_STRING = "(?:" + '"(?:[^"\\\\]|\\\\.)*"' + ")";
            var STRING = "(?:" + SQUOTE_STRING + "|" + DQUOTE_STRING + ")";
            var ARGUMENT = "(?:" + IDENT + "|" + NUMBER + "|" + STRING + "\\s*" + ")";
            var ARGUMENTS = "(?:" + ARGUMENT + "(?:,\\s*" + ARGUMENT + ")*" + ")";
            var ARGUMENT_LIST = "(?:" + "\\(\\s*" + "(?:" + ARGUMENTS + "?" + ")" + "\\)\\s*" + ")";
            var BINDING = "(" + IDENT + "\\s*" + ARGUMENT_LIST + "?" + ")";
            var OPEN_BRACKET = "(\\[\\[|{{)" + "\\s*";
            var CLOSE_BRACKET = "(?:]]|}})";
            var NEGATE = "(?:(!)\\s*)?";
            var EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
            return new RegExp(EXPRESSION,"g")
        }(),
        _parseBindings: function(text) {
            var re = this._bindingRegex;
            var parts = [];
            var lastIndex = 0;
            var m;
            while ((m = re.exec(text)) !== null) {
                if (m.index > lastIndex)
                    parts.push({
                        literal: text.slice(lastIndex, m.index)
                    });
                var mode = m[1][0];
                var negate = Boolean(m[2]);
                var value = m[3].trim();
                var customEvent, notifyEvent, colon;
                if (mode == "{" && (colon = value.indexOf("::")) > 0) {
                    notifyEvent = value.substring(colon + 2);
                    value = value.substring(0, colon);
                    customEvent = true
                }
                parts.push({
                    compoundIndex: parts.length,
                    value: value,
                    mode: mode,
                    negate: negate,
                    event: notifyEvent,
                    customEvent: customEvent
                });
                lastIndex = re.lastIndex
            }
            if (lastIndex && lastIndex < text.length) {
                var literal = text.substring(lastIndex);
                if (literal)
                    parts.push({
                        literal: literal
                    })
            }
            if (parts.length)
                return parts
        },
        _literalFromParts: function(parts) {
            var s = "";
            for (var i = 0; i < parts.length; i++) {
                var literal = parts[i].literal;
                s += literal || ""
            }
            return s
        },
        _parseTextNodeAnnotation: function(node, list) {
            var parts = this._parseBindings(node.textContent);
            if (parts) {
                node.textContent = this._literalFromParts(parts) || " ";
                var annote = {
                    bindings: [{
                        kind: "text",
                        name: "textContent",
                        parts: parts,
                        isCompound: parts.length !== 1
                    }]
                };
                list.push(annote);
                return annote
            }
        },
        _parseElementAnnotations: function(element, list, stripWhiteSpace) {
            var annote = {
                bindings: [],
                events: []
            };
            if (element.localName === "content")
                list._hasContent = true;
            this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
            if (element.attributes) {
                this._parseNodeAttributeAnnotations(element, annote, list);
                if (this.prepElement)
                    this.prepElement(element)
            }
            if (annote.bindings.length || annote.events.length || annote.id)
                list.push(annote);
            return annote
        },
        _parseChildNodesAnnotations: function(root, annote, list, stripWhiteSpace) {
            if (root.firstChild) {
                var node = root.firstChild;
                var i = 0;
                while (node) {
                    var next = node.nextSibling;
                    if (node.localName === "template" && !node.hasAttribute("preserve-content"))
                        this._parseTemplate(node, i, list, annote, stripWhiteSpace);
                    if (node.localName == "slot")
                        node = this._replaceSlotWithContent(node);
                    if (node.nodeType === Node.TEXT_NODE) {
                        var n = next;
                        while (n && n.nodeType === Node.TEXT_NODE) {
                            node.textContent += n.textContent;
                            next = n.nextSibling;
                            root.removeChild(n);
                            n = next
                        }
                        if (stripWhiteSpace && !node.textContent.trim()) {
                            root.removeChild(node);
                            i--
                        }
                    }
                    if (node.parentNode) {
                        var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
                        if (childAnnotation) {
                            childAnnotation.parent = annote;
                            childAnnotation.index = i
                        }
                    }
                    node = next;
                    i++
                }
            }
        },
        _replaceSlotWithContent: function(slot) {
            var content = slot.ownerDocument.createElement("content");
            while (slot.firstChild)
                content.appendChild(slot.firstChild);
            var attrs = slot.attributes;
            for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                content.setAttribute(attr.name, attr.value)
            }
            var name = slot.getAttribute("name");
            if (name)
                content.setAttribute("select", "[slot='" + name + "']");
            slot.parentNode.replaceChild(content, slot);
            return content
        },
        _parseTemplate: function(node, index, list, parent, stripWhiteSpace) {
            var content = document.createDocumentFragment();
            content._notes = this.parseAnnotations(node, stripWhiteSpace);
            content.appendChild(node.content);
            list.push({
                bindings: Polymer.nar,
                events: Polymer.nar,
                templateContent: content,
                parent: parent,
                index: index
            })
        },
        _parseNodeAttributeAnnotations: function(node, annotation) {
            var attrs = Array.prototype.slice.call(node.attributes);
            for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
                var n = a.name;
                var v = a.value;
                var b;
                if (n.slice(0, 3) === "on-") {
                    node.removeAttribute(n);
                    annotation.events.push({
                        name: n.slice(3),
                        value: v
                    })
                } else if (b = this._parseNodeAttributeAnnotation(node, n, v))
                    annotation.bindings.push(b);
                else if (n === "id")
                    annotation.id = v
            }
        },
        _parseNodeAttributeAnnotation: function(node, name, value) {
            var parts = this._parseBindings(value);
            if (parts) {
                var origName = name;
                var kind = "property";
                if (name[name.length - 1] == "$") {
                    name = name.slice(0, -1);
                    kind = "attribute"
                }
                var literal = this._literalFromParts(parts);
                if (literal && kind == "attribute")
                    node.setAttribute(name, literal);
                if (node.localName === "input" && origName === "value")
                    node.setAttribute(origName, "");
                if (disableUpgradeEnabled && origName === "disable-upgrade$")
                    node.setAttribute(name, "");
                node.removeAttribute(origName);
                var propertyName = Polymer.CaseMap.dashToCamelCase(name);
                if (kind === "property")
                    name = propertyName;
                return {
                    kind: kind,
                    name: name,
                    propertyName: propertyName,
                    parts: parts,
                    literal: literal,
                    isCompound: parts.length !== 1
                }
            }
        },
        findAnnotatedNode: function(root, annote) {
            var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
            if (parent)
                for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
                    if (annote.index === i++)
                        return n
                }
            else
                return root
        }
    }
}
)();
Polymer.Path = {
    root: function(path) {
        var dotIndex = path.indexOf(".");
        if (dotIndex === -1)
            return path;
        return path.slice(0, dotIndex)
    },
    isDeep: function(path) {
        return path.indexOf(".") !== -1
    },
    isAncestor: function(base, path) {
        return base.indexOf(path + ".") === 0
    },
    isDescendant: function(base, path) {
        return path.indexOf(base + ".") === 0
    },
    translate: function(base, newBase, path) {
        return newBase + path.slice(base.length)
    },
    matches: function(base, wildcard, path) {
        return base === path || this.isAncestor(base, path) || Boolean(wildcard) && this.isDescendant(base, path)
    }
};
Polymer.Base._addFeature({
    _prepAnnotations: function() {
        if (!this._template)
            this._notes = [];
        else {
            var self = this;
            Polymer.Annotations.prepElement = function(element) {
                self._prepElement(element)
            }
            ;
            if (this._template._content && this._template._content._notes)
                this._notes = this._template._content._notes;
            else {
                this._notes = Polymer.Annotations.parseAnnotations(this._template);
                this._processAnnotations(this._notes)
            }
            Polymer.Annotations.prepElement = null
        }
    },
    _processAnnotations: function(notes) {
        for (var i = 0; i < notes.length; i++) {
            var note = notes[i];
            for (var j = 0; j < note.bindings.length; j++) {
                var b = note.bindings[j];
                for (var k = 0; k < b.parts.length; k++) {
                    var p = b.parts[k];
                    if (!p.literal) {
                        var signature = this._parseMethod(p.value);
                        if (signature)
                            p.signature = signature;
                        else
                            p.model = Polymer.Path.root(p.value)
                    }
                }
            }
            if (note.templateContent) {
                this._processAnnotations(note.templateContent._notes);
                var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
                var bindings = [];
                for (var prop in pp) {
                    var name = "_parent_" + prop;
                    bindings.push({
                        index: note.index,
                        kind: "property",
                        name: name,
                        propertyName: name,
                        parts: [{
                            mode: "{",
                            model: prop,
                            value: prop
                        }]
                    })
                }
                note.bindings = note.bindings.concat(bindings)
            }
        }
    },
    _discoverTemplateParentProps: function(notes) {
        var pp = {};
        for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
            for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++)
                for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++)
                    if (p.signature) {
                        var args = p.signature.args;
                        for (var kk = 0; kk < args.length; kk++) {
                            var model = args[kk].model;
                            if (model)
                                pp[model] = true
                        }
                        if (p.signature.dynamicFn)
                            pp[p.signature.method] = true
                    } else if (p.model)
                        pp[p.model] = true;
            if (n.templateContent) {
                var tpp = n.templateContent._parentProps;
                Polymer.Base.mixin(pp, tpp)
            }
        }
        return pp
    },
    _prepElement: function(element) {
        Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument)
    },
    _findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
    _marshalAnnotationReferences: function() {
        if (this._template) {
            this._marshalIdNodes();
            this._marshalAnnotatedNodes();
            this._marshalAnnotatedListeners()
        }
    },
    _configureAnnotationReferences: function() {
        var notes = this._notes;
        var nodes = this._nodes;
        for (var i = 0; i < notes.length; i++) {
            var note = notes[i];
            var node = nodes[i];
            this._configureTemplateContent(note, node);
            this._configureCompoundBindings(note, node)
        }
    },
    _configureTemplateContent: function(note, node) {
        if (note.templateContent)
            node._content = note.templateContent
    },
    _configureCompoundBindings: function(note, node) {
        var bindings = note.bindings;
        for (var i = 0; i < bindings.length; i++) {
            var binding = bindings[i];
            if (binding.isCompound) {
                var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
                var parts = binding.parts;
                var literals = new Array(parts.length);
                for (var j = 0; j < parts.length; j++)
                    literals[j] = parts[j].literal;
                var name = binding.name;
                storage[name] = literals;
                if (binding.literal && binding.kind == "property")
                    if (node._configValue)
                        node._configValue(name, binding.literal);
                    else
                        node[name] = binding.literal
            }
        }
    },
    _marshalIdNodes: function() {
        this.$ = {};
        for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++)
            if (a.id)
                this.$[a.id] = this._findAnnotatedNode(this.root, a)
    },
    _marshalAnnotatedNodes: function() {
        if (this._notes && this._notes.length) {
            var r = new Array(this._notes.length);
            for (var i = 0; i < this._notes.length; i++)
                r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
            this._nodes = r
        }
    },
    _marshalAnnotatedListeners: function() {
        for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++)
            if (a.events && a.events.length) {
                var node = this._findAnnotatedNode(this.root, a);
                for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++)
                    this.listen(node, e.name, e.value)
            }
    }
});
Polymer.Base._addFeature({
    listeners: {},
    _listenListeners: function(listeners) {
        var node, name, eventName;
        for (eventName in listeners) {
            if (eventName.indexOf(".") < 0) {
                node = this;
                name = eventName
            } else {
                name = eventName.split(".");
                node = this.$[name[0]];
                name = name[1]
            }
            this.listen(node, name, listeners[eventName])
        }
    },
    listen: function(node, eventName, methodName) {
        var handler = this._recallEventHandler(this, eventName, node, methodName);
        if (!handler)
            handler = this._createEventHandler(node, eventName, methodName);
        if (handler._listening)
            return;
        this._listen(node, eventName, handler);
        handler._listening = true
    },
    _boundListenerKey: function(eventName, methodName) {
        return eventName + ":" + methodName
    },
    _recordEventHandler: function(host, eventName, target, methodName, handler) {
        var hbl = host.__boundListeners;
        if (!hbl)
            hbl = host.__boundListeners = new WeakMap;
        var bl = hbl.get(target);
        if (!bl) {
            bl = {};
            if (!Polymer.Settings.isIE || target != window)
                hbl.set(target, bl)
        }
        var key = this._boundListenerKey(eventName, methodName);
        bl[key] = handler
    },
    _recallEventHandler: function(host, eventName, target, methodName) {
        var hbl = host.__boundListeners;
        if (!hbl)
            return;
        var bl = hbl.get(target);
        if (!bl)
            return;
        var key = this._boundListenerKey(eventName, methodName);
        return bl[key]
    },
    _createEventHandler: function(node, eventName, methodName) {
        var host = this;
        var handler = function(e) {
            if (host[methodName])
                host[methodName](e, e.detail);
            else
                host._warn(host._logf("_createEventHandler", "listener method `" + methodName + "` not defined"))
        };
        handler._listening = false;
        this._recordEventHandler(host, eventName, node, methodName, handler);
        return handler
    },
    unlisten: function(node, eventName, methodName) {
        var handler = this._recallEventHandler(this, eventName, node, methodName);
        if (handler) {
            this._unlisten(node, eventName, handler);
            handler._listening = false
        }
    },
    _listen: function(node, eventName, handler) {
        node.addEventListener(eventName, handler)
    },
    _unlisten: function(node, eventName, handler) {
        node.removeEventListener(eventName, handler)
    }
});
(function() {
    var wrap = Polymer.DomApi.wrap;
    var HAS_NATIVE_TA = typeof document.head.style.touchAction === "string";
    var GESTURE_KEY = "__polymerGestures";
    var HANDLED_OBJ = "__polymerGesturesHandled";
    var TOUCH_ACTION = "__polymerGesturesTouchAction";
    var TAP_DISTANCE = 25;
    var TRACK_DISTANCE = 5;
    var TRACK_LENGTH = 2;
    var MOUSE_TIMEOUT = 2500;
    var MOUSE_EVENTS = ["mousedown", "mousemove", "mouseup", "click"];
    var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
    var MOUSE_HAS_BUTTONS = function() {
        try {
            return (new MouseEvent("test",{
                buttons: 1
            })).buttons === 1
        } catch (e) {
            return false
        }
    }();
    function isMouseEvent(name) {
        return MOUSE_EVENTS.indexOf(name) > -1
    }
    var SUPPORTS_PASSIVE = false;
    (function() {
        try {
            var opts = Object.defineProperty({}, "passive", {
                get: function() {
                    SUPPORTS_PASSIVE = true
                }
            });
            window.addEventListener("test", null, opts);
            window.removeEventListener("test", null, opts)
        } catch (e) {}
    }
    )();
    function PASSIVE_TOUCH() {
        if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && Polymer.Settings.passiveTouchGestures)
            return {
                passive: true
            }
    }
    var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
    var mouseCanceller = function(mouseEvent) {
        var sc = mouseEvent.sourceCapabilities;
        if (sc && !sc.firesTouchEvents)
            return;
        mouseEvent[HANDLED_OBJ] = {
            skip: true
        };
        if (mouseEvent.type === "click") {
            var path = Polymer.dom(mouseEvent).path;
            for (var i = 0; i < path.length; i++)
                if (path[i] === POINTERSTATE.mouse.target)
                    return;
            mouseEvent.preventDefault();
            mouseEvent.stopPropagation()
        }
    };
    function setupTeardownMouseCanceller(setup) {
        var events = IS_TOUCH_ONLY ? ["click"] : MOUSE_EVENTS;
        for (var i = 0, en; i < events.length; i++) {
            en = events[i];
            if (setup)
                document.addEventListener(en, mouseCanceller, true);
            else
                document.removeEventListener(en, mouseCanceller, true)
        }
    }
    function ignoreMouse(ev) {
        if (!POINTERSTATE.mouse.mouseIgnoreJob)
            setupTeardownMouseCanceller(true);
        var unset = function() {
            setupTeardownMouseCanceller();
            POINTERSTATE.mouse.target = null;
            POINTERSTATE.mouse.mouseIgnoreJob = null
        };
        POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
        POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT)
    }
    function hasLeftMouseButton(ev) {
        var type = ev.type;
        if (!isMouseEvent(type))
            return false;
        if (type === "mousemove") {
            var buttons = ev.buttons === undefined ? 1 : ev.buttons;
            if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS)
                buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
            return Boolean(buttons & 1)
        } else {
            var button = ev.button === undefined ? 0 : ev.button;
            return button === 0
        }
    }
    function isSyntheticClick(ev) {
        if (ev.type === "click") {
            if (ev.detail === 0)
                return true;
            var t = Gestures.findOriginalTarget(ev);
            var bcr = t.getBoundingClientRect();
            var x = ev.pageX
              , y = ev.pageY;
            return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom))
        }
        return false
    }
    var POINTERSTATE = {
        mouse: {
            target: null,
            mouseIgnoreJob: null
        },
        touch: {
            x: 0,
            y: 0,
            id: -1,
            scrollDecided: false
        }
    };
    function firstTouchAction(ev) {
        var path = Polymer.dom(ev).path;
        var ta = "auto";
        for (var i = 0, n; i < path.length; i++) {
            n = path[i];
            if (n[TOUCH_ACTION]) {
                ta = n[TOUCH_ACTION];
                break
            }
        }
        return ta
    }
    function trackDocument(stateObj, movefn, upfn) {
        stateObj.movefn = movefn;
        stateObj.upfn = upfn;
        document.addEventListener("mousemove", movefn);
        document.addEventListener("mouseup", upfn)
    }
    function untrackDocument(stateObj) {
        document.removeEventListener("mousemove", stateObj.movefn);
        document.removeEventListener("mouseup", stateObj.upfn);
        stateObj.movefn = null;
        stateObj.upfn = null
    }
    document.addEventListener("touchend", ignoreMouse, SUPPORTS_PASSIVE ? {
        passive: true
    } : false);
    var Gestures = {
        gestures: {},
        recognizers: [],
        deepTargetFind: function(x, y) {
            var node = document.elementFromPoint(x, y);
            var next = node;
            while (next && next.shadowRoot) {
                next = next.shadowRoot.elementFromPoint(x, y);
                if (next)
                    node = next
            }
            return node
        },
        findOriginalTarget: function(ev) {
            if (ev.path)
                return ev.path[0];
            return ev.target
        },
        handleNative: function(ev) {
            var handled;
            var type = ev.type;
            var node = wrap(ev.currentTarget);
            var gobj = node[GESTURE_KEY];
            if (!gobj)
                return;
            var gs = gobj[type];
            if (!gs)
                return;
            if (!ev[HANDLED_OBJ]) {
                ev[HANDLED_OBJ] = {};
                if (type.slice(0, 5) === "touch") {
                    var t = ev.changedTouches[0];
                    if (type === "touchstart")
                        if (ev.touches.length === 1)
                            POINTERSTATE.touch.id = t.identifier;
                    if (POINTERSTATE.touch.id !== t.identifier)
                        return;
                    if (!HAS_NATIVE_TA)
                        if (type === "touchstart" || type === "touchmove")
                            Gestures.handleTouchAction(ev)
                }
            }
            handled = ev[HANDLED_OBJ];
            if (handled.skip)
                return;
            var recognizers = Gestures.recognizers;
            for (var i = 0, r; i < recognizers.length; i++) {
                r = recognizers[i];
                if (gs[r.name] && !handled[r.name])
                    if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset)
                        r.reset()
            }
            for (i = 0,
            r; i < recognizers.length; i++) {
                r = recognizers[i];
                if (gs[r.name] && !handled[r.name]) {
                    handled[r.name] = true;
                    r[type](ev)
                }
            }
        },
        handleTouchAction: function(ev) {
            var t = ev.changedTouches[0];
            var type = ev.type;
            if (type === "touchstart") {
                POINTERSTATE.touch.x = t.clientX;
                POINTERSTATE.touch.y = t.clientY;
                POINTERSTATE.touch.scrollDecided = false
            } else if (type === "touchmove") {
                if (POINTERSTATE.touch.scrollDecided)
                    return;
                POINTERSTATE.touch.scrollDecided = true;
                var ta = firstTouchAction(ev);
                var prevent = false;
                var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
                var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
                if (!ev.cancelable)
                    ;
                else if (ta === "none")
                    prevent = true;
                else if (ta === "pan-x")
                    prevent = dy > dx;
                else if (ta === "pan-y")
                    prevent = dx > dy;
                if (prevent)
                    ev.preventDefault();
                else
                    Gestures.prevent("track")
            }
        },
        add: function(node, evType, handler) {
            node = wrap(node);
            var recognizer = this.gestures[evType];
            var deps = recognizer.deps;
            var name = recognizer.name;
            var gobj = node[GESTURE_KEY];
            if (!gobj)
                node[GESTURE_KEY] = gobj = {};
            for (var i = 0, dep, gd; i < deps.length; i++) {
                dep = deps[i];
                if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== "click")
                    continue;
                gd = gobj[dep];
                if (!gd)
                    gobj[dep] = gd = {
                        _count: 0
                    };
                if (gd._count === 0) {
                    var options = !isMouseEvent(dep) && PASSIVE_TOUCH();
                    node.addEventListener(dep, this.handleNative, options)
                }
                gd[name] = (gd[name] || 0) + 1;
                gd._count = (gd._count || 0) + 1
            }
            node.addEventListener(evType, handler);
            if (recognizer.touchAction)
                this.setTouchAction(node, recognizer.touchAction)
        },
        remove: function(node, evType, handler) {
            node = wrap(node);
            var recognizer = this.gestures[evType];
            var deps = recognizer.deps;
            var name = recognizer.name;
            var gobj = node[GESTURE_KEY];
            if (gobj)
                for (var i = 0, dep, gd; i < deps.length; i++) {
                    dep = deps[i];
                    gd = gobj[dep];
                    if (gd && gd[name]) {
                        gd[name] = (gd[name] || 1) - 1;
                        gd._count = (gd._count || 1) - 1;
                        if (gd._count === 0) {
                            var options = !isMouseEvent(dep) && PASSIVE_TOUCH();
                            node.removeEventListener(dep, this.handleNative, options)
                        }
                    }
                }
            node.removeEventListener(evType, handler)
        },
        register: function(recog) {
            this.recognizers.push(recog);
            for (var i = 0; i < recog.emits.length; i++)
                this.gestures[recog.emits[i]] = recog
        },
        findRecognizerByEvent: function(evName) {
            for (var i = 0, r; i < this.recognizers.length; i++) {
                r = this.recognizers[i];
                for (var j = 0, n; j < r.emits.length; j++) {
                    n = r.emits[j];
                    if (n === evName)
                        return r
                }
            }
            return null
        },
        setTouchAction: function(node, value) {
            if (HAS_NATIVE_TA)
                node.style.touchAction = value;
            node[TOUCH_ACTION] = value
        },
        fire: function(target, type, detail) {
            var ev = Polymer.Base.fire(type, detail, {
                node: target,
                bubbles: true,
                cancelable: true
            });
            if (ev.defaultPrevented) {
                var preventer = detail.preventer || detail.sourceEvent;
                if (preventer && preventer.preventDefault)
                    preventer.preventDefault()
            }
        },
        prevent: function(evName) {
            var recognizer = this.findRecognizerByEvent(evName);
            if (recognizer.info)
                recognizer.info.prevent = true
        },
        resetMouseCanceller: function() {
            if (POINTERSTATE.mouse.mouseIgnoreJob)
                POINTERSTATE.mouse.mouseIgnoreJob.complete()
        }
    };
    Gestures.register({
        name: "downup",
        deps: ["mousedown", "touchstart", "touchend"],
        flow: {
            start: ["mousedown", "touchstart"],
            end: ["mouseup", "touchend"]
        },
        emits: ["down", "up"],
        info: {
            movefn: null,
            upfn: null
        },
        reset: function() {
            untrackDocument(this.info)
        },
        mousedown: function(e) {
            if (!hasLeftMouseButton(e))
                return;
            var t = Gestures.findOriginalTarget(e);
            var self = this;
            var movefn = function movefn(e) {
                if (!hasLeftMouseButton(e)) {
                    self.fire("up", t, e);
                    untrackDocument(self.info)
                }
            };
            var upfn = function upfn(e) {
                if (hasLeftMouseButton(e))
                    self.fire("up", t, e);
                untrackDocument(self.info)
            };
            trackDocument(this.info, movefn, upfn);
            this.fire("down", t, e)
        },
        touchstart: function(e) {
            this.fire("down", Gestures.findOriginalTarget(e), e.changedTouches[0], e)
        },
        touchend: function(e) {
            this.fire("up", Gestures.findOriginalTarget(e), e.changedTouches[0], e)
        },
        fire: function(type, target, event, preventer) {
            Gestures.fire(target, type, {
                x: event.clientX,
                y: event.clientY,
                sourceEvent: event,
                preventer: preventer,
                prevent: function(e) {
                    return Gestures.prevent(e)
                }
            })
        }
    });
    Gestures.register({
        name: "track",
        touchAction: "none",
        deps: ["mousedown", "touchstart", "touchmove", "touchend"],
        flow: {
            start: ["mousedown", "touchstart"],
            end: ["mouseup", "touchend"]
        },
        emits: ["track"],
        info: {
            x: 0,
            y: 0,
            state: "start",
            started: false,
            moves: [],
            addMove: function(move) {
                if (this.moves.length > TRACK_LENGTH)
                    this.moves.shift();
                this.moves.push(move)
            },
            movefn: null,
            upfn: null,
            prevent: false
        },
        reset: function() {
            this.info.state = "start";
            this.info.started = false;
            this.info.moves = [];
            this.info.x = 0;
            this.info.y = 0;
            this.info.prevent = false;
            untrackDocument(this.info)
        },
        hasMovedEnough: function(x, y) {
            if (this.info.prevent)
                return false;
            if (this.info.started)
                return true;
            var dx = Math.abs(this.info.x - x);
            var dy = Math.abs(this.info.y - y);
            return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE
        },
        mousedown: function(e) {
            if (!hasLeftMouseButton(e))
                return;
            var t = Gestures.findOriginalTarget(e);
            var self = this;
            var movefn = function movefn(e) {
                var x = e.clientX
                  , y = e.clientY;
                if (self.hasMovedEnough(x, y)) {
                    self.info.state = self.info.started ? e.type === "mouseup" ? "end" : "track" : "start";
                    if (self.info.state === "start")
                        Gestures.prevent("tap");
                    self.info.addMove({
                        x: x,
                        y: y
                    });
                    if (!hasLeftMouseButton(e)) {
                        self.info.state = "end";
                        untrackDocument(self.info)
                    }
                    self.fire(t, e);
                    self.info.started = true
                }
            };
            var upfn = function upfn(e) {
                if (self.info.started)
                    movefn(e);
                untrackDocument(self.info)
            };
            trackDocument(this.info, movefn, upfn);
            this.info.x = e.clientX;
            this.info.y = e.clientY
        },
        touchstart: function(e) {
            var ct = e.changedTouches[0];
            this.info.x = ct.clientX;
            this.info.y = ct.clientY
        },
        touchmove: function(e) {
            var t = Gestures.findOriginalTarget(e);
            var ct = e.changedTouches[0];
            var x = ct.clientX
              , y = ct.clientY;
            if (this.hasMovedEnough(x, y)) {
                if (this.info.state === "start")
                    Gestures.prevent("tap");
                this.info.addMove({
                    x: x,
                    y: y
                });
                this.fire(t, ct);
                this.info.state = "track";
                this.info.started = true
            }
        },
        touchend: function(e) {
            var t = Gestures.findOriginalTarget(e);
            var ct = e.changedTouches[0];
            if (this.info.started) {
                this.info.state = "end";
                this.info.addMove({
                    x: ct.clientX,
                    y: ct.clientY
                });
                this.fire(t, ct, e)
            }
        },
        fire: function(target, touch, preventer) {
            var secondlast = this.info.moves[this.info.moves.length - 2];
            var lastmove = this.info.moves[this.info.moves.length - 1];
            var dx = lastmove.x - this.info.x;
            var dy = lastmove.y - this.info.y;
            var ddx, ddy = 0;
            if (secondlast) {
                ddx = lastmove.x - secondlast.x;
                ddy = lastmove.y - secondlast.y
            }
            return Gestures.fire(target, "track", {
                state: this.info.state,
                x: touch.clientX,
                y: touch.clientY,
                dx: dx,
                dy: dy,
                ddx: ddx,
                ddy: ddy,
                sourceEvent: touch,
                preventer: preventer,
                hover: function() {
                    return Gestures.deepTargetFind(touch.clientX, touch.clientY)
                }
            })
        }
    });
    Gestures.register({
        name: "tap",
        deps: ["mousedown", "click", "touchstart", "touchend"],
        flow: {
            start: ["mousedown", "touchstart"],
            end: ["click", "touchend"]
        },
        emits: ["tap"],
        info: {
            x: NaN,
            y: NaN,
            prevent: false
        },
        reset: function() {
            this.info.x = NaN;
            this.info.y = NaN;
            this.info.prevent = false
        },
        save: function(e) {
            this.info.x = e.clientX;
            this.info.y = e.clientY
        },
        mousedown: function(e) {
            if (hasLeftMouseButton(e))
                this.save(e)
        },
        click: function(e) {
            if (hasLeftMouseButton(e))
                this.forward(e)
        },
        touchstart: function(e) {
            this.save(e.changedTouches[0], e)
        },
        touchend: function(e) {
            this.forward(e.changedTouches[0], e)
        },
        forward: function(e, preventer) {
            var dx = Math.abs(e.clientX - this.info.x);
            var dy = Math.abs(e.clientY - this.info.y);
            var t = Gestures.findOriginalTarget(e);
            if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e))
                if (!this.info.prevent)
                    Gestures.fire(t, "tap", {
                        x: e.clientX,
                        y: e.clientY,
                        sourceEvent: e,
                        preventer: preventer
                    })
        }
    });
    var DIRECTION_MAP = {
        x: "pan-x",
        y: "pan-y",
        none: "none",
        all: "auto"
    };
    Polymer.Base._addFeature({
        _setupGestures: function() {
            this.__polymerGestures = null
        },
        _listen: function(node, eventName, handler) {
            if (Gestures.gestures[eventName])
                Gestures.add(node, eventName, handler);
            else
                node.addEventListener(eventName, handler)
        },
        _unlisten: function(node, eventName, handler) {
            if (Gestures.gestures[eventName])
                Gestures.remove(node, eventName, handler);
            else
                node.removeEventListener(eventName, handler)
        },
        setScrollDirection: function(direction, node) {
            node = node || this;
            Gestures.setTouchAction(node, DIRECTION_MAP[direction] || "auto")
        }
    });
    Polymer.Gestures = Gestures
}
)();
(function() {
    Polymer.Base._addFeature({
        $$: function(slctr) {
            return Polymer.dom(this.root).querySelector(slctr)
        },
        toggleClass: function(name, bool, node) {
            node = node || this;
            if (arguments.length == 1)
                bool = !node.classList.contains(name);
            if (bool)
                Polymer.dom(node).classList.add(name);
            else
                Polymer.dom(node).classList.remove(name)
        },
        toggleAttribute: function(name, bool, node) {
            node = node || this;
            if (arguments.length == 1)
                bool = !node.hasAttribute(name);
            if (bool)
                Polymer.dom(node).setAttribute(name, "");
            else
                Polymer.dom(node).removeAttribute(name)
        },
        classFollows: function(name, toElement, fromElement) {
            if (fromElement)
                Polymer.dom(fromElement).classList.remove(name);
            if (toElement)
                Polymer.dom(toElement).classList.add(name)
        },
        attributeFollows: function(name, toElement, fromElement) {
            if (fromElement)
                Polymer.dom(fromElement).removeAttribute(name);
            if (toElement)
                Polymer.dom(toElement).setAttribute(name, "")
        },
        getEffectiveChildNodes: function() {
            return Polymer.dom(this).getEffectiveChildNodes()
        },
        getEffectiveChildren: function() {
            var list = Polymer.dom(this).getEffectiveChildNodes();
            return list.filter(function(n) {
                return n.nodeType === Node.ELEMENT_NODE
            })
        },
        getEffectiveTextContent: function() {
            var cn = this.getEffectiveChildNodes();
            var tc = [];
            for (var i = 0, c; c = cn[i]; i++)
                if (c.nodeType !== Node.COMMENT_NODE)
                    tc.push(Polymer.dom(c).textContent);
            return tc.join("")
        },
        queryEffectiveChildren: function(slctr) {
            var e$ = Polymer.dom(this).queryDistributedElements(slctr);
            return e$ && e$[0]
        },
        queryAllEffectiveChildren: function(slctr) {
            return Polymer.dom(this).queryDistributedElements(slctr)
        },
        getContentChildNodes: function(slctr) {
            var content = Polymer.dom(this.root).querySelector(slctr || "content");
            return content ? Polymer.dom(content).getDistributedNodes() : []
        },
        getContentChildren: function(slctr) {
            return this.getContentChildNodes(slctr).filter(function(n) {
                return n.nodeType === Node.ELEMENT_NODE
            })
        },
        fire: function(type, detail, options) {
            options = options || Polymer.nob;
            var node = options.node || this;
            detail = detail === null || detail === undefined ? {} : detail;
            var bubbles = options.bubbles === undefined ? true : options.bubbles;
            var cancelable = Boolean(options.cancelable);
            var useCache = options._useCache;
            var event = this._getEvent(type, bubbles, cancelable, useCache);
            event.detail = detail;
            if (useCache)
                this.__eventCache[type] = null;
            node.dispatchEvent(event);
            if (useCache)
                this.__eventCache[type] = event;
            return event
        },
        __eventCache: {},
        _getEvent: function(type, bubbles, cancelable, useCache) {
            var event = useCache && this.__eventCache[type];
            if (!event || (event.bubbles != bubbles || event.cancelable != cancelable))
                event = new Event(type,{
                    bubbles: Boolean(bubbles),
                    cancelable: cancelable
                });
            return event
        },
        async: function(callback, waitTime) {
            var self = this;
            return Polymer.Async.run(function() {
                callback.call(self)
            }, waitTime)
        },
        cancelAsync: function(handle) {
            Polymer.Async.cancel(handle)
        },
        arrayDelete: function(path, item) {
            var index;
            if (Array.isArray(path)) {
                index = path.indexOf(item);
                if (index >= 0)
                    return path.splice(index, 1)
            } else {
                var arr = this._get(path);
                index = arr.indexOf(item);
                if (index >= 0)
                    return this.splice(path, index, 1)
            }
        },
        transform: function(transform, node) {
            node = node || this;
            node.style.webkitTransform = transform;
            node.style.transform = transform
        },
        translate3d: function(x, y, z, node) {
            node = node || this;
            this.transform("translate3d(" + x + "," + y + "," + z + ")", node)
        },
        importHref: function(href, onload, onerror, optAsync) {
            var link = document.createElement("link");
            link.rel = "import";
            link.href = href;
            var list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {};
            var cached = list[link.href];
            var imprt = cached || link;
            var self = this;
            var loadListener = function(e) {
                e.target.__firedLoad = true;
                e.target.removeEventListener("load", loadListener);
                e.target.removeEventListener("error", errorListener);
                return onload.call(self, e)
            };
            var errorListener = function(e) {
                e.target.__firedError = true;
                e.target.removeEventListener("load", loadListener);
                e.target.removeEventListener("error", errorListener);
                return onerror.call(self, e)
            };
            if (onload)
                imprt.addEventListener("load", loadListener);
            if (onerror)
                imprt.addEventListener("error", errorListener);
            if (cached) {
                if (cached.__firedLoad)
                    cached.dispatchEvent(new Event("load"));
                if (cached.__firedError)
                    cached.dispatchEvent(new Event("error"))
            } else {
                list[link.href] = link;
                optAsync = Boolean(optAsync);
                if (optAsync)
                    link.setAttribute("async", "");
                document.head.appendChild(link)
            }
            return imprt
        },
        create: function(tag, props) {
            var elt = document.createElement(tag);
            if (props)
                for (var n in props)
                    elt[n] = props[n];
            return elt
        },
        isLightDescendant: function(node) {
            return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot()
        },
        isLocalDescendant: function(node) {
            return this.root === Polymer.dom(node).getOwnerRoot()
        }
    });
    if (!Polymer.Settings.useNativeCustomElements) {
        var importHref = Polymer.Base.importHref;
        Polymer.Base.importHref = function(href, onload, onerror, optAsync) {
            CustomElements.ready = false;
            var loadFn = function(e) {
                CustomElements.upgradeDocumentTree(document);
                CustomElements.ready = true;
                if (onload)
                    return onload.call(this, e)
            };
            return importHref.call(this, href, loadFn, onerror, optAsync)
        }
    }
}
)();
Polymer.Bind = {
    prepareModel: function(model) {
        Polymer.Base.mixin(model, this._modelApi)
    },
    _modelApi: {
        _notifyChange: function(source, event, value) {
            value = value === undefined ? this[source] : value;
            event = event || Polymer.CaseMap.camelToDashCase(source) + "-changed";
            this.fire(event, {
                value: value
            }, {
                bubbles: false,
                cancelable: false,
                _useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
            })
        },
        _propertySetter: function(property, value, effects, fromAbove) {
            var old = this.__data__[property];
            if (old !== value && (old === old || value === value)) {
                this.__data__[property] = value;
                if (typeof value == "object")
                    this._clearPath(property);
                if (this._propertyChanged)
                    this._propertyChanged(property, value, old);
                if (effects)
                    this._effectEffects(property, value, effects, old, fromAbove)
            }
            return old
        },
        __setProperty: function(property, value, quiet, node) {
            node = node || this;
            var effects = node._propertyEffects && node._propertyEffects[property];
            if (effects)
                node._propertySetter(property, value, effects, quiet);
            else if (node[property] !== value)
                node[property] = value
        },
        _effectEffects: function(property, value, effects, old, fromAbove) {
            for (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++)
                fx.fn.call(this, property, this[property], fx.effect, old, fromAbove)
        },
        _clearPath: function(path) {
            for (var prop in this.__data__)
                if (Polymer.Path.isDescendant(path, prop))
                    this.__data__[prop] = undefined
        }
    },
    ensurePropertyEffects: function(model, property) {
        if (!model._propertyEffects)
            model._propertyEffects = {};
        var fx = model._propertyEffects[property];
        if (!fx)
            fx = model._propertyEffects[property] = [];
        return fx
    },
    addPropertyEffect: function(model, property, kind, effect) {
        var fx = this.ensurePropertyEffects(model, property);
        var propEffect = {
            kind: kind,
            effect: effect,
            fn: Polymer.Bind["_" + kind + "Effect"]
        };
        fx.push(propEffect);
        return propEffect
    },
    createBindings: function(model) {
        var fx$ = model._propertyEffects;
        if (fx$)
            for (var n in fx$) {
                var fx = fx$[n];
                fx.sort(this._sortPropertyEffects);
                this._createAccessors(model, n, fx)
            }
    },
    _sortPropertyEffects: function() {
        var EFFECT_ORDER = {
            "compute": 0,
            "annotation": 1,
            "annotatedComputation": 2,
            "reflect": 3,
            "notify": 4,
            "observer": 5,
            "complexObserver": 6,
            "function": 7
        };
        return function(a, b) {
            return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind]
        }
    }(),
    _createAccessors: function(model, property, effects) {
        var defun = {
            get: function() {
                return this.__data__[property]
            }
        };
        var setter = function(value) {
            this._propertySetter(property, value, effects)
        };
        var info = model.getPropertyInfo && model.getPropertyInfo(property);
        if (info && info.readOnly) {
            if (!info.computed)
                model["_set" + this.upper(property)] = setter
        } else
            defun.set = setter;
        Object.defineProperty(model, property, defun)
    },
    upper: function(name) {
        return name[0].toUpperCase() + name.substring(1)
    },
    _addAnnotatedListener: function(model, index, property, path, event, negated) {
        if (!model._bindListeners)
            model._bindListeners = [];
        var fn = this._notedListenerFactory(property, path, Polymer.Path.isDeep(path), negated);
        var eventName = event || Polymer.CaseMap.camelToDashCase(property) + "-changed";
        model._bindListeners.push({
            index: index,
            property: property,
            path: path,
            changedFn: fn,
            event: eventName
        })
    },
    _isEventBogus: function(e, target) {
        return e.path && e.path[0] !== target
    },
    _notedListenerFactory: function(property, path, isStructured, negated) {
        return function(target, value, targetPath) {
            if (targetPath) {
                var newPath = Polymer.Path.translate(property, path, targetPath);
                this._notifyPath(newPath, value)
            } else {
                value = target[property];
                if (negated)
                    value = !value;
                if (!isStructured)
                    this[path] = value;
                else if (this.__data__[path] != value)
                    this.set(path, value)
            }
        }
    },
    prepareInstance: function(inst) {
        inst.__data__ = Object.create(null)
    },
    setupBindListeners: function(inst) {
        var b$ = inst._bindListeners;
        for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
            var node = inst._nodes[info.index];
            this._addNotifyListener(node, inst, info.event, info.changedFn)
        }
    },
    _addNotifyListener: function(element, context, event, changedFn) {
        element.addEventListener(event, function(e) {
            return context._notifyListener(changedFn, e)
        })
    }
};
Polymer.Base.mixin(Polymer.Bind, {
    _shouldAddListener: function(effect) {
        return effect.name && effect.kind != "attribute" && effect.kind != "text" && !effect.isCompound && effect.parts[0].mode === "{"
    },
    _annotationEffect: function(source, value, effect) {
        if (source != effect.value) {
            value = this._get(effect.value);
            this.__data__[effect.value] = value
        }
        this._applyEffectValue(effect, value)
    },
    _reflectEffect: function(source, value, effect) {
        this.reflectPropertyToAttribute(source, effect.attribute, value)
    },
    _notifyEffect: function(source, value, effect, old, fromAbove) {
        if (!fromAbove)
            this._notifyChange(source, effect.event, value)
    },
    _functionEffect: function(source, value, fn, old, fromAbove) {
        fn.call(this, source, value, old, fromAbove)
    },
    _observerEffect: function(source, value, effect, old) {
        var fn = this[effect.method];
        if (fn)
            fn.call(this, value, old);
        else
            this._warn(this._logf("_observerEffect", "observer method `" + effect.method + "` not defined"))
    },
    _complexObserverEffect: function(source, value, effect) {
        var fn = this[effect.method];
        if (fn) {
            var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
            if (args)
                fn.apply(this, args)
        } else if (effect.dynamicFn)
            ;
        else
            this._warn(this._logf("_complexObserverEffect", "observer method `" + effect.method + "` not defined"))
    },
    _computeEffect: function(source, value, effect) {
        var fn = this[effect.method];
        if (fn) {
            var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
            if (args) {
                var computedvalue = fn.apply(this, args);
                this.__setProperty(effect.name, computedvalue)
            }
        } else if (effect.dynamicFn)
            ;
        else
            this._warn(this._logf("_computeEffect", "compute method `" + effect.method + "` not defined"))
    },
    _annotatedComputationEffect: function(source, value, effect) {
        var computedHost = this._rootDataHost || this;
        var fn = computedHost[effect.method];
        if (fn) {
            var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
            if (args) {
                var computedvalue = fn.apply(computedHost, args);
                this._applyEffectValue(effect, computedvalue)
            }
        } else if (effect.dynamicFn)
            ;
        else
            computedHost._warn(computedHost._logf("_annotatedComputationEffect", "compute method `" + effect.method + "` not defined"))
    },
    _marshalArgs: function(model, effect, path, value) {
        var values = [];
        var args = effect.args;
        var bailoutEarly = args.length > 1 || effect.dynamicFn;
        for (var i = 0, l = args.length; i < l; i++) {
            var arg = args[i];
            var name = arg.name;
            var v;
            if (arg.literal)
                v = arg.value;
            else if (path === name)
                v = value;
            else {
                v = model[name];
                if (v === undefined && arg.structured)
                    v = Polymer.Base._get(name, model)
            }
            if (bailoutEarly && v === undefined)
                return;
            if (arg.wildcard) {
                var matches = Polymer.Path.isAncestor(path, name);
                values[i] = {
                    path: matches ? path : name,
                    value: matches ? value : v,
                    base: v
                }
            } else
                values[i] = v
        }
        return values
    }
});
Polymer.Base._addFeature({
    _addPropertyEffect: function(property, kind, effect) {
        var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
        prop.pathFn = this["_" + prop.kind + "PathEffect"]
    },
    _prepEffects: function() {
        Polymer.Bind.prepareModel(this);
        this._addAnnotationEffects(this._notes)
    },
    _prepBindings: function() {
        Polymer.Bind.createBindings(this)
    },
    _addPropertyEffects: function(properties) {
        if (properties)
            for (var p in properties) {
                var prop = properties[p];
                if (prop.observer)
                    this._addObserverEffect(p, prop.observer);
                if (prop.computed) {
                    prop.readOnly = true;
                    this._addComputedEffect(p, prop.computed)
                }
                if (prop.notify)
                    this._addPropertyEffect(p, "notify", {
                        event: Polymer.CaseMap.camelToDashCase(p) + "-changed"
                    });
                if (prop.reflectToAttribute) {
                    var attr = Polymer.CaseMap.camelToDashCase(p);
                    if (attr[0] === "-")
                        this._warn(this._logf("_addPropertyEffects", "Property " + p + " cannot be reflected to attribute " + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
                    else
                        this._addPropertyEffect(p, "reflect", {
                            attribute: attr
                        })
                }
                if (prop.readOnly)
                    Polymer.Bind.ensurePropertyEffects(this, p)
            }
    },
    _addComputedEffect: function(name, expression) {
        var sig = this._parseMethod(expression);
        var dynamicFn = sig.dynamicFn;
        for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++)
            this._addPropertyEffect(arg.model, "compute", {
                method: sig.method,
                args: sig.args,
                trigger: arg,
                name: name,
                dynamicFn: dynamicFn
            });
        if (dynamicFn)
            this._addPropertyEffect(sig.method, "compute", {
                method: sig.method,
                args: sig.args,
                trigger: null,
                name: name,
                dynamicFn: dynamicFn
            })
    },
    _addObserverEffect: function(property, observer) {
        this._addPropertyEffect(property, "observer", {
            method: observer,
            property: property
        })
    },
    _addComplexObserverEffects: function(observers) {
        if (observers)
            for (var i = 0, o; i < observers.length && (o = observers[i]); i++)
                this._addComplexObserverEffect(o)
    },
    _addComplexObserverEffect: function(observer) {
        var sig = this._parseMethod(observer);
        if (!sig)
            throw new Error("Malformed observer expression '" + observer + "'");
        var dynamicFn = sig.dynamicFn;
        for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++)
            this._addPropertyEffect(arg.model, "complexObserver", {
                method: sig.method,
                args: sig.args,
                trigger: arg,
                dynamicFn: dynamicFn
            });
        if (dynamicFn)
            this._addPropertyEffect(sig.method, "complexObserver", {
                method: sig.method,
                args: sig.args,
                trigger: null,
                dynamicFn: dynamicFn
            })
    },
    _addAnnotationEffects: function(notes) {
        for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
            var b$ = note.bindings;
            for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++)
                this._addAnnotationEffect(binding, i)
        }
    },
    _addAnnotationEffect: function(note, index) {
        if (Polymer.Bind._shouldAddListener(note))
            Polymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
        for (var i = 0; i < note.parts.length; i++) {
            var part = note.parts[i];
            if (part.signature)
                this._addAnnotatedComputationEffect(note, part, index);
            else if (!part.literal)
                if (note.kind === "attribute" && note.name[0] === "-")
                    this._warn(this._logf("_addAnnotationEffect", "Cannot set attribute " + note.name + ' because "-" is not a valid attribute starting character'));
                else
                    this._addPropertyEffect(part.model, "annotation", {
                        kind: note.kind,
                        index: index,
                        name: note.name,
                        propertyName: note.propertyName,
                        value: part.value,
                        isCompound: note.isCompound,
                        compoundIndex: part.compoundIndex,
                        event: part.event,
                        customEvent: part.customEvent,
                        negate: part.negate
                    })
        }
    },
    _addAnnotatedComputationEffect: function(note, part, index) {
        var sig = part.signature;
        if (sig["static"])
            this.__addAnnotatedComputationEffect("__static__", index, note, part, null);
        else {
            for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++)
                if (!arg.literal)
                    this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
            if (sig.dynamicFn)
                this.__addAnnotatedComputationEffect(sig.method, index, note, part, null)
        }
    },
    __addAnnotatedComputationEffect: function(property, index, note, part, trigger) {
        this._addPropertyEffect(property, "annotatedComputation", {
            index: index,
            isCompound: note.isCompound,
            compoundIndex: part.compoundIndex,
            kind: note.kind,
            name: note.name,
            negate: part.negate,
            method: part.signature.method,
            args: part.signature.args,
            trigger: trigger,
            dynamicFn: part.signature.dynamicFn
        })
    },
    _parseMethod: function(expression) {
        var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
        if (m) {
            var sig = {
                method: m[1],
                "static": true
            };
            if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
                sig["static"] = false;
                sig.dynamicFn = true
            }
            if (m[2].trim()) {
                var args = m[2].replace(/\\,/g, "&comma;").split(",");
                return this._parseArgs(args, sig)
            } else {
                sig.args = Polymer.nar;
                return sig
            }
        }
    },
    _parseArgs: function(argList, sig) {
        sig.args = argList.map(function(rawArg) {
            var arg = this._parseArg(rawArg);
            if (!arg.literal)
                sig["static"] = false;
            return arg
        }, this);
        return sig
    },
    _parseArg: function(rawArg) {
        var arg = rawArg.trim().replace(/&comma;/g, ",").replace(/\\(.)/g, "$1");
        var a = {
            name: arg
        };
        var fc = arg[0];
        if (fc === "-")
            fc = arg[1];
        if (fc >= "0" && fc <= "9")
            fc = "#";
        switch (fc) {
        case "'":
        case '"':
            a.value = arg.slice(1, -1);
            a.literal = true;
            break;
        case "#":
            a.value = Number(arg);
            a.literal = true;
            break
        }
        if (!a.literal) {
            a.model = Polymer.Path.root(arg);
            a.structured = Polymer.Path.isDeep(arg);
            if (a.structured) {
                a.wildcard = arg.slice(-2) == ".*";
                if (a.wildcard)
                    a.name = arg.slice(0, -2)
            }
        }
        return a
    },
    _marshalInstanceEffects: function() {
        Polymer.Bind.prepareInstance(this);
        if (this._bindListeners)
            Polymer.Bind.setupBindListeners(this)
    },
    _applyEffectValue: function(info, value) {
        var node = this._nodes[info.index];
        var property = info.name;
        value = this._computeFinalAnnotationValue(node, property, value, info);
        if (info.kind == "attribute")
            this.serializeValueToAttribute(value, property, node);
        else {
            var pinfo = node._propertyInfo && node._propertyInfo[property];
            if (pinfo && pinfo.readOnly)
                return;
            this.__setProperty(property, value, Polymer.Settings.suppressBindingNotifications, node)
        }
    },
    _computeFinalAnnotationValue: function(node, property, value, info) {
        if (info.negate)
            value = !value;
        if (info.isCompound) {
            var storage = node.__compoundStorage__[property];
            storage[info.compoundIndex] = value;
            value = storage.join("")
        }
        if (info.kind !== "attribute") {
            if (property === "className")
                value = this._scopeElementClass(node, value);
            if (property === "textContent" || node.localName == "input" && property == "value")
                value = value == undefined ? "" : value
        }
        return value
    },
    _executeStaticEffects: function() {
        if (this._propertyEffects && this._propertyEffects.__static__)
            this._effectEffects("__static__", null, this._propertyEffects.__static__)
    }
});
(function() {
    var usePolyfillProto = Polymer.Settings.usePolyfillProto;
    var avoidInstanceProperties = Boolean(Object.getOwnPropertyDescriptor(document.documentElement, "properties"));
    Polymer.Base._addFeature({
        _setupConfigure: function(initialConfig) {
            this._config = {};
            this._handlers = [];
            this._aboveConfig = null;
            if (initialConfig)
                for (var i in initialConfig)
                    if (initialConfig[i] !== undefined)
                        this._config[i] = initialConfig[i]
        },
        _marshalAttributes: function() {
            this._takeAttributesToModel(this._config)
        },
        _attributeChangedImpl: function(name) {
            var model = this._clientsReadied ? this : this._config;
            this._setAttributeToProperty(model, name)
        },
        _configValue: function(name, value) {
            var info = this._propertyInfo[name];
            if (!info || !info.readOnly)
                this._config[name] = value
        },
        _beforeClientsReady: function() {
            this._configure()
        },
        _configure: function() {
            this._configureAnnotationReferences();
            this._configureInstanceProperties();
            this._aboveConfig = this.mixin({}, this._config);
            var config = {};
            for (var i = 0; i < this.behaviors.length; i++)
                this._configureProperties(this.behaviors[i].properties, config);
            this._configureProperties(avoidInstanceProperties ? this.__proto__.properties : this.properties, config);
            this.mixin(config, this._aboveConfig);
            this._config = config;
            if (this._clients && this._clients.length)
                this._distributeConfig(this._config)
        },
        _configureInstanceProperties: function() {
            for (var i in this._propertyEffects)
                if (!usePolyfillProto && this.hasOwnProperty(i)) {
                    this._configValue(i, this[i]);
                    delete this[i]
                }
        },
        _configureProperties: function(properties, config) {
            for (var i in properties) {
                var c = properties[i];
                if (c.value !== undefined) {
                    var value = c.value;
                    if (typeof value == "function")
                        value = value.call(this, this._config);
                    config[i] = value
                }
            }
        },
        _distributeConfig: function(config) {
            var fx$ = this._propertyEffects;
            if (fx$)
                for (var p in config) {
                    var fx = fx$[p];
                    if (fx)
                        for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++)
                            if (x.kind === "annotation") {
                                var node = this._nodes[x.effect.index];
                                var name = x.effect.propertyName;
                                var isAttr = x.effect.kind == "attribute";
                                var hasEffect = node._propertyEffects && node._propertyEffects[name];
                                if (node._configValue && (hasEffect || !isAttr)) {
                                    var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
                                    value = this._computeFinalAnnotationValue(node, name, value, x.effect);
                                    if (isAttr)
                                        value = node.deserialize(this.serialize(value), node._propertyInfo[name].type);
                                    node._configValue(name, value)
                                }
                            }
                }
        },
        _afterClientsReady: function() {
            this.importPath = this._importPath;
            this.rootPath = Polymer.rootPath;
            this._executeStaticEffects();
            this._applyConfig(this._config, this._aboveConfig);
            this._flushHandlers()
        },
        _applyConfig: function(config, aboveConfig) {
            for (var n in config)
                if (this[n] === undefined)
                    this.__setProperty(n, config[n], n in aboveConfig)
        },
        _notifyListener: function(fn, e) {
            if (!Polymer.Bind._isEventBogus(e, e.target)) {
                var value, path;
                if (e.detail) {
                    value = e.detail.value;
                    path = e.detail.path
                }
                if (!this._clientsReadied)
                    this._queueHandler([fn, e.target, value, path]);
                else
                    return fn.call(this, e.target, value, path)
            }
        },
        _queueHandler: function(args) {
            this._handlers.push(args)
        },
        _flushHandlers: function() {
            var h$ = this._handlers;
            for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++)
                h[0].call(this, h[1], h[2], h[3]);
            this._handlers = []
        }
    })
}
)();
(function() {
    var Path = Polymer.Path;
    Polymer.Base._addFeature({
        notifyPath: function(path, value, fromAbove) {
            var info = {};
            var v = this._get(path, this, info);
            if (arguments.length === 1)
                value = v;
            if (info.path)
                this._notifyPath(info.path, value, fromAbove)
        },
        _notifyPath: function(path, value, fromAbove) {
            var old = this._propertySetter(path, value);
            if (old !== value && (old === old || value === value)) {
                this._pathEffector(path, value);
                if (!fromAbove)
                    this._notifyPathUp(path, value);
                return true
            }
        },
        _getPathParts: function(path) {
            if (Array.isArray(path)) {
                var parts = [];
                for (var i = 0; i < path.length; i++) {
                    var args = path[i].toString().split(".");
                    for (var j = 0; j < args.length; j++)
                        parts.push(args[j])
                }
                return parts
            } else
                return path.toString().split(".")
        },
        set: function(path, value, root) {
            var prop = root || this;
            var parts = this._getPathParts(path);
            var array;
            var last = parts[parts.length - 1];
            if (parts.length > 1) {
                for (var i = 0; i < parts.length - 1; i++) {
                    var part = parts[i];
                    if (array && part[0] == "#")
                        prop = Polymer.Collection.get(array).getItem(part);
                    else {
                        prop = prop[part];
                        if (array && parseInt(part, 10) == part)
                            parts[i] = Polymer.Collection.get(array).getKey(prop)
                    }
                    if (!prop)
                        return;
                    array = Array.isArray(prop) ? prop : null
                }
                if (array) {
                    var coll = Polymer.Collection.get(array);
                    var old, key;
                    if (last[0] == "#") {
                        key = last;
                        old = coll.getItem(key);
                        last = array.indexOf(old);
                        coll.setItem(key, value)
                    } else if (parseInt(last, 10) == last) {
                        old = prop[last];
                        key = coll.getKey(old);
                        parts[i] = key;
                        coll.setItem(key, value)
                    }
                }
                prop[last] = value;
                if (!root)
                    this._notifyPath(parts.join("."), value)
            } else
                prop[path] = value
        },
        get: function(path, root) {
            return this._get(path, root)
        },
        _get: function(path, root, info) {
            var prop = root || this;
            var parts = this._getPathParts(path);
            var array;
            for (var i = 0; i < parts.length; i++) {
                if (!prop)
                    return;
                var part = parts[i];
                if (array && part[0] == "#")
                    prop = Polymer.Collection.get(array).getItem(part);
                else {
                    prop = prop[part];
                    if (info && array && parseInt(part, 10) == part)
                        parts[i] = Polymer.Collection.get(array).getKey(prop)
                }
                array = Array.isArray(prop) ? prop : null
            }
            if (info)
                info.path = parts.join(".");
            return prop
        },
        _pathEffector: function(path, value) {
            var model = Path.root(path);
            var fx$ = this._propertyEffects && this._propertyEffects[model];
            if (fx$)
                for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
                    var fxFn = fx.pathFn;
                    if (fxFn)
                        fxFn.call(this, path, value, fx.effect)
                }
            if (this._boundPaths)
                this._notifyBoundPaths(path, value)
        },
        _annotationPathEffect: function(path, value, effect) {
            if (Path.matches(effect.value, false, path))
                Polymer.Bind._annotationEffect.call(this, path, value, effect);
            else if (!effect.negate && Path.isDescendant(effect.value, path)) {
                var node = this._nodes[effect.index];
                if (node && node._notifyPath) {
                    var newPath = Path.translate(effect.value, effect.name, path);
                    node._notifyPath(newPath, value, true)
                }
            }
        },
        _complexObserverPathEffect: function(path, value, effect) {
            if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path))
                Polymer.Bind._complexObserverEffect.call(this, path, value, effect)
        },
        _computePathEffect: function(path, value, effect) {
            if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path))
                Polymer.Bind._computeEffect.call(this, path, value, effect)
        },
        _annotatedComputationPathEffect: function(path, value, effect) {
            if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path))
                Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect)
        },
        linkPaths: function(to, from) {
            this._boundPaths = this._boundPaths || {};
            if (from)
                this._boundPaths[to] = from;
            else
                this.unlinkPaths(to)
        },
        unlinkPaths: function(path) {
            if (this._boundPaths)
                delete this._boundPaths[path]
        },
        _notifyBoundPaths: function(path, value) {
            for (var a in this._boundPaths) {
                var b = this._boundPaths[a];
                if (Path.isDescendant(a, path))
                    this._notifyPath(Path.translate(a, b, path), value);
                else if (Path.isDescendant(b, path))
                    this._notifyPath(Path.translate(b, a, path), value)
            }
        },
        _notifyPathUp: function(path, value) {
            var rootName = Path.root(path);
            var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
            var eventName = dashCaseName + this._EVENT_CHANGED;
            this.fire(eventName, {
                path: path,
                value: value
            }, {
                bubbles: false,
                _useCache: Polymer.Settings.eventDataCache || !Polymer.Settings.isIE
            })
        },
        _EVENT_CHANGED: "-changed",
        notifySplices: function(path, splices) {
            var info = {};
            var array = this._get(path, this, info);
            this._notifySplices(array, info.path, splices)
        },
        _notifySplices: function(array, path, splices) {
            var change = {
                keySplices: Polymer.Collection.applySplices(array, splices),
                indexSplices: splices
            };
            var splicesPath = path + ".splices";
            this._notifyPath(splicesPath, change);
            this._notifyPath(path + ".length", array.length);
            this.__data__[splicesPath] = {
                keySplices: null,
                indexSplices: null
            }
        },
        _notifySplice: function(array, path, index, added, removed) {
            this._notifySplices(array, path, [{
                index: index,
                addedCount: added,
                removed: removed,
                object: array,
                type: "splice"
            }])
        },
        push: function(path) {
            var info = {};
            var array = this._get(path, this, info);
            var args = Array.prototype.slice.call(arguments, 1);
            var len = array.length;
            var ret = array.push.apply(array, args);
            if (args.length)
                this._notifySplice(array, info.path, len, args.length, []);
            return ret
        },
        pop: function(path) {
            var info = {};
            var array = this._get(path, this, info);
            var hadLength = Boolean(array.length);
            var args = Array.prototype.slice.call(arguments, 1);
            var ret = array.pop.apply(array, args);
            if (hadLength)
                this._notifySplice(array, info.path, array.length, 0, [ret]);
            return ret
        },
        splice: function(path, start) {
            var info = {};
            var array = this._get(path, this, info);
            if (start < 0)
                start = array.length - Math.floor(-start);
            else
                start = Math.floor(start);
            if (!start)
                start = 0;
            var args = Array.prototype.slice.call(arguments, 1);
            var ret = array.splice.apply(array, args);
            var addedCount = Math.max(args.length - 2, 0);
            if (addedCount || ret.length)
                this._notifySplice(array, info.path, start, addedCount, ret);
            return ret
        },
        shift: function(path) {
            var info = {};
            var array = this._get(path, this, info);
            var hadLength = Boolean(array.length);
            var args = Array.prototype.slice.call(arguments, 1);
            var ret = array.shift.apply(array, args);
            if (hadLength)
                this._notifySplice(array, info.path, 0, 0, [ret]);
            return ret
        },
        unshift: function(path) {
            var info = {};
            var array = this._get(path, this, info);
            var args = Array.prototype.slice.call(arguments, 1);
            var ret = array.unshift.apply(array, args);
            if (args.length)
                this._notifySplice(array, info.path, 0, args.length, []);
            return ret
        },
        prepareModelNotifyPath: function(model) {
            this.mixin(model, {
                fire: Polymer.Base.fire,
                _getEvent: Polymer.Base._getEvent,
                __eventCache: Polymer.Base.__eventCache,
                notifyPath: Polymer.Base.notifyPath,
                _get: Polymer.Base._get,
                _EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
                _notifyPath: Polymer.Base._notifyPath,
                _notifyPathUp: Polymer.Base._notifyPathUp,
                _pathEffector: Polymer.Base._pathEffector,
                _annotationPathEffect: Polymer.Base._annotationPathEffect,
                _complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
                _annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
                _computePathEffect: Polymer.Base._computePathEffect,
                _notifyBoundPaths: Polymer.Base._notifyBoundPaths,
                _getPathParts: Polymer.Base._getPathParts
            })
        }
    })
}
)();
Polymer.Base._addFeature({
    resolveUrl: function(url) {
        return Polymer.ResolveUrl.resolveUrl(url, this._importPath)
    }
});
Polymer.CssParse = function() {
    return {
        parse: function(text) {
            text = this._clean(text);
            return this._parseCss(this._lex(text), text)
        },
        _clean: function(cssText) {
            return cssText.replace(this._rx.comments, "").replace(this._rx.port, "")
        },
        _lex: function(text) {
            var root = {
                start: 0,
                end: text.length
            };
            var n = root;
            for (var i = 0, l = text.length; i < l; i++)
                switch (text[i]) {
                case this.OPEN_BRACE:
                    if (!n.rules)
                        n.rules = [];
                    var p = n;
                    var previous = p.rules[p.rules.length - 1];
                    n = {
                        start: i + 1,
                        parent: p,
                        previous: previous
                    };
                    p.rules.push(n);
                    break;
                case this.CLOSE_BRACE:
                    n.end = i + 1;
                    n = n.parent || root;
                    break
                }
            return root
        },
        _parseCss: function(node, text) {
            var t = text.substring(node.start, node.end - 1);
            node.parsedCssText = node.cssText = t.trim();
            if (node.parent) {
                var ss = node.previous ? node.previous.end : node.parent.start;
                t = text.substring(ss, node.start - 1);
                t = this._expandUnicodeEscapes(t);
                t = t.replace(this._rx.multipleSpaces, " ");
                t = t.substring(t.lastIndexOf(";") + 1);
                var s = node.parsedSelector = node.selector = t.trim();
                node.atRule = s.indexOf(this.AT_START) === 0;
                if (node.atRule)
                    if (s.indexOf(this.MEDIA_START) === 0)
                        node.type = this.types.MEDIA_RULE;
                    else {
                        if (s.match(this._rx.keyframesRule)) {
                            node.type = this.types.KEYFRAMES_RULE;
                            node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop()
                        }
                    }
                else if (s.indexOf(this.VAR_START) === 0)
                    node.type = this.types.MIXIN_RULE;
                else
                    node.type = this.types.STYLE_RULE
            }
            var r$ = node.rules;
            if (r$)
                for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++)
                    this._parseCss(r, text);
            return node
        },
        _expandUnicodeEscapes: function(s) {
            return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
                var code = arguments[1]
                  , repeat = 6 - code.length;
                while (repeat--)
                    code = "0" + code;
                return "\\" + code
            })
        },
        stringify: function(node, preserveProperties, text) {
            text = text || "";
            var cssText = "";
            if (node.cssText || node.rules) {
                var r$ = node.rules;
                if (r$ && !this._hasMixinRules(r$))
                    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++)
                        cssText = this.stringify(r, preserveProperties, cssText);
                else {
                    cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
                    cssText = cssText.trim();
                    if (cssText)
                        cssText = "  " + cssText + "\n"
                }
            }
            if (cssText) {
                if (node.selector)
                    text += node.selector + " " + this.OPEN_BRACE + "\n";
                text += cssText;
                if (node.selector)
                    text += this.CLOSE_BRACE + "\n\n"
            }
            return text
        },
        _hasMixinRules: function(rules) {
            return rules[0].selector.indexOf(this.VAR_START) === 0
        },
        removeCustomProps: function(cssText) {
            cssText = this.removeCustomPropAssignment(cssText);
            return this.removeCustomPropApply(cssText)
        },
        removeCustomPropAssignment: function(cssText) {
            return cssText.replace(this._rx.customProp, "").replace(this._rx.mixinProp, "")
        },
        removeCustomPropApply: function(cssText) {
            return cssText.replace(this._rx.mixinApply, "").replace(this._rx.varApply, "")
        },
        types: {
            STYLE_RULE: 1,
            KEYFRAMES_RULE: 7,
            MEDIA_RULE: 4,
            MIXIN_RULE: 1E3
        },
        OPEN_BRACE: "{",
        CLOSE_BRACE: "}",
        _rx: {
            comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
            port: /@import[^;]*;/gim,
            customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
            mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
            mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
            varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
            keyframesRule: /^@[^\s]*keyframes/,
            multipleSpaces: /\s+/g
        },
        VAR_START: "--",
        MEDIA_START: "@media",
        AT_START: "@"
    }
}();
Polymer.StyleUtil = function() {
    var settings = Polymer.Settings;
    return {
        unscopedStyleImports: new WeakMap,
        SHADY_UNSCOPED_ATTR: "shady-unscoped",
        NATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,
        MODULE_STYLES_SELECTOR: "style, link[rel=import][type~=css], template",
        INCLUDE_ATTR: "include",
        toCssText: function(rules, callback) {
            if (typeof rules === "string")
                rules = this.parser.parse(rules);
            if (callback)
                this.forEachRule(rules, callback);
            return this.parser.stringify(rules, this.NATIVE_VARIABLES)
        },
        forRulesInStyles: function(styles, styleRuleCallback, keyframesRuleCallback) {
            if (styles)
                for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++)
                    this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback)
        },
        forActiveRulesInStyles: function(styles, styleRuleCallback, keyframesRuleCallback) {
            if (styles)
                for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++)
                    this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, true)
        },
        rulesForStyle: function(style) {
            if (!style.__cssRules && style.textContent)
                style.__cssRules = this.parser.parse(style.textContent);
            return style.__cssRules
        },
        isKeyframesSelector: function(rule) {
            return rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE
        },
        forEachRuleInStyle: function(style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
            var rules = this.rulesForStyle(style);
            var styleCallback, keyframeCallback;
            if (styleRuleCallback)
                styleCallback = function(rule) {
                    styleRuleCallback(rule, style)
                }
                ;
            if (keyframesRuleCallback)
                keyframeCallback = function(rule) {
                    keyframesRuleCallback(rule, style)
                }
                ;
            this.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules)
        },
        forEachRule: function(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
            if (!node)
                return;
            var skipRules = false;
            if (onlyActiveRules)
                if (node.type === this.ruleTypes.MEDIA_RULE) {
                    var matchMedia = node.selector.match(this.rx.MEDIA_MATCH);
                    if (matchMedia)
                        if (!window.matchMedia(matchMedia[1]).matches)
                            skipRules = true
                }
            if (node.type === this.ruleTypes.STYLE_RULE)
                styleRuleCallback(node);
            else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE)
                keyframesRuleCallback(node);
            else if (node.type === this.ruleTypes.MIXIN_RULE)
                skipRules = true;
            var r$ = node.rules;
            if (r$ && !skipRules)
                for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++)
                    this.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules)
        },
        applyCss: function(cssText, moniker, target, contextNode) {
            var style = this.createScopeStyle(cssText, moniker);
            return this.applyStyle(style, target, contextNode)
        },
        applyStyle: function(style, target, contextNode) {
            target = target || document.head;
            var after = contextNode && contextNode.nextSibling || target.firstChild;
            this.__lastHeadApplyNode = style;
            return target.insertBefore(style, after)
        },
        createScopeStyle: function(cssText, moniker) {
            var style = document.createElement("style");
            if (moniker)
                style.setAttribute("scope", moniker);
            style.textContent = cssText;
            return style
        },
        __lastHeadApplyNode: null,
        applyStylePlaceHolder: function(moniker) {
            var placeHolder = document.createComment(" Shady DOM styles for " + moniker + " ");
            var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
            var scope = document.head;
            scope.insertBefore(placeHolder, after || scope.firstChild);
            this.__lastHeadApplyNode = placeHolder;
            return placeHolder
        },
        cssFromModules: function(moduleIds, warnIfNotFound) {
            var modules = moduleIds.trim().split(/\s+/);
            var cssText = "";
            for (var i = 0; i < modules.length; i++)
                cssText += this.cssFromModule(modules[i], warnIfNotFound);
            return cssText
        },
        cssFromModule: function(moduleId, warnIfNotFound) {
            var m = Polymer.DomModule["import"](moduleId);
            if (m && !m._cssText)
                m._cssText = this.cssFromElement(m);
            if (!m && warnIfNotFound)
                console.warn("Could not find style data in module named", moduleId);
            return m && m._cssText || ""
        },
        cssFromElement: function(element) {
            var cssText = "";
            var content = element.content || element;
            var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
            for (var i = 0, e; i < e$.length; i++) {
                e = e$[i];
                if (e.localName === "template") {
                    if (!e.hasAttribute("preserve-content"))
                        cssText += this.cssFromElement(e)
                } else if (e.localName === "style") {
                    var include = e.getAttribute(this.INCLUDE_ATTR);
                    if (include)
                        cssText += this.cssFromModules(include, true);
                    e = e.__appliedElement || e;
                    e.parentNode.removeChild(e);
                    var css = this.resolveCss(e.textContent, element.ownerDocument);
                    if (!settings.useNativeShadow && e.hasAttribute(this.SHADY_UNSCOPED_ATTR)) {
                        e.textContent = css;
                        document.head.insertBefore(e, document.head.firstChild)
                    } else
                        cssText += css
                } else if (e["import"] && e["import"].body) {
                    var importCss = this.resolveCss(e["import"].body.textContent, e["import"]);
                    if (!settings.useNativeShadow && e.hasAttribute(this.SHADY_UNSCOPED_ATTR)) {
                        if (!this.unscopedStyleImports.has(e["import"])) {
                            this.unscopedStyleImports.set(e["import"], true);
                            var importStyle = document.createElement("style");
                            importStyle.setAttribute(this.SHADY_UNSCOPED_ATTR, "");
                            importStyle.textContent = importCss;
                            document.head.insertBefore(importStyle, document.head.firstChild)
                        }
                    } else
                        cssText += importCss
                }
            }
            return cssText
        },
        styleIncludesToTemplate: function(targetTemplate) {
            var styles = targetTemplate.content.querySelectorAll("style[include]");
            for (var i = 0, s; i < styles.length; i++) {
                s = styles[i];
                s.parentNode.insertBefore(this._includesToFragment(s.getAttribute("include")), s)
            }
        },
        _includesToFragment: function(styleIncludes) {
            var includeArray = styleIncludes.trim().split(" ");
            var frag = document.createDocumentFragment();
            for (var i = 0; i < includeArray.length; i++) {
                var t = Polymer.DomModule["import"](includeArray[i], "template");
                if (t)
                    this._addStylesToFragment(frag, t.content)
            }
            return frag
        },
        _addStylesToFragment: function(frag, source) {
            var s$ = source.querySelectorAll("style");
            for (var i = 0, s; i < s$.length; i++) {
                s = s$[i];
                var include = s.getAttribute("include");
                if (include)
                    frag.appendChild(this._includesToFragment(include));
                if (s.textContent)
                    frag.appendChild(s.cloneNode(true))
            }
        },
        isTargetedBuild: function(buildType) {
            return settings.useNativeShadow ? buildType === "shadow" : buildType === "shady"
        },
        cssBuildTypeForModule: function(module) {
            var dm = Polymer.DomModule["import"](module);
            if (dm)
                return this.getCssBuildType(dm)
        },
        getCssBuildType: function(element) {
            return element.getAttribute("css-build")
        },
        _findMatchingParen: function(text, start) {
            var level = 0;
            for (var i = start, l = text.length; i < l; i++)
                switch (text[i]) {
                case "(":
                    level++;
                    break;
                case ")":
                    if (--level === 0)
                        return i;
                    break
                }
            return -1
        },
        processVariableAndFallback: function(str, callback) {
            var start = str.indexOf("var(");
            if (start === -1)
                return callback(str, "", "", "");
            var end = this._findMatchingParen(str, start + 3);
            var inner = str.substring(start + 4, end);
            var prefix = str.substring(0, start);
            var suffix = this.processVariableAndFallback(str.substring(end + 1), callback);
            var comma = inner.indexOf(",");
            if (comma === -1)
                return callback(prefix, inner.trim(), "", suffix);
            var value = inner.substring(0, comma).trim();
            var fallback = inner.substring(comma + 1).trim();
            return callback(prefix, value, fallback, suffix)
        },
        rx: {
            VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
            MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
            VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
            ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
            MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
            IS_VAR: /^--/,
            BRACKETED: /\{[^}]*\}/g,
            HOST_PREFIX: "(?:^|[^.#[:])",
            HOST_SUFFIX: "($|[.:[\\s>+~])"
        },
        resolveCss: Polymer.ResolveUrl.resolveCss,
        parser: Polymer.CssParse,
        ruleTypes: Polymer.CssParse.types
    }
}();
Polymer.StyleTransformer = function() {
    var styleUtil = Polymer.StyleUtil;
    var settings = Polymer.Settings;
    var api = {
        dom: function(node, scope, useAttr, shouldRemoveScope) {
            this._transformDom(node, scope || "", useAttr, shouldRemoveScope)
        },
        _transformDom: function(node, selector, useAttr, shouldRemoveScope) {
            if (node.setAttribute)
                this.element(node, selector, useAttr, shouldRemoveScope);
            var c$ = Polymer.dom(node).childNodes;
            for (var i = 0; i < c$.length; i++)
                this._transformDom(c$[i], selector, useAttr, shouldRemoveScope)
        },
        element: function(element, scope, useAttr, shouldRemoveScope) {
            if (useAttr)
                if (shouldRemoveScope)
                    element.removeAttribute(SCOPE_NAME);
                else
                    element.setAttribute(SCOPE_NAME, scope);
            else if (scope)
                if (element.classList)
                    if (shouldRemoveScope) {
                        element.classList.remove(SCOPE_NAME);
                        element.classList.remove(scope)
                    } else {
                        element.classList.add(SCOPE_NAME);
                        element.classList.add(scope)
                    }
                else if (element.getAttribute) {
                    var c = element.getAttribute(CLASS);
                    if (shouldRemoveScope) {
                        if (c)
                            element.setAttribute(CLASS, c.replace(SCOPE_NAME, "").replace(scope, ""))
                    } else
                        element.setAttribute(CLASS, (c ? c + " " : "") + SCOPE_NAME + " " + scope)
                }
        },
        elementStyles: function(element, callback) {
            var styles = element._styles;
            var cssText = "";
            var cssBuildType = element.__cssBuild;
            var passthrough = settings.useNativeShadow || cssBuildType === "shady";
            var cb;
            if (passthrough) {
                var self = this;
                cb = function(rule) {
                    rule.selector = self._slottedToContent(rule.selector);
                    rule.selector = rule.selector.replace(ROOT, ":host > *");
                    rule.selector = self._dirShadowTransform(rule.selector);
                    if (callback)
                        callback(rule)
                }
            }
            for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
                var rules = styleUtil.rulesForStyle(s);
                cssText += passthrough ? styleUtil.toCssText(rules, cb) : this.css(rules, element.is, element["extends"], callback, element._scopeCssViaAttr) + "\n\n"
            }
            return cssText.trim()
        },
        css: function(rules, scope, ext, callback, useAttr) {
            var hostScope = this._calcHostScope(scope, ext);
            scope = this._calcElementScope(scope, useAttr);
            var self = this;
            return styleUtil.toCssText(rules, function(rule) {
                if (!rule.isScoped) {
                    self.rule(rule, scope, hostScope);
                    rule.isScoped = true
                }
                if (callback)
                    callback(rule, scope, hostScope)
            })
        },
        _calcElementScope: function(scope, useAttr) {
            if (scope)
                return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
            else
                return ""
        },
        _calcHostScope: function(scope, ext) {
            return ext ? "[is=" + scope + "]" : scope
        },
        rule: function(rule, scope, hostScope) {
            this._transformRule(rule, this._transformComplexSelector, scope, hostScope)
        },
        _transformRule: function(rule, transformer, scope, hostScope) {
            rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope)
        },
        _transformRuleCss: function(rule, transformer, scope, hostScope) {
            var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
            if (!styleUtil.isKeyframesSelector(rule))
                for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++)
                    p$[i] = transformer.call(this, p, scope, hostScope);
            return p$.join(COMPLEX_SELECTOR_SEP)
        },
        _transformComplexSelector: function(selector, scope, hostScope) {
            var stop = false;
            var hostContext = false;
            var self = this;
            selector = selector.trim();
            selector = this._slottedToContent(selector);
            selector = selector.replace(ROOT, ":host > *");
            selector = selector.replace(CONTENT_START, HOST + " $1");
            selector = selector.replace(SIMPLE_SELECTOR_SEP, function(m, c, s) {
                if (!stop) {
                    var info = self._transformCompoundSelector(s, c, scope, hostScope);
                    stop = stop || info.stop;
                    hostContext = hostContext || info.hostContext;
                    c = info.combinator;
                    s = info.value
                } else
                    s = s.replace(SCOPE_JUMP, " ");
                return c + s
            });
            if (hostContext)
                selector = selector.replace(HOST_CONTEXT_PAREN, function(m, pre, paren, post) {
                    return pre + paren + " " + hostScope + post + COMPLEX_SELECTOR_SEP + " " + pre + hostScope + paren + post
                });
            return selector
        },
        _transformCompoundSelector: function(selector, combinator, scope, hostScope) {
            var jumpIndex = selector.search(SCOPE_JUMP);
            var hostContext = false;
            if (selector.indexOf(HOST_CONTEXT) >= 0)
                hostContext = true;
            else if (selector.indexOf(HOST) >= 0)
                selector = this._transformHostSelector(selector, hostScope);
            else if (jumpIndex !== 0)
                selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
            if (selector.indexOf(CONTENT) >= 0)
                combinator = "";
            var stop;
            if (jumpIndex >= 0) {
                selector = selector.replace(SCOPE_JUMP, " ");
                stop = true
            }
            selector = selector.replace(DIR_PAREN, DIR_REPLACE);
            return {
                value: selector,
                combinator: combinator,
                stop: stop,
                hostContext: hostContext
            }
        },
        _transformSimpleSelector: function(selector, scope) {
            var p$ = selector.split(PSEUDO_PREFIX);
            p$[0] += scope;
            return p$.join(PSEUDO_PREFIX)
        },
        _transformHostSelector: function(selector, hostScope) {
            var m = selector.match(HOST_PAREN);
            var paren = m && m[2].trim() || "";
            if (paren)
                if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
                    var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
                    if (typeSelector === hostScope)
                        return paren;
                    else
                        return SELECTOR_NO_MATCH
                } else
                    return selector.replace(HOST_PAREN, function(m, host, paren) {
                        return hostScope + paren
                    });
            else
                return selector.replace(HOST, hostScope)
        },
        documentRule: function(rule) {
            rule.selector = rule.parsedSelector;
            this.normalizeRootSelector(rule);
            if (!settings.useNativeShadow)
                this._transformRule(rule, this._transformDocumentSelector)
        },
        normalizeRootSelector: function(rule) {
            rule.selector = rule.selector.replace(ROOT, "html");
            var parts = rule.selector.split(COMPLEX_SELECTOR_SEP);
            parts = parts.filter(function(part) {
                return !part.match(HOST_OR_HOST_GT_STAR)
            });
            rule.selector = parts.join(COMPLEX_SELECTOR_SEP)
        },
        _transformDocumentSelector: function(selector) {
            return this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR)
        },
        _slottedToContent: function(cssText) {
            return cssText.replace(SLOTTED_PAREN, CONTENT + "> $1")
        },
        _dirShadowTransform: function(selector) {
            return selector.split(",").map(function(s) {
                s = s.replace(HOST_DIR, HOST_DIR_REPLACE);
                s = s.replace(DIR_PAREN, SHADOW_DIR_REPLACE);
                return s
            }).join(",")
        },
        SCOPE_NAME: "style-scope"
    };
    var SCOPE_NAME = api.SCOPE_NAME;
    var SCOPE_DOC_SELECTOR = ":not([" + SCOPE_NAME + "])" + ":not(." + SCOPE_NAME + ")";
    var COMPLEX_SELECTOR_SEP = ",";
    var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
    var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
    var HOST = ":host";
    var ROOT = ":root";
    var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
    var HOST_CONTEXT = ":host-context";
    var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
    var CONTENT = "::content";
    var SCOPE_JUMP = /::content|::shadow|\/deep\//;
    var CSS_CLASS_PREFIX = ".";
    var CSS_ATTR_PREFIX = "[" + SCOPE_NAME + "~=";
    var CSS_ATTR_SUFFIX = "]";
    var PSEUDO_PREFIX = ":";
    var CLASS = "class";
    var CONTENT_START = new RegExp("^(" + CONTENT + ")");
    var SELECTOR_NO_MATCH = "should_not_match";
    var SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
    var HOST_OR_HOST_GT_STAR = /:host(?:\s*>\s*\*)?/;
    var DIR_PAREN = /(.*):dir\((ltr|rtl)\)/g;
    var DIR_REPLACE = '[dir="$2"] $1, $1[dir="$2"]';
    var SHADOW_DIR_REPLACE = ':host-context([dir="$2"]) $1';
    var HOST_DIR = /:host\(:dir\((rtl|ltr)\)\)/g;
    var HOST_DIR_REPLACE = ':host-context([dir="$1"])';
    return api
}();
Polymer.StyleExtends = function() {
    var styleUtil = Polymer.StyleUtil;
    return {
        hasExtends: function(cssText) {
            return Boolean(cssText.match(this.rx.EXTEND))
        },
        transform: function(style) {
            var rules = styleUtil.rulesForStyle(style);
            var self = this;
            styleUtil.forEachRule(rules, function(rule) {
                self._mapRuleOntoParent(rule);
                if (rule.parent) {
                    var m;
                    while (m = self.rx.EXTEND.exec(rule.cssText)) {
                        var extend = m[1];
                        var extendor = self._findExtendor(extend, rule);
                        if (extendor)
                            self._extendRule(rule, extendor)
                    }
                }
                rule.cssText = rule.cssText.replace(self.rx.EXTEND, "")
            });
            return styleUtil.toCssText(rules, function(rule) {
                if (rule.selector.match(self.rx.STRIP))
                    rule.cssText = ""
            }, true)
        },
        _mapRuleOntoParent: function(rule) {
            if (rule.parent) {
                var map = rule.parent.map || (rule.parent.map = {});
                var parts = rule.selector.split(",");
                for (var i = 0, p; i < parts.length; i++) {
                    p = parts[i];
                    map[p.trim()] = rule
                }
                return map
            }
        },
        _findExtendor: function(extend, rule) {
            return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent)
        },
        _extendRule: function(target, source) {
            if (target.parent !== source.parent)
                this._cloneAndAddRuleToParent(source, target.parent);
            target["extends"] = target["extends"] || [];
            target["extends"].push(source);
            source.selector = source.selector.replace(this.rx.STRIP, "");
            source.selector = (source.selector && source.selector + ",\n") + target.selector;
            if (source["extends"])
                source["extends"].forEach(function(e) {
                    this._extendRule(target, e)
                }, this)
        },
        _cloneAndAddRuleToParent: function(rule, parent) {
            rule = Object.create(rule);
            rule.parent = parent;
            if (rule["extends"])
                rule["extends"] = rule["extends"].slice();
            parent.rules.push(rule)
        },
        rx: {
            EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
            STRIP: /%[^,]*$/
        }
    }
}();
Polymer.ApplyShim = function() {
    var styleUtil = Polymer.StyleUtil;
    var MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;
    var VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;
    var BAD_VAR = /var\(\s*(--[^,]*),\s*(--[^)]*)\)/g;
    var APPLY_NAME_CLEAN = /;\s*/m;
    var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
    var MIXIN_VAR_SEP = "_-_";
    var mixinMap = {};
    function mapSet(name, props) {
        name = name.trim();
        mixinMap[name] = {
            properties: props,
            dependants: {}
        }
    }
    function mapGet(name) {
        name = name.trim();
        return mixinMap[name]
    }
    function replaceInitialOrInherit(property, value) {
        var match = INITIAL_INHERIT.exec(value);
        if (match)
            if (match[1])
                value = ApplyShim._getInitialValueForProperty(property);
            else
                value = "apply-shim-inherit";
        return value
    }
    function cssTextToMap(text) {
        var props = text.split(";");
        var property, value;
        var out = {};
        for (var i = 0, p, sp; i < props.length; i++) {
            p = props[i];
            if (p) {
                sp = p.split(":");
                if (sp.length > 1) {
                    property = sp[0].trim();
                    value = replaceInitialOrInherit(property, sp.slice(1).join(":"));
                    out[property] = value
                }
            }
        }
        return out
    }
    function invalidateMixinEntry(mixinEntry) {
        var currentProto = ApplyShim.__currentElementProto;
        var currentElementName = currentProto && currentProto.is;
        for (var elementName in mixinEntry.dependants)
            if (elementName !== currentElementName)
                mixinEntry.dependants[elementName].__applyShimInvalid = true
    }
    function produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
        if (valueProperty)
            styleUtil.processVariableAndFallback(valueProperty, function(prefix, value) {
                if (value && mapGet(value))
                    valueMixin = "@apply " + value + ";"
            });
        if (!valueMixin)
            return matchText;
        var mixinAsProperties = consumeCssProperties(valueMixin);
        var prefix = matchText.slice(0, matchText.indexOf("--"));
        var mixinValues = cssTextToMap(mixinAsProperties);
        var combinedProps = mixinValues;
        var mixinEntry = mapGet(propertyName);
        var oldProps = mixinEntry && mixinEntry.properties;
        if (oldProps) {
            combinedProps = Object.create(oldProps);
            combinedProps = Polymer.Base.mixin(combinedProps, mixinValues)
        } else
            mapSet(propertyName, combinedProps);
        var out = [];
        var p, v;
        var needToInvalidate = false;
        for (p in combinedProps) {
            v = mixinValues[p];
            if (v === undefined)
                v = "initial";
            if (oldProps && !(p in oldProps))
                needToInvalidate = true;
            out.push(propertyName + MIXIN_VAR_SEP + p + ": " + v)
        }
        if (needToInvalidate)
            invalidateMixinEntry(mixinEntry);
        if (mixinEntry)
            mixinEntry.properties = combinedProps;
        if (valueProperty)
            prefix = matchText + ";" + prefix;
        return prefix + out.join("; ") + ";"
    }
    function fixVars(matchText, varA, varB) {
        return "var(" + varA + "," + "var(" + varB + "))"
    }
    function atApplyToCssProperties(mixinName, fallbacks) {
        mixinName = mixinName.replace(APPLY_NAME_CLEAN, "");
        var vars = [];
        var mixinEntry = mapGet(mixinName);
        if (!mixinEntry) {
            mapSet(mixinName, {});
            mixinEntry = mapGet(mixinName)
        }
        if (mixinEntry) {
            var currentProto = ApplyShim.__currentElementProto;
            if (currentProto)
                mixinEntry.dependants[currentProto.is] = currentProto;
            var p, parts, f;
            for (p in mixinEntry.properties) {
                f = fallbacks && fallbacks[p];
                parts = [p, ": var(", mixinName, MIXIN_VAR_SEP, p];
                if (f)
                    parts.push(",", f);
                parts.push(")");
                vars.push(parts.join(""))
            }
        }
        return vars.join("; ")
    }
    function consumeCssProperties(text) {
        var m;
        while (m = MIXIN_MATCH.exec(text)) {
            var matchText = m[0];
            var mixinName = m[1];
            var idx = m.index;
            var applyPos = idx + matchText.indexOf("@apply");
            var afterApplyPos = idx + matchText.length;
            var textBeforeApply = text.slice(0, applyPos);
            var textAfterApply = text.slice(afterApplyPos);
            var defaults = cssTextToMap(textBeforeApply);
            var replacement = atApplyToCssProperties(mixinName, defaults);
            text = [textBeforeApply, replacement, textAfterApply].join("");
            MIXIN_MATCH.lastIndex = idx + replacement.length
        }
        return text
    }
    var ApplyShim = {
        _measureElement: null,
        _map: mixinMap,
        _separator: MIXIN_VAR_SEP,
        transform: function(styles, elementProto) {
            this.__currentElementProto = elementProto;
            styleUtil.forRulesInStyles(styles, this._boundFindDefinitions);
            styleUtil.forRulesInStyles(styles, this._boundFindApplications);
            if (elementProto)
                elementProto.__applyShimInvalid = false;
            this.__currentElementProto = null
        },
        _findDefinitions: function(rule) {
            var cssText = rule.parsedCssText;
            cssText = cssText.replace(BAD_VAR, fixVars);
            cssText = cssText.replace(VAR_ASSIGN, produceCssProperties);
            rule.cssText = cssText;
            if (rule.selector === ":root")
                rule.selector = ":host > *"
        },
        _findApplications: function(rule) {
            rule.cssText = consumeCssProperties(rule.cssText)
        },
        transformRule: function(rule) {
            this._findDefinitions(rule);
            this._findApplications(rule)
        },
        _getInitialValueForProperty: function(property) {
            if (!this._measureElement) {
                this._measureElement = document.createElement("meta");
                this._measureElement.style.all = "initial";
                document.head.appendChild(this._measureElement)
            }
            return window.getComputedStyle(this._measureElement).getPropertyValue(property)
        }
    };
    ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
    ApplyShim._boundFindDefinitions = ApplyShim._findDefinitions.bind(ApplyShim);
    ApplyShim._boundFindApplications = ApplyShim._findApplications.bind(ApplyShim);
    return ApplyShim
}();
(function() {
    var prepElement = Polymer.Base._prepElement;
    var nativeShadow = Polymer.Settings.useNativeShadow;
    var styleUtil = Polymer.StyleUtil;
    var styleTransformer = Polymer.StyleTransformer;
    var styleExtends = Polymer.StyleExtends;
    var applyShim = Polymer.ApplyShim;
    var settings = Polymer.Settings;
    Polymer.Base._addFeature({
        _prepElement: function(element) {
            if (this._encapsulateStyle && this.__cssBuild !== "shady")
                styleTransformer.element(element, this.is, this._scopeCssViaAttr);
            prepElement.call(this, element)
        },
        _prepStyles: function() {
            if (this._encapsulateStyle === undefined)
                this._encapsulateStyle = !nativeShadow;
            if (!nativeShadow)
                this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
            this.__cssBuild = styleUtil.cssBuildTypeForModule(this.is)
        },
        _prepShimStyles: function() {
            if (this._template) {
                var hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);
                if (settings.useNativeCSSProperties && this.__cssBuild === "shadow" && hasTargetedCssBuild) {
                    if (settings.preserveStyleIncludes)
                        styleUtil.styleIncludesToTemplate(this._template);
                    return
                }
                this._styles = this._styles || this._collectStyles();
                if (settings.useNativeCSSProperties && !this.__cssBuild)
                    applyShim.transform(this._styles, this);
                var cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);
                this._prepStyleProperties();
                if (!this._needsStyleProperties() && cssText)
                    styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle)
            } else
                this._styles = []
        },
        _collectStyles: function() {
            var styles = [];
            var cssText = ""
              , m$ = this.styleModules;
            if (m$)
                for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++)
                    cssText += styleUtil.cssFromModule(m);
            cssText += styleUtil.cssFromModule(this.is);
            var p = this._template && this._template.parentNode;
            if (this._template && (!p || p.id.toLowerCase() !== this.is))
                cssText += styleUtil.cssFromElement(this._template);
            if (cssText) {
                var style = document.createElement("style");
                style.textContent = cssText;
                if (styleExtends.hasExtends(style.textContent))
                    cssText = styleExtends.transform(style);
                styles.push(style)
            }
            return styles
        },
        _elementAdd: function(node) {
            if (this._encapsulateStyle)
                if (node.__styleScoped)
                    node.__styleScoped = false;
                else
                    styleTransformer.dom(node, this.is, this._scopeCssViaAttr)
        },
        _elementRemove: function(node) {
            if (this._encapsulateStyle)
                styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true)
        },
        scopeSubtree: function(container, shouldObserve) {
            if (nativeShadow)
                return;
            var self = this;
            var scopify = function(node) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    var className = node.getAttribute("class");
                    node.setAttribute("class", self._scopeElementClass(node, className));
                    var n$ = node.querySelectorAll("*");
                    for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
                        className = n.getAttribute("class");
                        n.setAttribute("class", self._scopeElementClass(n, className))
                    }
                }
            };
            scopify(container);
            if (shouldObserve) {
                var mo = new MutationObserver(function(mxns) {
                    for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++)
                        if (m.addedNodes)
                            for (var j = 0; j < m.addedNodes.length; j++)
                                scopify(m.addedNodes[j])
                }
                );
                mo.observe(container, {
                    childList: true,
                    subtree: true
                });
                return mo
            }
        }
    })
}
)();
Polymer.StyleProperties = function() {
    var matchesSelector = Polymer.DomApi.matchesSelector;
    var styleUtil = Polymer.StyleUtil;
    var styleTransformer = Polymer.StyleTransformer;
    var IS_IE = navigator.userAgent.match("Trident");
    var settings = Polymer.Settings;
    return {
        decorateStyles: function(styles, scope) {
            var self = this
              , props = {}
              , keyframes = []
              , ruleIndex = 0;
            var scopeSelector = styleTransformer._calcHostScope(scope.is, scope["extends"]);
            styleUtil.forRulesInStyles(styles, function(rule, style) {
                self.decorateRule(rule);
                rule.index = ruleIndex++;
                self.whenHostOrRootRule(scope, rule, style, function(info) {
                    if (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE)
                        scope.__notStyleScopeCacheable = true;
                    if (info.isHost) {
                        var hostContextOrFunction = info.selector.split(" ").some(function(s) {
                            return s.indexOf(scopeSelector) === 0 && s.length !== scopeSelector.length
                        });
                        scope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction
                    }
                });
                self.collectPropertiesInCssText(rule.propertyInfo.cssText, props)
            }, function onKeyframesRule(rule) {
                keyframes.push(rule)
            });
            styles._keyframes = keyframes;
            var names = [];
            for (var i in props)
                names.push(i);
            return names
        },
        decorateRule: function(rule) {
            if (rule.propertyInfo)
                return rule.propertyInfo;
            var info = {}
              , properties = {};
            var hasProperties = this.collectProperties(rule, properties);
            if (hasProperties) {
                info.properties = properties;
                rule.rules = null
            }
            info.cssText = this.collectCssText(rule);
            rule.propertyInfo = info;
            return info
        },
        collectProperties: function(rule, properties) {
            var info = rule.propertyInfo;
            if (info) {
                if (info.properties) {
                    Polymer.Base.mixin(properties, info.properties);
                    return true
                }
            } else {
                var m, rx = this.rx.VAR_ASSIGN;
                var cssText = rule.parsedCssText;
                var value;
                var any;
                while (m = rx.exec(cssText)) {
                    value = (m[2] || m[3]).trim();
                    if (value !== "inherit")
                        properties[m[1].trim()] = value;
                    any = true
                }
                return any
            }
        },
        collectCssText: function(rule) {
            return this.collectConsumingCssText(rule.parsedCssText)
        },
        collectConsumingCssText: function(cssText) {
            return cssText.replace(this.rx.BRACKETED, "").replace(this.rx.VAR_ASSIGN, "")
        },
        collectPropertiesInCssText: function(cssText, props) {
            var m;
            while (m = this.rx.VAR_CONSUMED.exec(cssText)) {
                var name = m[1];
                if (m[2] !== ":")
                    props[name] = true
            }
        },
        reify: function(props) {
            var names = Object.getOwnPropertyNames(props);
            for (var i = 0, n; i < names.length; i++) {
                n = names[i];
                props[n] = this.valueForProperty(props[n], props)
            }
        },
        valueForProperty: function(property, props) {
            if (property)
                if (property.indexOf(";") >= 0)
                    property = this.valueForProperties(property, props);
                else {
                    var self = this;
                    var fn = function(prefix, value, fallback, suffix) {
                        var propertyValue = self.valueForProperty(props[value], props);
                        if (!propertyValue || propertyValue === "initial")
                            propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
                        else if (propertyValue === "apply-shim-inherit")
                            propertyValue = "inherit";
                        return prefix + (propertyValue || "") + suffix
                    };
                    property = styleUtil.processVariableAndFallback(property, fn)
                }
            return property && property.trim() || ""
        },
        valueForProperties: function(property, props) {
            var parts = property.split(";");
            for (var i = 0, p, m; i < parts.length; i++)
                if (p = parts[i]) {
                    this.rx.MIXIN_MATCH.lastIndex = 0;
                    m = this.rx.MIXIN_MATCH.exec(p);
                    if (m)
                        p = this.valueForProperty(props[m[1]], props);
                    else {
                        var colon = p.indexOf(":");
                        if (colon !== -1) {
                            var pp = p.substring(colon);
                            pp = pp.trim();
                            pp = this.valueForProperty(pp, props) || pp;
                            p = p.substring(0, colon) + pp
                        }
                    }
                    parts[i] = p && p.lastIndexOf(";") === p.length - 1 ? p.slice(0, -1) : p || ""
                }
            return parts.join(";")
        },
        applyProperties: function(rule, props) {
            var output = "";
            if (!rule.propertyInfo)
                this.decorateRule(rule);
            if (rule.propertyInfo.cssText)
                output = this.valueForProperties(rule.propertyInfo.cssText, props);
            rule.cssText = output
        },
        applyKeyframeTransforms: function(rule, keyframeTransforms) {
            var input = rule.cssText;
            var output = rule.cssText;
            if (rule.hasAnimations == null)
                rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
            if (rule.hasAnimations) {
                var transform;
                if (rule.keyframeNamesToTransform == null) {
                    rule.keyframeNamesToTransform = [];
                    for (var keyframe in keyframeTransforms) {
                        transform = keyframeTransforms[keyframe];
                        output = transform(input);
                        if (input !== output) {
                            input = output;
                            rule.keyframeNamesToTransform.push(keyframe)
                        }
                    }
                } else {
                    for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
                        transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
                        input = transform(input)
                    }
                    output = input
                }
            }
            rule.cssText = output
        },
        propertyDataFromStyles: function(styles, element) {
            var props = {}
              , self = this;
            var o = [];
            styleUtil.forActiveRulesInStyles(styles, function(rule) {
                if (!rule.propertyInfo)
                    self.decorateRule(rule);
                var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
                if (element && rule.propertyInfo.properties && selectorToMatch)
                    if (matchesSelector.call(element, selectorToMatch)) {
                        self.collectProperties(rule, props);
                        addToBitMask(rule.index, o)
                    }
            });
            return {
                properties: props,
                key: o
            }
        },
        _rootSelector: /:root|:host\s*>\s*\*/,
        _checkRoot: function(hostScope, selector) {
            return Boolean(selector.match(this._rootSelector)) || hostScope === "html" && selector.indexOf("html") > -1
        },
        whenHostOrRootRule: function(scope, rule, style, callback) {
            if (!rule.propertyInfo)
                self.decorateRule(rule);
            if (!rule.propertyInfo.properties)
                return;
            var hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope["extends"]) : "html";
            var parsedSelector = rule.parsedSelector;
            var isRoot = this._checkRoot(hostScope, parsedSelector);
            var isHost = !isRoot && parsedSelector.indexOf(":host") === 0;
            var cssBuild = scope.__cssBuild || style.__cssBuild;
            if (cssBuild === "shady") {
                isRoot = parsedSelector === hostScope + " > *." + hostScope || parsedSelector.indexOf("html") > -1;
                isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0
            }
            if (!isRoot && !isHost)
                return;
            var selectorToMatch = hostScope;
            if (isHost) {
                if (settings.useNativeShadow && !rule.transformedSelector)
                    rule.transformedSelector = styleTransformer._transformRuleCss(rule, styleTransformer._transformComplexSelector, scope.is, hostScope);
                selectorToMatch = rule.transformedSelector || rule.parsedSelector
            }
            if (isRoot && hostScope === "html")
                selectorToMatch = rule.transformedSelector || rule.parsedSelector;
            callback({
                selector: selectorToMatch,
                isHost: isHost,
                isRoot: isRoot
            })
        },
        hostAndRootPropertiesForScope: function(scope) {
            var hostProps = {}
              , rootProps = {}
              , self = this;
            styleUtil.forActiveRulesInStyles(scope._styles, function(rule, style) {
                self.whenHostOrRootRule(scope, rule, style, function(info) {
                    var element = scope._element || scope;
                    if (matchesSelector.call(element, info.selector))
                        if (info.isHost)
                            self.collectProperties(rule, hostProps);
                        else
                            self.collectProperties(rule, rootProps)
                })
            });
            return {
                rootProps: rootProps,
                hostProps: hostProps
            }
        },
        transformStyles: function(element, properties, scopeSelector) {
            var self = this;
            var hostSelector = styleTransformer._calcHostScope(element.is, element["extends"]);
            var rxHostSelector = element["extends"] ? "\\" + hostSelector.slice(0, -1) + "\\]" : hostSelector;
            var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);
            var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
            return styleTransformer.elementStyles(element, function(rule) {
                self.applyProperties(rule, properties);
                if (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
                    self.applyKeyframeTransforms(rule, keyframeTransforms);
                    self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector)
                }
            })
        },
        _elementKeyframeTransforms: function(element, scopeSelector) {
            var keyframesRules = element._styles._keyframes;
            var keyframeTransforms = {};
            if (!settings.useNativeShadow && keyframesRules)
                for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
                    this._scopeKeyframes(keyframesRule, scopeSelector);
                    keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule)
                }
            return keyframeTransforms
        },
        _keyframesRuleTransformer: function(keyframesRule) {
            return function(cssText) {
                return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName)
            }
        },
        _scopeKeyframes: function(rule, scopeId) {
            rule.keyframesNameRx = new RegExp(rule.keyframesName,"g");
            rule.transformedKeyframesName = rule.keyframesName + "-" + scopeId;
            rule.transformedSelector = rule.transformedSelector || rule.selector;
            rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName)
        },
        _scopeSelector: function(rule, hostRx, hostSelector, viaAttr, scopeId) {
            rule.transformedSelector = rule.transformedSelector || rule.selector;
            var selector = rule.transformedSelector;
            var scope = viaAttr ? "[" + styleTransformer.SCOPE_NAME + "~=" + scopeId + "]" : "." + scopeId;
            var parts = selector.split(",");
            for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++)
                parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + " " + p;
            rule.selector = parts.join(",")
        },
        applyElementScopeSelector: function(element, selector, old, viaAttr) {
            var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute("class") || "";
            var v = old ? c.replace(old, selector) : (c ? c + " " : "") + this.XSCOPE_NAME + " " + selector;
            if (c !== v)
                if (viaAttr)
                    element.setAttribute(styleTransformer.SCOPE_NAME, v);
                else
                    element.setAttribute("class", v)
        },
        applyElementStyle: function(element, properties, selector, style) {
            var cssText = style ? style.textContent || "" : this.transformStyles(element, properties, selector);
            var s = element._customStyle;
            if (s && !settings.useNativeShadow && s !== style) {
                s._useCount--;
                if (s._useCount <= 0 && s.parentNode)
                    s.parentNode.removeChild(s)
            }
            if (settings.useNativeShadow)
                if (element._customStyle) {
                    element._customStyle.textContent = cssText;
                    style = element._customStyle
                } else {
                    if (cssText)
                        style = styleUtil.applyCss(cssText, selector, element.root, element._scopeStyle)
                }
            else if (!style) {
                if (cssText)
                    style = styleUtil.applyCss(cssText, selector, null, element._scopeStyle)
            } else if (!style.parentNode) {
                if (IS_IE && cssText.indexOf("@media") > -1)
                    style.textContent = cssText;
                styleUtil.applyStyle(style, null, element._scopeStyle)
            }
            if (style) {
                style._useCount = style._useCount || 0;
                if (element._customStyle != style)
                    style._useCount++;
                element._customStyle = style
            }
            return style
        },
        mixinCustomStyle: function(props, customStyle) {
            var v;
            for (var i in customStyle) {
                v = customStyle[i];
                if (v || v === 0)
                    props[i] = v
            }
        },
        updateNativeStyleProperties: function(element, properties) {
            var oldPropertyNames = element.__customStyleProperties;
            if (oldPropertyNames)
                for (var i = 0; i < oldPropertyNames.length; i++)
                    element.style.removeProperty(oldPropertyNames[i]);
            var propertyNames = [];
            for (var p in properties)
                if (properties[p] !== null) {
                    element.style.setProperty(p, properties[p]);
                    propertyNames.push(p)
                }
            element.__customStyleProperties = propertyNames
        },
        rx: styleUtil.rx,
        XSCOPE_NAME: "x-scope"
    };
    function addToBitMask(n, bits) {
        var o = parseInt(n / 32);
        var v = 1 << n % 32;
        bits[o] = (bits[o] || 0) | v
    }
}();
(function() {
    Polymer.StyleCache = function() {
        this.cache = {}
    }
    ;
    Polymer.StyleCache.prototype = {
        MAX: 100,
        store: function(is, data, keyValues, keyStyles) {
            data.keyValues = keyValues;
            data.styles = keyStyles;
            var s$ = this.cache[is] = this.cache[is] || [];
            s$.push(data);
            if (s$.length > this.MAX)
                s$.shift()
        },
        retrieve: function(is, keyValues, keyStyles) {
            var cache = this.cache[is];
            if (cache)
                for (var i = cache.length - 1, data; i >= 0; i--) {
                    data = cache[i];
                    if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues))
                        return data
                }
        },
        clear: function() {
            this.cache = {}
        },
        _objectsEqual: function(target, source) {
            var t, s;
            for (var i in target) {
                t = target[i],
                s = source[i];
                if (!(typeof t === "object" && t ? this._objectsStrictlyEqual(t, s) : t === s))
                    return false
            }
            if (Array.isArray(target))
                return target.length === source.length;
            return true
        },
        _objectsStrictlyEqual: function(target, source) {
            return this._objectsEqual(target, source) && this._objectsEqual(source, target)
        }
    }
}
)();
Polymer.StyleDefaults = function() {
    var styleProperties = Polymer.StyleProperties;
    var StyleCache = Polymer.StyleCache;
    var nativeVariables = Polymer.Settings.useNativeCSSProperties;
    var api = {
        _styles: [],
        _properties: null,
        customStyle: {},
        _styleCache: new StyleCache,
        _element: Polymer.DomApi.wrap(document.documentElement),
        addStyle: function(style) {
            this._styles.push(style);
            this._properties = null
        },
        get _styleProperties() {
            if (!this._properties) {
                styleProperties.decorateStyles(this._styles, this);
                this._styles._scopeStyleProperties = null;
                this._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;
                styleProperties.mixinCustomStyle(this._properties, this.customStyle);
                styleProperties.reify(this._properties)
            }
            return this._properties
        },
        hasStyleProperties: function() {
            return Boolean(this._properties)
        },
        _needsStyleProperties: function() {},
        _computeStyleProperties: function() {
            return this._styleProperties
        },
        updateStyles: function(properties) {
            this._properties = null;
            if (properties)
                Polymer.Base.mixin(this.customStyle, properties);
            this._styleCache.clear();
            for (var i = 0, s; i < this._styles.length; i++) {
                s = this._styles[i];
                s = s.__importElement || s;
                s._apply()
            }
            if (nativeVariables)
                styleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle)
        }
    };
    return api
}();
(function() {
    var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
    var propertyUtils = Polymer.StyleProperties;
    var styleTransformer = Polymer.StyleTransformer;
    var styleDefaults = Polymer.StyleDefaults;
    var nativeShadow = Polymer.Settings.useNativeShadow;
    var nativeVariables = Polymer.Settings.useNativeCSSProperties;
    Polymer.Base._addFeature({
        _prepStyleProperties: function() {
            if (!nativeVariables)
                this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles, this) : null
        },
        customStyle: null,
        getComputedStyleValue: function(property) {
            if (!nativeVariables && !this._styleProperties)
                this._computeStyleProperties();
            return !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property)
        },
        _setupStyleProperties: function() {
            this.customStyle = {};
            this._styleCache = null;
            this._styleProperties = null;
            this._scopeSelector = null;
            this._ownStyleProperties = null;
            this._customStyle = null
        },
        _needsStyleProperties: function() {
            return Boolean(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length)
        },
        _validateApplyShim: function() {
            if (this.__applyShimInvalid) {
                Polymer.ApplyShim.transform(this._styles, this.__proto__);
                var cssText = styleTransformer.elementStyles(this);
                if (nativeShadow) {
                    var templateStyle = this._template.content.querySelector("style");
                    if (templateStyle)
                        templateStyle.textContent = cssText
                } else {
                    var shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;
                    if (shadyStyle)
                        shadyStyle.textContent = cssText
                }
            }
        },
        _beforeAttached: function() {
            if ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {
                this.__stylePropertiesInvalid = false;
                this._updateStyleProperties()
            }
        },
        _findStyleHost: function() {
            var e = this, root;
            while (root = Polymer.dom(e).getOwnerRoot()) {
                if (Polymer.isInstance(root.host))
                    return root.host;
                e = root.host
            }
            return styleDefaults
        },
        _updateStyleProperties: function() {
            var info, scope = this._findStyleHost();
            if (!scope._styleProperties)
                scope._computeStyleProperties();
            if (!scope._styleCache)
                scope._styleCache = new Polymer.StyleCache;
            var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
            var scopeCacheable = !this.__notStyleScopeCacheable;
            if (scopeCacheable) {
                scopeData.key.customStyle = this.customStyle;
                info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles)
            }
            var scopeCached = Boolean(info);
            if (scopeCached)
                this._styleProperties = info._styleProperties;
            else
                this._computeStyleProperties(scopeData.properties);
            this._computeOwnStyleProperties();
            if (!scopeCached)
                info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
            var globalCached = Boolean(info) && !scopeCached;
            var style = this._applyStyleProperties(info);
            if (!scopeCached) {
                style = style && nativeShadow ? style.cloneNode(true) : style;
                info = {
                    style: style,
                    _scopeSelector: this._scopeSelector,
                    _styleProperties: this._styleProperties
                };
                if (scopeCacheable) {
                    scopeData.key.customStyle = {};
                    this.mixin(scopeData.key.customStyle, this.customStyle);
                    scope._styleCache.store(this.is, info, scopeData.key, this._styles)
                }
                if (!globalCached)
                    styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles)
            }
        },
        _computeStyleProperties: function(scopeProps) {
            var scope = this._findStyleHost();
            if (!scope._styleProperties)
                scope._computeStyleProperties();
            var props = Object.create(scope._styleProperties);
            var hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);
            this.mixin(props, hostAndRootProps.hostProps);
            scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
            this.mixin(props, scopeProps);
            this.mixin(props, hostAndRootProps.rootProps);
            propertyUtils.mixinCustomStyle(props, this.customStyle);
            propertyUtils.reify(props);
            this._styleProperties = props
        },
        _computeOwnStyleProperties: function() {
            var props = {};
            for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
                n = this._ownStylePropertyNames[i];
                props[n] = this._styleProperties[n]
            }
            this._ownStyleProperties = props
        },
        _scopeCount: 0,
        _applyStyleProperties: function(info) {
            var oldScopeSelector = this._scopeSelector;
            this._scopeSelector = info ? info._scopeSelector : this.is + "-" + this.__proto__._scopeCount++;
            var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
            if (!nativeShadow)
                propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
            return style
        },
        serializeValueToAttribute: function(value, attribute, node) {
            node = node || this;
            if (attribute === "class" && !nativeShadow) {
                var host = node === this ? this.domHost || this.dataHost : this;
                if (host)
                    value = host._scopeElementClass(node, value)
            }
            node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
            serializeValueToAttribute.call(this, value, attribute, node)
        },
        _scopeElementClass: function(element, selector) {
            if (!nativeShadow && !this._scopeCssViaAttr)
                selector = (selector ? selector + " " : "") + SCOPE_NAME + " " + this.is + (element._scopeSelector ? " " + XSCOPE_NAME + " " + element._scopeSelector : "");
            return selector
        },
        updateStyles: function(properties) {
            if (properties)
                this.mixin(this.customStyle, properties);
            if (nativeVariables)
                propertyUtils.updateNativeStyleProperties(this, this.customStyle);
            else {
                if (this.isAttached)
                    if (this._needsStyleProperties())
                        this._updateStyleProperties();
                    else
                        this._styleProperties = null;
                else
                    this.__stylePropertiesInvalid = true;
                if (this._styleCache)
                    this._styleCache.clear();
                this._updateRootStyles()
            }
        },
        _updateRootStyles: function(root) {
            root = root || this.root;
            var c$ = Polymer.dom(root)._query(function(e) {
                return e.shadyRoot || e.shadowRoot
            });
            for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++)
                if (c.updateStyles)
                    c.updateStyles()
        }
    });
    Polymer.updateStyles = function(properties) {
        styleDefaults.updateStyles(properties);
        Polymer.Base._updateRootStyles(document)
    }
    ;
    var styleCache = new Polymer.StyleCache;
    Polymer.customStyleCache = styleCache;
    var SCOPE_NAME = styleTransformer.SCOPE_NAME;
    var XSCOPE_NAME = propertyUtils.XSCOPE_NAME
}
)();
Polymer.Base._addFeature({
    _registerFeatures: function() {
        this._prepIs();
        if (this.factoryImpl)
            this._prepConstructor();
        this._prepStyles()
    },
    _finishRegisterFeatures: function() {
        this._prepTemplate();
        this._prepShimStyles();
        this._prepAnnotations();
        this._prepEffects();
        this._prepBehaviors();
        this._prepPropertyInfo();
        this._prepBindings();
        this._prepShady()
    },
    _prepBehavior: function(b) {
        this._addPropertyEffects(b.properties);
        this._addComplexObserverEffects(b.observers);
        this._addHostAttributes(b.hostAttributes)
    },
    _initFeatures: function() {
        this._setupGestures();
        this._setupConfigure(this.__data__);
        this._setupStyleProperties();
        this._setupDebouncers();
        this._setupShady();
        this._registerHost();
        if (this._template) {
            this._validateApplyShim();
            this._poolContent();
            this._beginHosting();
            this._stampTemplate();
            this._endHosting();
            this._marshalAnnotationReferences()
        }
        this._marshalInstanceEffects();
        this._marshalBehaviors();
        this._marshalHostAttributes();
        this._marshalAttributes();
        this._tryReady()
    },
    _marshalBehavior: function(b) {
        if (b.listeners)
            this._listenListeners(b.listeners)
    }
});
(function() {
    var propertyUtils = Polymer.StyleProperties;
    var styleUtil = Polymer.StyleUtil;
    var cssParse = Polymer.CssParse;
    var styleDefaults = Polymer.StyleDefaults;
    var styleTransformer = Polymer.StyleTransformer;
    var applyShim = Polymer.ApplyShim;
    var debounce = Polymer.Debounce;
    var settings = Polymer.Settings;
    var updateDebouncer;
    Polymer({
        is: "custom-style",
        "extends": "style",
        _template: null,
        properties: {
            include: String
        },
        ready: function() {
            this.__appliedElement = this.__appliedElement || this;
            this.__cssBuild = styleUtil.getCssBuildType(this);
            if (this.__appliedElement !== this)
                this.__appliedElement.__cssBuild = this.__cssBuild;
            if (this.ownerDocument !== window.document && this.__appliedElement === this)
                document.head.appendChild(this);
            this._tryApply()
        },
        attached: function() {
            this._tryApply()
        },
        _tryApply: function() {
            if (!this._appliesToDocument)
                if (this.parentNode && this.parentNode.localName !== "dom-module") {
                    this._appliesToDocument = true;
                    var e = this.__appliedElement;
                    if (!settings.useNativeCSSProperties) {
                        this.__needsUpdateStyles = styleDefaults.hasStyleProperties();
                        styleDefaults.addStyle(e)
                    }
                    if (e.textContent || this.include)
                        this._apply(true);
                    else {
                        var self = this;
                        var observer = new MutationObserver(function() {
                            observer.disconnect();
                            self._apply(true)
                        }
                        );
                        observer.observe(e, {
                            childList: true
                        })
                    }
                }
        },
        _updateStyles: function() {
            Polymer.updateStyles()
        },
        _apply: function(initialApply) {
            var e = this.__appliedElement;
            if (this.include)
                e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
            if (!e.textContent)
                return;
            var buildType = this.__cssBuild;
            var targetedBuild = styleUtil.isTargetedBuild(buildType);
            if (settings.useNativeCSSProperties && targetedBuild)
                return;
            var styleRules = styleUtil.rulesForStyle(e);
            if (!targetedBuild) {
                styleUtil.forEachRule(styleRules, function(rule) {
                    styleTransformer.documentRule(rule)
                });
                if (settings.useNativeCSSProperties && !buildType)
                    applyShim.transform([e])
            }
            if (settings.useNativeCSSProperties)
                e.textContent = styleUtil.toCssText(styleRules);
            else {
                var self = this;
                var fn = function fn() {
                    self._flushCustomProperties()
                };
                if (initialApply)
                    Polymer.RenderStatus.whenReady(fn);
                else
                    fn()
            }
        },
        _flushCustomProperties: function() {
            if (this.__needsUpdateStyles) {
                this.__needsUpdateStyles = false;
                updateDebouncer = debounce(updateDebouncer, this._updateStyles)
            } else
                this._applyCustomProperties()
        },
        _applyCustomProperties: function() {
            var element = this.__appliedElement;
            this._computeStyleProperties();
            var props = this._styleProperties;
            var rules = styleUtil.rulesForStyle(element);
            if (!rules)
                return;
            element.textContent = styleUtil.toCssText(rules, function(rule) {
                var css = rule.cssText = rule.parsedCssText;
                if (rule.propertyInfo && rule.propertyInfo.cssText) {
                    css = cssParse.removeCustomPropAssignment(css);
                    rule.cssText = propertyUtils.valueForProperties(css, props)
                }
            })
        }
    })
}
)();
Polymer.Templatizer = {
    properties: {
        __hideTemplateChildren__: {
            observer: "_showHideChildren"
        }
    },
    _instanceProps: Polymer.nob,
    _parentPropPrefix: "_parent_",
    templatize: function(template) {
        this._templatized = template;
        if (!template._content)
            template._content = template.content;
        if (template._content._ctor) {
            this.ctor = template._content._ctor;
            this._prepParentProperties(this.ctor.prototype, template);
            return
        }
        var archetype = Object.create(Polymer.Base);
        this._customPrepAnnotations(archetype, template);
        this._prepParentProperties(archetype, template);
        archetype._prepEffects();
        this._customPrepEffects(archetype);
        archetype._prepBehaviors();
        archetype._prepPropertyInfo();
        archetype._prepBindings();
        archetype._notifyPathUp = this._notifyPathUpImpl;
        archetype._scopeElementClass = this._scopeElementClassImpl;
        archetype.listen = this._listenImpl;
        archetype._showHideChildren = this._showHideChildrenImpl;
        archetype.__setPropertyOrig = this.__setProperty;
        archetype.__setProperty = this.__setPropertyImpl;
        var _constructor = this._constructorImpl;
        var ctor = function TemplateInstance(model, host) {
            _constructor.call(this, model, host)
        };
        ctor.prototype = archetype;
        archetype.constructor = ctor;
        template._content._ctor = ctor;
        this.ctor = ctor
    },
    _getRootDataHost: function() {
        return this.dataHost && this.dataHost._rootDataHost || this.dataHost
    },
    _showHideChildrenImpl: function(hide) {
        var c = this._children;
        for (var i = 0; i < c.length; i++) {
            var n = c[i];
            if (Boolean(hide) != Boolean(n.__hideTemplateChildren__))
                if (n.nodeType === Node.TEXT_NODE)
                    if (hide) {
                        n.__polymerTextContent__ = n.textContent;
                        n.textContent = ""
                    } else
                        n.textContent = n.__polymerTextContent__;
                else if (n.style)
                    if (hide) {
                        n.__polymerDisplay__ = n.style.display;
                        n.style.display = "none"
                    } else
                        n.style.display = n.__polymerDisplay__;
            n.__hideTemplateChildren__ = hide
        }
    },
    __setPropertyImpl: function(property, value, fromAbove, node) {
        if (node && node.__hideTemplateChildren__ && property == "textContent")
            property = "__polymerTextContent__";
        this.__setPropertyOrig(property, value, fromAbove, node)
    },
    _debounceTemplate: function(fn) {
        Polymer.dom.addDebouncer(this.debounce("_debounceTemplate", fn))
    },
    _flushTemplates: function() {
        Polymer.dom.flush()
    },
    _customPrepEffects: function(archetype) {
        var parentProps = archetype._parentProps;
        for (var prop in parentProps)
            archetype._addPropertyEffect(prop, "function", this._createHostPropEffector(prop));
        for (prop in this._instanceProps)
            archetype._addPropertyEffect(prop, "function", this._createInstancePropEffector(prop))
    },
    _customPrepAnnotations: function(archetype, template) {
        archetype._template = template;
        var c = template._content;
        if (!c._notes) {
            var rootDataHost = archetype._rootDataHost;
            if (rootDataHost)
                Polymer.Annotations.prepElement = function() {
                    rootDataHost._prepElement()
                }
                ;
            c._notes = Polymer.Annotations.parseAnnotations(template);
            Polymer.Annotations.prepElement = null;
            this._processAnnotations(c._notes)
        }
        archetype._notes = c._notes;
        archetype._parentProps = c._parentProps
    },
    _prepParentProperties: function(archetype, template) {
        var parentProps = this._parentProps = archetype._parentProps;
        if (this._forwardParentProp && parentProps) {
            var proto = archetype._parentPropProto;
            var prop;
            if (!proto) {
                for (prop in this._instanceProps)
                    delete parentProps[prop];
                proto = archetype._parentPropProto = Object.create(null);
                if (template != this) {
                    Polymer.Bind.prepareModel(proto);
                    Polymer.Base.prepareModelNotifyPath(proto)
                }
                for (prop in parentProps) {
                    var parentProp = this._parentPropPrefix + prop;
                    var effects = [{
                        kind: "function",
                        effect: this._createForwardPropEffector(prop),
                        fn: Polymer.Bind._functionEffect
                    }, {
                        kind: "notify",
                        fn: Polymer.Bind._notifyEffect,
                        effect: {
                            event: Polymer.CaseMap.camelToDashCase(parentProp) + "-changed"
                        }
                    }];
                    proto._propertyEffects = proto._propertyEffects || {};
                    proto._propertyEffects[parentProp] = effects;
                    Polymer.Bind._createAccessors(proto, parentProp, effects)
                }
            }
            var self = this;
            if (template != this) {
                Polymer.Bind.prepareInstance(template);
                template._forwardParentProp = function(source, value) {
                    self._forwardParentProp(source, value)
                }
            }
            this._extendTemplate(template, proto);
            template._pathEffector = function(path, value, fromAbove) {
                return self._pathEffectorImpl(path, value, fromAbove)
            }
        }
    },
    _createForwardPropEffector: function(prop) {
        return function(source, value) {
            this._forwardParentProp(prop, value)
        }
    },
    _createHostPropEffector: function(prop) {
        var prefix = this._parentPropPrefix;
        return function(source, value) {
            this.dataHost._templatized[prefix + prop] = value
        }
    },
    _createInstancePropEffector: function(prop) {
        return function(source, value, old, fromAbove) {
            if (!fromAbove)
                this.dataHost._forwardInstanceProp(this, prop, value)
        }
    },
    _extendTemplate: function(template, proto) {
        var n$ = Object.getOwnPropertyNames(proto);
        if (proto._propertySetter)
            template._propertySetter = proto._propertySetter;
        for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
            var val = template[n];
            if (val && n == "_propertyEffects") {
                var pe = Polymer.Base.mixin({}, val);
                template._propertyEffects = Polymer.Base.mixin(pe, proto._propertyEffects)
            } else {
                var pd = Object.getOwnPropertyDescriptor(proto, n);
                Object.defineProperty(template, n, pd);
                if (val !== undefined)
                    template._propertySetter(n, val)
            }
        }
    },
    _showHideChildren: function(hidden) {},
    _forwardInstancePath: function(inst, path, value) {},
    _forwardInstanceProp: function(inst, prop, value) {},
    _notifyPathUpImpl: function(path, value) {
        var dataHost = this.dataHost;
        var root = Polymer.Path.root(path);
        dataHost._forwardInstancePath.call(dataHost, this, path, value);
        if (root in dataHost._parentProps)
            dataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value)
    },
    _pathEffectorImpl: function(path, value, fromAbove) {
        if (this._forwardParentPath)
            if (path.indexOf(this._parentPropPrefix) === 0) {
                var subPath = path.substring(this._parentPropPrefix.length);
                var model = Polymer.Path.root(subPath);
                if (model in this._parentProps)
                    this._forwardParentPath(subPath, value)
            }
        Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove)
    },
    _constructorImpl: function(model, host) {
        this._rootDataHost = host._getRootDataHost();
        this._setupConfigure(model);
        this._registerHost(host);
        this._beginHosting();
        this.root = this.instanceTemplate(this._template);
        this.root.__noContent = !this._notes._hasContent;
        this.root.__styleScoped = true;
        this._endHosting();
        this._marshalAnnotatedNodes();
        this._marshalInstanceEffects();
        this._marshalAnnotatedListeners();
        var children = [];
        for (var n = this.root.firstChild; n; n = n.nextSibling) {
            children.push(n);
            n._templateInstance = this
        }
        this._children = children;
        if (host.__hideTemplateChildren__)
            this._showHideChildren(true);
        this._tryReady()
    },
    _listenImpl: function(node, eventName, methodName) {
        var model = this;
        var host = this._rootDataHost;
        var handler = host._createEventHandler(node, eventName, methodName);
        var decorated = function(e) {
            e.model = model;
            handler(e)
        };
        host._listen(node, eventName, decorated)
    },
    _scopeElementClassImpl: function(node, value) {
        var host = this._rootDataHost;
        if (host)
            return host._scopeElementClass(node, value);
        return value
    },
    stamp: function(model) {
        model = model || {};
        if (this._parentProps) {
            var templatized = this._templatized;
            for (var prop in this._parentProps)
                if (model[prop] === undefined)
                    model[prop] = templatized[this._parentPropPrefix + prop]
        }
        return new this.ctor(model,this)
    },
    modelForElement: function(el) {
        var model;
        while (el)
            if (model = el._templateInstance)
                if (model.dataHost != this)
                    el = model.dataHost;
                else
                    return model;
            else
                el = el.parentNode
    }
};
Polymer({
    is: "dom-template",
    "extends": "template",
    _template: null,
    behaviors: [Polymer.Templatizer],
    ready: function() {
        this.templatize(this)
    }
});
Polymer._collections = new WeakMap;
Polymer.Collection = function(userArray) {
    Polymer._collections.set(userArray, this);
    this.userArray = userArray;
    this.store = userArray.slice();
    this.initMap()
}
;
Polymer.Collection.prototype = {
    constructor: Polymer.Collection,
    initMap: function() {
        var omap = this.omap = new WeakMap;
        var pmap = this.pmap = {};
        var s = this.store;
        for (var i = 0; i < s.length; i++) {
            var item = s[i];
            if (item && typeof item == "object")
                omap.set(item, i);
            else
                pmap[item] = i
        }
    },
    add: function(item) {
        var key = this.store.push(item) - 1;
        if (item && typeof item == "object")
            this.omap.set(item, key);
        else
            this.pmap[item] = key;
        return "#" + key
    },
    removeKey: function(key) {
        if (key = this._parseKey(key)) {
            this._removeFromMap(this.store[key]);
            delete this.store[key]
        }
    },
    _removeFromMap: function(item) {
        if (item && typeof item == "object")
            this.omap["delete"](item);
        else
            delete this.pmap[item]
    },
    remove: function(item) {
        var key = this.getKey(item);
        this.removeKey(key);
        return key
    },
    getKey: function(item) {
        var key;
        if (item && typeof item == "object")
            key = this.omap.get(item);
        else
            key = this.pmap[item];
        if (key != undefined)
            return "#" + key
    },
    getKeys: function() {
        return Object.keys(this.store).map(function(key) {
            return "#" + key
        })
    },
    _parseKey: function(key) {
        if (key && key[0] == "#")
            return key.slice(1)
    },
    setItem: function(key, item) {
        if (key = this._parseKey(key)) {
            var old = this.store[key];
            if (old)
                this._removeFromMap(old);
            if (item && typeof item == "object")
                this.omap.set(item, key);
            else
                this.pmap[item] = key;
            this.store[key] = item
        }
    },
    getItem: function(key) {
        if (key = this._parseKey(key))
            return this.store[key]
    },
    getItems: function() {
        var items = []
          , store = this.store;
        for (var key in store)
            items.push(store[key]);
        return items
    },
    _applySplices: function(splices) {
        var keyMap = {}, key;
        for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
            s.addedKeys = [];
            for (var j = 0; j < s.removed.length; j++) {
                key = this.getKey(s.removed[j]);
                keyMap[key] = keyMap[key] ? null : -1
            }
            for (j = 0; j < s.addedCount; j++) {
                var item = this.userArray[s.index + j];
                key = this.getKey(item);
                key = key === undefined ? this.add(item) : key;
                keyMap[key] = keyMap[key] ? null : 1;
                s.addedKeys.push(key)
            }
        }
        var removed = [];
        var added = [];
        for (key in keyMap) {
            if (keyMap[key] < 0) {
                this.removeKey(key);
                removed.push(key)
            }
            if (keyMap[key] > 0)
                added.push(key)
        }
        return [{
            removed: removed,
            added: added
        }]
    }
};
Polymer.Collection.get = function(userArray) {
    return Polymer._collections.get(userArray) || new Polymer.Collection(userArray)
}
;
Polymer.Collection.applySplices = function(userArray, splices) {
    var coll = Polymer._collections.get(userArray);
    return coll ? coll._applySplices(splices) : null
}
;
Polymer({
    is: "dom-repeat",
    "extends": "template",
    _template: null,
    properties: {
        items: {
            type: Array
        },
        as: {
            type: String,
            value: "item"
        },
        indexAs: {
            type: String,
            value: "index"
        },
        sort: {
            type: Function,
            observer: "_sortChanged"
        },
        filter: {
            type: Function,
            observer: "_filterChanged"
        },
        observe: {
            type: String,
            observer: "_observeChanged"
        },
        delay: Number,
        renderedItemCount: {
            type: Number,
            notify: !Polymer.Settings.suppressTemplateNotifications,
            readOnly: true
        },
        initialCount: {
            type: Number,
            observer: "_initializeChunking"
        },
        targetFramerate: {
            type: Number,
            value: 20
        },
        notifyDomChange: {
            type: Boolean
        },
        _targetFrameTime: {
            type: Number,
            computed: "_computeFrameTime(targetFramerate)"
        }
    },
    behaviors: [Polymer.Templatizer],
    observers: ["_itemsChanged(items.*)"],
    created: function() {
        this._instances = [];
        this._pool = [];
        this._limit = Infinity;
        var self = this;
        this._boundRenderChunk = function() {
            self._renderChunk()
        }
    },
    detached: function() {
        this.__isDetached = true;
        for (var i = 0; i < this._instances.length; i++)
            this._detachInstance(i)
    },
    attached: function() {
        if (this.__isDetached) {
            this.__isDetached = false;
            var refNode;
            var parentNode = Polymer.dom(this).parentNode;
            if (parentNode.localName == this.is) {
                refNode = parentNode;
                parentNode = Polymer.dom(parentNode).parentNode
            } else
                refNode = this;
            var parent = Polymer.dom(parentNode);
            for (var i = 0; i < this._instances.length; i++)
                this._attachInstance(i, parent, refNode)
        }
    },
    ready: function() {
        this._instanceProps = {
            __key__: true
        };
        this._instanceProps[this.as] = true;
        this._instanceProps[this.indexAs] = true;
        if (!this.ctor)
            this.templatize(this)
    },
    _sortChanged: function(sort) {
        var dataHost = this._getRootDataHost();
        this._sortFn = sort && (typeof sort == "function" ? sort : function() {
            return dataHost[sort].apply(dataHost, arguments)
        }
        );
        this._needFullRefresh = true;
        if (this.items)
            this._debounceTemplate(this._render)
    },
    _filterChanged: function(filter) {
        var dataHost = this._getRootDataHost();
        this._filterFn = filter && (typeof filter == "function" ? filter : function() {
            return dataHost[filter].apply(dataHost, arguments)
        }
        );
        this._needFullRefresh = true;
        if (this.items)
            this._debounceTemplate(this._render)
    },
    _computeFrameTime: function(rate) {
        return Math.ceil(1E3 / rate)
    },
    _initializeChunking: function() {
        if (this.initialCount) {
            this._limit = this.initialCount;
            this._chunkCount = this.initialCount;
            this._lastChunkTime = performance.now()
        }
    },
    _tryRenderChunk: function() {
        if (this.items && this._limit < this.items.length)
            this.debounce("renderChunk", this._requestRenderChunk)
    },
    _requestRenderChunk: function() {
        requestAnimationFrame(this._boundRenderChunk)
    },
    _renderChunk: function() {
        var currChunkTime = performance.now();
        var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
        this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
        this._limit += this._chunkCount;
        this._lastChunkTime = currChunkTime;
        this._debounceTemplate(this._render)
    },
    _observeChanged: function() {
        this._observePaths = this.observe && this.observe.replace(".*", ".").split(" ")
    },
    _itemsChanged: function(change) {
        if (change.path == "items") {
            if (Array.isArray(this.items))
                this.collection = Polymer.Collection.get(this.items);
            else if (!this.items)
                this.collection = null;
            else
                this._error(this._logf("dom-repeat", "expected array for `items`," + " found", this.items));
            this._keySplices = [];
            this._indexSplices = [];
            this._needFullRefresh = true;
            this._initializeChunking();
            this._debounceTemplate(this._render)
        } else if (change.path == "items.splices") {
            this._keySplices = this._keySplices.concat(change.value.keySplices);
            this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
            this._debounceTemplate(this._render)
        } else {
            var subpath = change.path.slice(6);
            this._forwardItemPath(subpath, change.value);
            this._checkObservedPaths(subpath)
        }
    },
    _checkObservedPaths: function(path) {
        if (this._observePaths) {
            path = path.substring(path.indexOf(".") + 1);
            var paths = this._observePaths;
            for (var i = 0; i < paths.length; i++)
                if (path.indexOf(paths[i]) === 0) {
                    this._needFullRefresh = true;
                    if (this.delay)
                        this.debounce("render", this._render, this.delay);
                    else
                        this._debounceTemplate(this._render);
                    return
                }
        }
    },
    render: function() {
        this._needFullRefresh = true;
        this._debounceTemplate(this._render);
        this._flushTemplates()
    },
    _render: function() {
        if (this._needFullRefresh) {
            this._applyFullRefresh();
            this._needFullRefresh = false
        } else if (this._keySplices.length)
            if (this._sortFn)
                this._applySplicesUserSort(this._keySplices);
            else if (this._filterFn)
                this._applyFullRefresh();
            else
                this._applySplicesArrayOrder(this._indexSplices);
        else
            ;this._keySplices = [];
        this._indexSplices = [];
        var keyToIdx = this._keyToInstIdx = {};
        for (var i = this._instances.length - 1; i >= 0; i--) {
            var inst = this._instances[i];
            if (inst.isPlaceholder && i < this._limit)
                inst = this._insertInstance(i, inst.__key__);
            else if (!inst.isPlaceholder && i >= this._limit)
                inst = this._downgradeInstance(i, inst.__key__);
            keyToIdx[inst.__key__] = i;
            if (!inst.isPlaceholder)
                inst.__setProperty(this.indexAs, i, true)
        }
        this._pool.length = 0;
        this._setRenderedItemCount(this._instances.length);
        if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange)
            this.fire("dom-change");
        this._tryRenderChunk()
    },
    _applyFullRefresh: function() {
        var c = this.collection;
        var keys;
        if (this._sortFn)
            keys = c ? c.getKeys() : [];
        else {
            keys = [];
            var items = this.items;
            if (items)
                for (var i = 0; i < items.length; i++)
                    keys.push(c.getKey(items[i]))
        }
        var self = this;
        if (this._filterFn)
            keys = keys.filter(function(a) {
                return self._filterFn(c.getItem(a))
            });
        if (this._sortFn)
            keys.sort(function(a, b) {
                return self._sortFn(c.getItem(a), c.getItem(b))
            });
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var inst = this._instances[i];
            if (inst) {
                inst.__key__ = key;
                if (!inst.isPlaceholder && i < this._limit)
                    inst.__setProperty(this.as, c.getItem(key), true)
            } else if (i < this._limit)
                this._insertInstance(i, key);
            else
                this._insertPlaceholder(i, key)
        }
        for (var j = this._instances.length - 1; j >= i; j--)
            this._detachAndRemoveInstance(j)
    },
    _numericSort: function(a, b) {
        return a - b
    },
    _applySplicesUserSort: function(splices) {
        var c = this.collection;
        var keyMap = {};
        var key;
        for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
            for (var j = 0; j < s.removed.length; j++) {
                key = s.removed[j];
                keyMap[key] = keyMap[key] ? null : -1
            }
            for (j = 0; j < s.added.length; j++) {
                key = s.added[j];
                keyMap[key] = keyMap[key] ? null : 1
            }
        }
        var removedIdxs = [];
        var addedKeys = [];
        for (key in keyMap) {
            if (keyMap[key] === -1)
                removedIdxs.push(this._keyToInstIdx[key]);
            if (keyMap[key] === 1)
                addedKeys.push(key)
        }
        if (removedIdxs.length) {
            removedIdxs.sort(this._numericSort);
            for (i = removedIdxs.length - 1; i >= 0; i--) {
                var idx = removedIdxs[i];
                if (idx !== undefined)
                    this._detachAndRemoveInstance(idx)
            }
        }
        var self = this;
        if (addedKeys.length) {
            if (this._filterFn)
                addedKeys = addedKeys.filter(function(a) {
                    return self._filterFn(c.getItem(a))
                });
            addedKeys.sort(function(a, b) {
                return self._sortFn(c.getItem(a), c.getItem(b))
            });
            var start = 0;
            for (i = 0; i < addedKeys.length; i++)
                start = this._insertRowUserSort(start, addedKeys[i])
        }
    },
    _insertRowUserSort: function(start, key) {
        var c = this.collection;
        var item = c.getItem(key);
        var end = this._instances.length - 1;
        var idx = -1;
        while (start <= end) {
            var mid = start + end >> 1;
            var midKey = this._instances[mid].__key__;
            var cmp = this._sortFn(c.getItem(midKey), item);
            if (cmp < 0)
                start = mid + 1;
            else if (cmp > 0)
                end = mid - 1;
            else {
                idx = mid;
                break
            }
        }
        if (idx < 0)
            idx = end + 1;
        this._insertPlaceholder(idx, key);
        return idx
    },
    _applySplicesArrayOrder: function(splices) {
        for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
            for (var j = 0; j < s.removed.length; j++)
                this._detachAndRemoveInstance(s.index);
            for (j = 0; j < s.addedKeys.length; j++)
                this._insertPlaceholder(s.index + j, s.addedKeys[j])
        }
    },
    _detachInstance: function(idx) {
        var inst = this._instances[idx];
        if (!inst.isPlaceholder) {
            for (var i = 0; i < inst._children.length; i++) {
                var el = inst._children[i];
                Polymer.dom(inst.root).appendChild(el)
            }
            return inst
        }
    },
    _attachInstance: function(idx, parent, refNode) {
        var inst = this._instances[idx];
        if (!inst.isPlaceholder)
            parent.insertBefore(inst.root, refNode)
    },
    _detachAndRemoveInstance: function(idx) {
        var inst = this._detachInstance(idx);
        if (inst)
            this._pool.push(inst);
        this._instances.splice(idx, 1)
    },
    _insertPlaceholder: function(idx, key) {
        this._instances.splice(idx, 0, {
            isPlaceholder: true,
            __key__: key
        })
    },
    _stampInstance: function(idx, key) {
        var model = {
            __key__: key
        };
        model[this.as] = this.collection.getItem(key);
        model[this.indexAs] = idx;
        return this.stamp(model)
    },
    _insertInstance: function(idx, key) {
        var inst = this._pool.pop();
        if (inst) {
            inst.__setProperty(this.as, this.collection.getItem(key), true);
            inst.__setProperty("__key__", key, true)
        } else
            inst = this._stampInstance(idx, key);
        var beforeRow = this._instances[idx + 1];
        var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
        var parentNode = Polymer.dom(this).parentNode;
        if (parentNode.localName == this.is) {
            if (beforeNode == this)
                beforeNode = parentNode;
            parentNode = Polymer.dom(parentNode).parentNode
        }
        Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
        this._instances[idx] = inst;
        return inst
    },
    _downgradeInstance: function(idx, key) {
        var inst = this._detachInstance(idx);
        if (inst)
            this._pool.push(inst);
        inst = {
            isPlaceholder: true,
            __key__: key
        };
        this._instances[idx] = inst;
        return inst
    },
    _showHideChildren: function(hidden) {
        for (var i = 0; i < this._instances.length; i++)
            if (!this._instances[i].isPlaceholder)
                this._instances[i]._showHideChildren(hidden)
    },
    _forwardInstanceProp: function(inst, prop, value) {
        if (prop == this.as) {
            var idx;
            if (this._sortFn || this._filterFn)
                idx = this.items.indexOf(this.collection.getItem(inst.__key__));
            else
                idx = inst[this.indexAs];
            this.set("items." + idx, value)
        }
    },
    _forwardInstancePath: function(inst, path, value) {
        if (path.indexOf(this.as + ".") === 0)
            this._notifyPath("items." + inst.__key__ + "." + path.slice(this.as.length + 1), value)
    },
    _forwardParentProp: function(prop, value) {
        var i$ = this._instances;
        for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++)
            if (!inst.isPlaceholder)
                inst.__setProperty(prop, value, true)
    },
    _forwardParentPath: function(path, value) {
        var i$ = this._instances;
        for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++)
            if (!inst.isPlaceholder)
                inst._notifyPath(path, value, true)
    },
    _forwardItemPath: function(path, value) {
        if (this._keyToInstIdx) {
            var dot = path.indexOf(".");
            var key = path.substring(0, dot < 0 ? path.length : dot);
            var idx = this._keyToInstIdx[key];
            var inst = this._instances[idx];
            if (inst && !inst.isPlaceholder)
                if (dot >= 0) {
                    path = this.as + "." + path.substring(dot + 1);
                    inst._notifyPath(path, value, true)
                } else
                    inst.__setProperty(this.as, value, true)
        }
    },
    itemForElement: function(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.as]
    },
    keyForElement: function(el) {
        var instance = this.modelForElement(el);
        return instance && instance.__key__
    },
    indexForElement: function(el) {
        var instance = this.modelForElement(el);
        return instance && instance[this.indexAs]
    }
});
Polymer({
    is: "array-selector",
    _template: null,
    properties: {
        items: {
            type: Array,
            observer: "clearSelection"
        },
        multi: {
            type: Boolean,
            value: false,
            observer: "clearSelection"
        },
        selected: {
            type: Object,
            notify: true
        },
        selectedItem: {
            type: Object,
            notify: true
        },
        toggle: {
            type: Boolean,
            value: false
        }
    },
    clearSelection: function() {
        if (Array.isArray(this.selected))
            for (var i = 0; i < this.selected.length; i++)
                this.unlinkPaths("selected." + i);
        else {
            this.unlinkPaths("selected");
            this.unlinkPaths("selectedItem")
        }
        if (this.multi) {
            if (!this.selected || this.selected.length) {
                this.selected = [];
                this._selectedColl = Polymer.Collection.get(this.selected)
            }
        } else {
            this.selected = null;
            this._selectedColl = null
        }
        this.selectedItem = null
    },
    isSelected: function(item) {
        if (this.multi)
            return this._selectedColl.getKey(item) !== undefined;
        else
            return this.selected == item
    },
    deselect: function(item) {
        if (this.multi) {
            if (this.isSelected(item)) {
                var skey = this._selectedColl.getKey(item);
                this.arrayDelete("selected", item);
                this.unlinkPaths("selected." + skey)
            }
        } else {
            this.selected = null;
            this.selectedItem = null;
            this.unlinkPaths("selected");
            this.unlinkPaths("selectedItem")
        }
    },
    select: function(item) {
        var icol = Polymer.Collection.get(this.items);
        var key = icol.getKey(item);
        if (this.multi)
            if (this.isSelected(item)) {
                if (this.toggle)
                    this.deselect(item)
            } else {
                this.push("selected", item);
                var skey = this._selectedColl.getKey(item);
                this.linkPaths("selected." + skey, "items." + key)
            }
        else if (this.toggle && item == this.selected)
            this.deselect();
        else {
            this.selected = item;
            this.selectedItem = item;
            this.linkPaths("selected", "items." + key);
            this.linkPaths("selectedItem", "items." + key)
        }
    }
});
Polymer({
    is: "dom-if",
    "extends": "template",
    _template: null,
    properties: {
        "if": {
            type: Boolean,
            value: false,
            observer: "_queueRender"
        },
        restamp: {
            type: Boolean,
            value: false,
            observer: "_queueRender"
        },
        notifyDomChange: {
            type: Boolean
        }
    },
    behaviors: [Polymer.Templatizer],
    _queueRender: function() {
        this._debounceTemplate(this._render)
    },
    detached: function() {
        var parentNode = this.parentNode;
        if (parentNode && parentNode.localName == this.is)
            parentNode = Polymer.dom(parentNode).parentNode;
        if (!parentNode || parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(parentNode instanceof ShadowRoot)))
            this._teardownInstance()
    },
    attached: function() {
        if (this["if"] && this.ctor)
            this.async(this._ensureInstance)
    },
    render: function() {
        this._flushTemplates()
    },
    _render: function() {
        if (this["if"]) {
            if (!this.ctor)
                this.templatize(this);
            this._ensureInstance();
            this._showHideChildren()
        } else if (this.restamp)
            this._teardownInstance();
        if (!this.restamp && this._instance)
            this._showHideChildren();
        if (this["if"] != this._lastIf) {
            if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange)
                this.fire("dom-change");
            this._lastIf = this["if"]
        }
    },
    _ensureInstance: function() {
        var refNode;
        var parentNode = Polymer.dom(this).parentNode;
        if (parentNode && parentNode.localName == this.is) {
            refNode = parentNode;
            parentNode = Polymer.dom(parentNode).parentNode
        } else
            refNode = this;
        if (parentNode)
            if (!this._instance) {
                this._instance = this.stamp();
                var root = this._instance.root;
                Polymer.dom(parentNode).insertBefore(root, refNode)
            } else {
                var c$ = this._instance._children;
                if (c$ && c$.length) {
                    var lastChild = Polymer.dom(refNode).previousSibling;
                    if (lastChild !== c$[c$.length - 1])
                        for (var i = 0, n; i < c$.length && (n = c$[i]); i++)
                            Polymer.dom(parentNode).insertBefore(n, refNode)
                }
            }
    },
    _teardownInstance: function() {
        if (this._instance) {
            var c$ = this._instance._children;
            if (c$ && c$.length) {
                var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
                for (var i = 0, n; i < c$.length && (n = c$[i]); i++)
                    parent.removeChild(n)
            }
            this._instance = null
        }
    },
    _showHideChildren: function() {
        var hidden = this.__hideTemplateChildren__ || !this["if"];
        if (this._instance)
            this._instance._showHideChildren(hidden)
    },
    _forwardParentProp: function(prop, value) {
        if (this._instance)
            this._instance.__setProperty(prop, value, true)
    },
    _forwardParentPath: function(path, value) {
        if (this._instance)
            this._instance._notifyPath(path, value, true)
    }
});
Polymer({
    is: "dom-bind",
    properties: {
        notifyDomChange: {
            type: Boolean
        }
    },
    "extends": "template",
    _template: null,
    created: function() {
        var self = this;
        Polymer.RenderStatus.whenReady(function() {
            if (document.readyState == "loading")
                document.addEventListener("DOMContentLoaded", function() {
                    self._markImportsReady()
                });
            else
                self._markImportsReady()
        })
    },
    _ensureReady: function() {
        if (!this._readied)
            this._readySelf()
    },
    _markImportsReady: function() {
        this._importsReady = true;
        this._ensureReady()
    },
    _registerFeatures: function() {
        this._prepConstructor()
    },
    _insertChildren: function() {
        var refNode;
        var parentNode = Polymer.dom(this).parentNode;
        if (parentNode.localName == this.is) {
            refNode = parentNode;
            parentNode = Polymer.dom(parentNode).parentNode
        } else
            refNode = this;
        Polymer.dom(parentNode).insertBefore(this.root, refNode)
    },
    _removeChildren: function() {
        if (this._children)
            for (var i = 0; i < this._children.length; i++)
                this.root.appendChild(this._children[i])
    },
    _initFeatures: function() {},
    _scopeElementClass: function(element, selector) {
        if (this.dataHost)
            return this.dataHost._scopeElementClass(element, selector);
        else
            return selector
    },
    _configureInstanceProperties: function() {},
    _prepConfigure: function() {
        var config = {};
        for (var prop in this._propertyEffects)
            config[prop] = this[prop];
        var setupConfigure = this._setupConfigure;
        this._setupConfigure = function() {
            setupConfigure.call(this, config)
        }
    },
    attached: function() {
        if (this._importsReady)
            this.render()
    },
    detached: function() {
        this._removeChildren()
    },
    render: function() {
        this._ensureReady();
        if (!this._children) {
            this._template = this;
            this._prepAnnotations();
            this._prepEffects();
            this._prepBehaviors();
            this._prepConfigure();
            this._prepBindings();
            this._prepPropertyInfo();
            Polymer.Base._initFeatures.call(this);
            this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root)
        }
        this._insertChildren();
        if (!Polymer.Settings.suppressTemplateNotifications || this.notifyDomChange)
            this.fire("dom-change")
    }
});
'use strict';
var g, n = n || {};
n.scope = {};
n.ASSUME_ES5 = !1;
n.ASSUME_NO_NATIVE_MAP = !1;
n.ASSUME_NO_NATIVE_SET = !1;
n.defineProperty = n.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, c) {
    a != Array.prototype && a != Object.prototype && (a[b] = c.value)
}
;
n.getGlobal = function(a) {
    return "undefined" != typeof window && window === a ? a : "undefined" != typeof global && null != global ? global : a
}
;
n.global = n.getGlobal(this);
n.SYMBOL_PREFIX = "jscomp_symbol_";
n.initSymbol = function() {
    n.initSymbol = function() {}
    ;
    n.global.Symbol || (n.global.Symbol = n.Symbol)
}
;
n.Symbol = function() {
    function a(a) {
        return n.SYMBOL_PREFIX + (a || "") + b++
    }
    var b = 0;
    return a
}();
n.initSymbolIterator = function() {
    n.initSymbol();
    var a = n.global.Symbol.iterator;
    a || (a = n.global.Symbol.iterator = n.global.Symbol("iterator"));
    "function" != typeof Array.prototype[a] && n.defineProperty(Array.prototype, a, {
        configurable: !0,
        writable: !0,
        value: function() {
            return n.arrayIterator(this)
        }
    });
    n.initSymbolIterator = function() {}
}
;
n.arrayIterator = function(a) {
    var b = 0;
    return n.iteratorPrototype(function() {
        return b < a.length ? {
            done: !1,
            value: a[b++]
        } : {
            done: !0
        }
    })
}
;
n.iteratorPrototype = function(a) {
    n.initSymbolIterator();
    a = {
        next: a
    };
    a[n.global.Symbol.iterator] = function() {
        return this
    }
    ;
    return a
}
;
n.makeIterator = function(a) {
    n.initSymbolIterator();
    var b = a[Symbol.iterator];
    return b ? b.call(a) : n.arrayIterator(a)
}
;
n.iteratorFromArray = function(a, b) {
    n.initSymbolIterator();
    a instanceof String && (a += "");
    var c = 0
      , d = {
        next: function() {
            if (c < a.length) {
                var e = c++;
                return {
                    value: b(e, a[e]),
                    done: !1
                }
            }
            d.next = function() {
                return {
                    done: !0,
                    value: void 0
                }
            }
            ;
            return d.next()
        }
    };
    d[Symbol.iterator] = function() {
        return d
    }
    ;
    return d
}
;
n.polyfill = function(a, b) {
    if (b) {
        var c = n.global;
        a = a.split(".");
        for (var d = 0; d < a.length - 1; d++) {
            var e = a[d];
            e in c || (c[e] = {});
            c = c[e]
        }
        a = a[a.length - 1];
        d = c[a];
        b = b(d);
        b != d && null != b && n.defineProperty(c, a, {
            configurable: !0,
            writable: !0,
            value: b
        })
    }
}
;
n.polyfill("Array.prototype.keys", function(a) {
    return a ? a : a = function() {
        return n.iteratorFromArray(this, function(a) {
            return a
        })
    }
}, "es6", "es3");
n.polyfill("Array.prototype.fill", function(a) {
    return a ? a : a = function(a, c, d) {
        var b = this.length || 0;
        0 > c && (c = Math.max(0, b + c));
        if (null == d || d > b)
            d = b;
        d = Number(d);
        0 > d && (d = Math.max(0, b + d));
        for (c = Number(c || 0); c < d; c++)
            this[c] = a;
        return this
    }
}, "es6", "es3");
n.polyfill("Array.from", function(a) {
    return a ? a : a = function(a, c, d) {
        n.initSymbolIterator();
        c = null != c ? c : function(a) {
            return a
        }
        ;
        var b = []
          , f = a[Symbol.iterator];
        if ("function" == typeof f)
            for (a = f.call(a); !(f = a.next()).done; )
                b.push(c.call(d, f.value));
        else {
            f = a.length;
            for (var l = 0; l < f; l++)
                b.push(c.call(d, a[l]))
        }
        return b
    }
}, "es6", "es3");
n.polyfill("Math.sign", function(a) {
    return a ? a : a = function(a) {
        a = Number(a);
        return 0 === a || isNaN(a) ? a : 0 < a ? 1 : -1
    }
}, "es6", "es3");
n.FORCE_POLYFILL_PROMISE = !1;
n.polyfill("Promise", function(a) {
    function b() {
        this.batch_ = null
    }
    function c(a) {
        return a instanceof f ? a : new f(function(b) {
            b(a)
        }
        )
    }
    if (a && !n.FORCE_POLYFILL_PROMISE)
        return a;
    b.prototype.asyncExecute = function(a) {
        null == this.batch_ && (this.batch_ = [],
        this.asyncExecuteBatch_());
        this.batch_.push(a);
        return this
    }
    ;
    b.prototype.asyncExecuteBatch_ = function() {
        var a = this;
        this.asyncExecuteFunction(function() {
            a.executeBatch_()
        })
    }
    ;
    var d = n.global.setTimeout;
    b.prototype.asyncExecuteFunction = function(a) {
        d(a, 0)
    }
    ;
    b.prototype.executeBatch_ = function() {
        for (; this.batch_ && this.batch_.length; ) {
            var a = this.batch_;
            this.batch_ = [];
            for (var b = 0; b < a.length; ++b) {
                var d = a[b];
                delete a[b];
                try {
                    d()
                } catch (r) {
                    this.asyncThrow_(r)
                }
            }
        }
        this.batch_ = null
    }
    ;
    b.prototype.asyncThrow_ = function(a) {
        this.asyncExecuteFunction(function() {
            throw a;
        })
    }
    ;
    var e = {
        PENDING: 0,
        FULFILLED: 1,
        REJECTED: 2
    }
      , f = function(a) {
        this.state_ = e.PENDING;
        this.result_ = void 0;
        this.onSettledCallbacks_ = [];
        var b = this.createResolveAndReject_();
        try {
            a(b.resolve, b.reject)
        } catch (m) {
            b.reject(m)
        }
    };
    f.prototype.createResolveAndReject_ = function() {
        function a(a) {
            return function(c) {
                d || (d = !0,
                a.call(b, c))
            }
        }
        var b = this
          , d = !1;
        return {
            resolve: a(this.resolveTo_),
            reject: a(this.reject_)
        }
    }
    ;
    f.prototype.resolveTo_ = function(a) {
        if (a === this)
            this.reject_(new TypeError("A Promise cannot resolve to itself"));
        else if (a instanceof f)
            this.settleSameAsPromise_(a);
        else {
            a: switch (typeof a) {
            case "object":
                var b = null != a;
                break a;
            case "function":
                b = !0;
                break a;
            default:
                b = !1
            }
            b ? this.resolveToNonPromiseObj_(a) : this.fulfill_(a)
        }
    }
    ;
    f.prototype.resolveToNonPromiseObj_ = function(a) {
        var b = void 0;
        try {
            b = a.then
        } catch (m) {
            this.reject_(m);
            return
        }
        "function" == typeof b ? this.settleSameAsThenable_(b, a) : this.fulfill_(a)
    }
    ;
    f.prototype.reject_ = function(a) {
        this.settle_(e.REJECTED, a)
    }
    ;
    f.prototype.fulfill_ = function(a) {
        this.settle_(e.FULFILLED, a)
    }
    ;
    f.prototype.settle_ = function(a, b) {
        if (this.state_ != e.PENDING)
            throw Error("Cannot settle(" + a + ", " + b | "): Promise already settled in state" + this.state_);
        this.state_ = a;
        this.result_ = b;
        this.executeOnSettledCallbacks_()
    }
    ;
    f.prototype.executeOnSettledCallbacks_ = function() {
        if (null != this.onSettledCallbacks_) {
            for (var a = this.onSettledCallbacks_, b = 0; b < a.length; ++b)
                a[b].call(),
                a[b] = null;
            this.onSettledCallbacks_ = null
        }
    }
    ;
    var l = new b;
    f.prototype.settleSameAsPromise_ = function(a) {
        var b = this.createResolveAndReject_();
        a.callWhenSettled_(b.resolve, b.reject)
    }
    ;
    f.prototype.settleSameAsThenable_ = function(a, b) {
        var d = this.createResolveAndReject_();
        try {
            a.call(b, d.resolve, d.reject)
        } catch (r) {
            d.reject(r)
        }
    }
    ;
    f.prototype.then = function(a, b) {
        function d(a, b) {
            return "function" == typeof a ? function(b) {
                try {
                    c(a(b))
                } catch (u) {
                    e(u)
                }
            }
            : b
        }
        var c, e, h = new f(function(a, b) {
            c = a;
            e = b
        }
        );
        this.callWhenSettled_(d(a, c), d(b, e));
        return h
    }
    ;
    f.prototype.catch = function(a) {
        return this.then(void 0, a)
    }
    ;
    f.prototype.callWhenSettled_ = function(a, b) {
        function d() {
            switch (c.state_) {
            case e.FULFILLED:
                a(c.result_);
                break;
            case e.REJECTED:
                b(c.result_);
                break;
            default:
                throw Error("Unexpected state: " + c.state_);
            }
        }
        var c = this;
        null == this.onSettledCallbacks_ ? l.asyncExecute(d) : this.onSettledCallbacks_.push(function() {
            l.asyncExecute(d)
        })
    }
    ;
    f.resolve = c;
    f.reject = function(a) {
        return new f(function(b, d) {
            d(a)
        }
        )
    }
    ;
    f.race = function(a) {
        return new f(function(b, d) {
            for (var e = n.makeIterator(a), f = e.next(); !f.done; f = e.next())
                c(f.value).callWhenSettled_(b, d)
        }
        )
    }
    ;
    f.all = function(a) {
        var b = n.makeIterator(a)
          , d = b.next();
        return d.done ? c([]) : new f(function(a, e) {
            function f(b) {
                return function(d) {
                    h[b] = d;
                    k--;
                    0 == k && a(h)
                }
            }
            var h = []
              , k = 0;
            do
                h.push(void 0),
                k++,
                c(d.value).callWhenSettled_(f(h.length - 1), e),
                d = b.next();
            while (!d.done)
        }
        )
    }
    ;
    return f
}, "es6", "es3");
var p = p || {};
p.global = this;
p.isDef = function(a) {
    return void 0 !== a
}
;
p.isString = function(a) {
    return "string" == typeof a
}
;
p.isBoolean = function(a) {
    return "boolean" == typeof a
}
;
p.isNumber = function(a) {
    return "number" == typeof a
}
;
p.exportPath_ = function(a, b, c) {
    a = a.split(".");
    c = c || p.global;
    a[0]in c || !c.execScript || c.execScript("var " + a[0]);
    for (var d; a.length && (d = a.shift()); )
        !a.length && p.isDef(b) ? c[d] = b : c = c[d] && c[d] !== Object.prototype[d] ? c[d] : c[d] = {}
}
;
p.define = function(a, b) {
    p.exportPath_(a, b)
}
;
p.DEBUG = !0;
p.LOCALE = "en";
p.TRUSTED_SITE = !0;
p.STRICT_MODE_COMPATIBLE = !1;
p.DISALLOW_TEST_ONLY_CODE = !p.DEBUG;
p.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1;
p.provide = function(a) {
    if (p.isInModuleLoader_())
        throw Error("goog.provide can not be used within a goog.module.");
    p.constructNamespace_(a)
}
;
p.constructNamespace_ = function(a, b) {
    p.exportPath_(a, b)
}
;
p.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
p.module = function(a) {
    if (!p.isString(a) || !a || -1 == a.search(p.VALID_MODULE_RE_))
        throw Error("Invalid module identifier");
    if (!p.isInModuleLoader_())
        throw Error("Module " + a + " has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
    if (p.moduleLoaderState_.moduleName)
        throw Error("goog.module may only be called once per module.");
    p.moduleLoaderState_.moduleName = a
}
;
p.module.get = function() {
    return null
}
;
p.module.getInternal_ = function() {
    return null
}
;
p.moduleLoaderState_ = null;
p.isInModuleLoader_ = function() {
    return null != p.moduleLoaderState_
}
;
p.module.declareLegacyNamespace = function() {
    p.moduleLoaderState_.declareLegacyNamespace = !0
}
;
p.setTestOnly = function(a) {
    if (p.DISALLOW_TEST_ONLY_CODE)
        throw a = a || "",
        Error("Importing test-only code into non-debug environment" + (a ? ": " + a : "."));
}
;
p.forwardDeclare = function() {}
;
p.getObjectByName = function(a, b) {
    a = a.split(".");
    b = b || p.global;
    for (var c = 0; c < a.length; c++)
        if (b = b[a[c]],
        !p.isDefAndNotNull(b))
            return null;
    return b
}
;
p.globalize = function(a, b) {
    b = b || p.global;
    for (var c in a)
        b[c] = a[c]
}
;
p.addDependency = function(a, b, c, d) {
    if (p.DEPENDENCIES_ENABLED) {
        var e = p.getLoader_();
        e && e.addDependency(a, b, c, d)
    }
}
;
p.useStrictRequires = !1;
p.ENABLE_DEBUG_LOADER = !0;
p.logToConsole_ = function(a) {
    p.global.console && p.global.console.error(a)
}
;
p.require = function(a) {
    p.ENABLE_DEBUG_LOADER && p.debugLoader_ && p.getLoader_().earlyProcessLoad(a)
}
;
p.basePath = "";
p.nullFunction = function() {}
;
p.abstractMethod = function() {
    throw Error("unimplemented abstract method");
}
;
p.addSingletonGetter = function(a) {
    a.instance_ = void 0;
    a.getInstance = function() {
        if (a.instance_)
            return a.instance_;
        p.DEBUG && (p.instantiatedSingletons_[p.instantiatedSingletons_.length] = a);
        return a.instance_ = new a
    }
}
;
p.instantiatedSingletons_ = [];
p.LOAD_MODULE_USING_EVAL = !0;
p.SEAL_MODULE_EXPORTS = p.DEBUG;
p.loadedModules_ = {};
p.DEPENDENCIES_ENABLED = !1;
p.TRANSPILE = "detect";
p.TRANSPILER = "transpile.js";
p.DEBUG_LOADER = "";
p.hasBadLetScoping = null;
p.useSafari10Workaround = function() {
    if (null == p.hasBadLetScoping) {
        try {
            var a = !eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";')
        } catch (b) {
            a = !1
        }
        p.hasBadLetScoping = a
    }
    return p.hasBadLetScoping
}
;
p.workaroundSafari10EvalBug = function(a) {
    return "(function(){" + a + "\n;})();\n"
}
;
p.loadModule = function(a) {
    var b = p.moduleLoaderState_;
    try {
        p.moduleLoaderState_ = {
            moduleName: void 0,
            declareLegacyNamespace: !1
        };
        if (p.isFunction(a))
            var c = a.call(void 0, {});
        else if (p.isString(a))
            p.useSafari10Workaround() && (a = p.workaroundSafari10EvalBug(a)),
            c = p.loadModuleFromSource_.call(void 0, a);
        else
            throw Error("Invalid module definition");
        var d = p.moduleLoaderState_.moduleName;
        if (!p.isString(d) || !d)
            throw Error('Invalid module name "' + d + '"');
        p.moduleLoaderState_.declareLegacyNamespace ? p.constructNamespace_(d, c) : p.SEAL_MODULE_EXPORTS && Object.seal && "object" == typeof c && null != c && Object.seal(c);
        p.loadedModules_[d] = c
    } finally {
        p.moduleLoaderState_ = b
    }
}
;
p.loadModuleFromSource_ = function(a) {
    var b = {};
    eval(a);
    return b
}
;
p.normalizePath_ = function(a) {
    a = a.split("/");
    for (var b = 0; b < a.length; )
        "." == a[b] ? a.splice(b, 1) : b && ".." == a[b] && a[b - 1] && ".." != a[b - 1] ? a.splice(--b, 2) : b++;
    return a.join("/")
}
;
p.loadFileSync_ = function(a) {
    if (p.global.CLOSURE_LOAD_FILE_SYNC)
        return p.global.CLOSURE_LOAD_FILE_SYNC(a);
    try {
        var b = new p.global.XMLHttpRequest;
        b.open("get", a, !1);
        b.send();
        return 0 == b.status || 200 == b.status ? b.responseText : null
    } catch (c) {
        return null
    }
}
;
p.transpile_ = function(a, b) {
    var c = p.global.$jscomp;
    c || (p.global.$jscomp = c = {});
    var d = c.transpile;
    if (!d) {
        var e = p.basePath + p.TRANSPILER
          , f = p.loadFileSync_(e);
        if (f) {
            (function() {
                eval(f + "\n//# sourceURL=" + e)
            }
            ).call(p.global);
            if (p.global.$gwtExport && p.global.$gwtExport.$jscomp && !p.global.$gwtExport.$jscomp.transpile)
                throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: ' + JSON.stringify(p.global.$gwtExport));
            p.global.$jscomp.transpile = p.global.$gwtExport.$jscomp.transpile;
            c = p.global.$jscomp;
            d = c.transpile
        }
    }
    if (!d) {
        var l = " requires transpilation but no transpiler was found.";
        l += ' Please add "//javascript/closure:transpiler" as a data dependency to ensure it is included.';
        d = c.transpile = function(a, b) {
            p.logToConsole_(b + l);
            return a
        }
    }
    return d(a, b)
}
;
p.typeOf = function(a) {
    var b = typeof a;
    if ("object" == b)
        if (a) {
            if (a instanceof Array)
                return "array";
            if (a instanceof Object)
                return b;
            var c = Object.prototype.toString.call(a);
            if ("[object Window]" == c)
                return "object";
            if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice"))
                return "array";
            if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call"))
                return "function"
        } else
            return "null";
    else if ("function" == b && "undefined" == typeof a.call)
        return "object";
    return b
}
;
p.isNull = function(a) {
    return null === a
}
;
p.isDefAndNotNull = function(a) {
    return null != a
}
;
p.isArray = function(a) {
    return "array" == p.typeOf(a)
}
;
p.isArrayLike = function(a) {
    var b = p.typeOf(a);
    return "array" == b || "object" == b && "number" == typeof a.length
}
;
p.isDateLike = function(a) {
    return p.isObject(a) && "function" == typeof a.getFullYear
}
;
p.isFunction = function(a) {
    return "function" == p.typeOf(a)
}
;
p.isObject = function(a) {
    var b = typeof a;
    return "object" == b && null != a || "function" == b
}
;
p.getUid = function(a) {
    return a[p.UID_PROPERTY_] || (a[p.UID_PROPERTY_] = ++p.uidCounter_)
}
;
p.hasUid = function(a) {
    return !!a[p.UID_PROPERTY_]
}
;
p.removeUid = function(a) {
    null !== a && "removeAttribute"in a && a.removeAttribute(p.UID_PROPERTY_);
    try {
        delete a[p.UID_PROPERTY_]
    } catch (b) {}
}
;
p.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
p.uidCounter_ = 0;
p.getHashCode = p.getUid;
p.removeHashCode = p.removeUid;
p.cloneObject = function(a) {
    var b = p.typeOf(a);
    if ("object" == b || "array" == b) {
        if (a.clone)
            return a.clone();
        b = "array" == b ? [] : {};
        for (var c in a)
            b[c] = p.cloneObject(a[c]);
        return b
    }
    return a
}
;
p.bindNative_ = function(a, b, c) {
    return a.call.apply(a.bind, arguments)
}
;
p.bindJs_ = function(a, b, c) {
    if (!a)
        throw Error();
    if (2 < arguments.length) {
        var d = Array.prototype.slice.call(arguments, 2);
        return function() {
            var c = Array.prototype.slice.call(arguments);
            Array.prototype.unshift.apply(c, d);
            return a.apply(b, c)
        }
    }
    return function() {
        return a.apply(b, arguments)
    }
}
;
p.bind = function(a, b, c) {
    p.bind = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? p.bindNative_ : p.bindJs_;
    return p.bind.apply(null, arguments)
}
;
p.partial = function(a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function() {
        var b = c.slice();
        b.push.apply(b, arguments);
        return a.apply(this, b)
    }
}
;
p.mixin = function(a, b) {
    for (var c in b)
        a[c] = b[c]
}
;
p.now = p.TRUSTED_SITE && Date.now || function() {
    return +new Date
}
;
p.globalEval = function(a) {
    if (p.global.execScript)
        p.global.execScript(a, "JavaScript");
    else if (p.global.eval) {
        if (null == p.evalWorksForGlobals_) {
            try {
                p.global.eval("var _evalTest_ = 1;")
            } catch (d) {}
            if ("undefined" != typeof p.global._evalTest_) {
                try {
                    delete p.global._evalTest_
                } catch (d) {}
                p.evalWorksForGlobals_ = !0
            } else
                p.evalWorksForGlobals_ = !1
        }
        if (p.evalWorksForGlobals_)
            p.global.eval(a);
        else {
            var b = p.global.document
              , c = b.createElement("SCRIPT");
            c.type = "text/javascript";
            c.defer = !1;
            c.appendChild(b.createTextNode(a));
            b.head.appendChild(c);
            b.head.removeChild(c)
        }
    } else
        throw Error("goog.globalEval not available");
}
;
p.evalWorksForGlobals_ = null;
p.getCssName = function(a, b) {
    if ("." == String(a).charAt(0))
        throw Error('className passed in goog.getCssName must not start with ".". You passed: ' + a);
    var c = function(a) {
        return p.cssNameMapping_[a] || a
    }
      , d = function(a) {
        a = a.split("-");
        for (var b = [], d = 0; d < a.length; d++)
            b.push(c(a[d]));
        return b.join("-")
    };
    d = p.cssNameMapping_ ? "BY_WHOLE" == p.cssNameMappingStyle_ ? c : d : function(a) {
        return a
    }
    ;
    a = b ? a + "-" + d(b) : d(a);
    return p.global.CLOSURE_CSS_NAME_MAP_FN ? p.global.CLOSURE_CSS_NAME_MAP_FN(a) : a
}
;
p.setCssNameMapping = function(a, b) {
    p.cssNameMapping_ = a;
    p.cssNameMappingStyle_ = b
}
;
p.getMsg = function(a, b) {
    b && (a = a.replace(/\{\$([^}]+)}/g, function(a, d) {
        return null != b && d in b ? b[d] : a
    }));
    return a
}
;
p.getMsgWithFallback = function(a) {
    return a
}
;
p.exportSymbol = function(a, b, c) {
    p.exportPath_(a, b, c)
}
;
p.exportProperty = function(a, b, c) {
    a[b] = c
}
;
p.inherits = function(a, b) {
    function c() {}
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c;
    a.prototype.constructor = a;
    a.base = function(a, c, f) {
        for (var d = Array(arguments.length - 2), e = 2; e < arguments.length; e++)
            d[e - 2] = arguments[e];
        return b.prototype[c].apply(a, d)
    }
}
;
p.base = function(a, b, c) {
    var d = arguments.callee.caller;
    if (p.STRICT_MODE_COMPATIBLE || p.DEBUG && !d)
        throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
    if (d.superClass_) {
        for (var e = Array(arguments.length - 1), f = 1; f < arguments.length; f++)
            e[f - 1] = arguments[f];
        return d.superClass_.constructor.apply(a, e)
    }
    e = Array(arguments.length - 2);
    for (f = 2; f < arguments.length; f++)
        e[f - 2] = arguments[f];
    f = !1;
    for (var l = a.constructor; l; l = l.superClass_ && l.superClass_.constructor)
        if (l.prototype[b] === d)
            f = !0;
        else if (f)
            return l.prototype[b].apply(a, e);
    if (a[b] === d)
        return a.constructor.prototype[b].apply(a, e);
    throw Error("goog.base called from a method of one name to a method of a different name");
}
;
p.scope = function(a) {
    if (p.isInModuleLoader_())
        throw Error("goog.scope is not supported within a goog.module.");
    a.call(p.global)
}
;
p.defineClass = function(a, b) {
    var c = b.constructor
      , d = b.statics;
    c && c != Object.prototype.constructor || (c = function() {
        throw Error("cannot instantiate an interface (no constructor defined).");
    }
    );
    c = p.defineClass.createSealingConstructor_(c, a);
    a && p.inherits(c, a);
    delete b.constructor;
    delete b.statics;
    p.defineClass.applyProperties_(c.prototype, b);
    null != d && (d instanceof Function ? d(c) : p.defineClass.applyProperties_(c, d));
    return c
}
;
p.defineClass.SEAL_CLASS_INSTANCES = p.DEBUG;
p.defineClass.createSealingConstructor_ = function(a, b) {
    if (!p.defineClass.SEAL_CLASS_INSTANCES)
        return a;
    var c = !p.defineClass.isUnsealable_(b)
      , d = function() {
        var b = a.apply(this, arguments) || this;
        b[p.UID_PROPERTY_] = b[p.UID_PROPERTY_];
        this.constructor === d && c && Object.seal instanceof Function && Object.seal(b);
        return b
    };
    return d
}
;
p.defineClass.isUnsealable_ = function(a) {
    return a && a.prototype && a.prototype[p.UNSEALABLE_CONSTRUCTOR_PROPERTY_]
}
;
p.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
p.defineClass.applyProperties_ = function(a, b) {
    for (var c in b)
        Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
    for (var d = 0; d < p.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; d++)
        c = p.defineClass.OBJECT_PROTOTYPE_FIELDS_[d],
        Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c])
}
;
p.tagUnsealableClass = function() {}
;
p.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
if (p.DEPENDENCIES_ENABLED) {
    p.inHtmlDocument_ = function() {
        var a = p.global.document;
        return null != a && "write"in a
    }
    ;
    p.findBasePath_ = function() {
        if (p.isDef(p.global.CLOSURE_BASE_PATH) && p.isString(p.global.CLOSURE_BASE_PATH))
            p.basePath = p.global.CLOSURE_BASE_PATH;
        else if (p.inHtmlDocument_()) {
            var a = p.global.document
              , b = a.currentScript;
            a = b ? [b] : a.getElementsByTagName("SCRIPT");
            for (b = a.length - 1; 0 <= b; --b) {
                var c = a[b];
                c = c.src;
                var d = c.lastIndexOf("?");
                d = -1 == d ? c.length : d;
                if ("base.js" == c.substr(d - 7, 7)) {
                    p.basePath = c.substr(0, d - 7);
                    break
                }
            }
        }
    }
    ;
    p.findBasePath_();
    p.Transpiler = function() {
        this.requiresTranspilation_ = null
    }
    ;
    p.Transpiler.prototype.createRequiresTranspilation_ = function() {
        function a(a, b) {
            d ? c[a] = !0 : b() ? c[a] = !1 : d = c[a] = !0
        }
        function b(a) {
            try {
                return !!eval(a)
            } catch (l) {
                return !1
            }
        }
        var c = {
            es3: !1
        }
          , d = !1
          , e = p.global.navigator && p.global.navigator.userAgent ? p.global.navigator.userAgent : "";
        a("es5", function() {
            return b("[1,].length==1")
        });
        a("es6", function() {
            var a = /Edge\/(\d+)(\.\d)*/i;
            return (a = e.match(a)) && 15 > Number(a[1]) ? !1 : b('(()=>{"use strict";class X{constructor(){if(new.target!=String)throw 1;this.x=42}}let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof String))throw 1;for(const a of[2,3]){if(a==2)continue;function f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()==3}})()')
        });
        a("es6-impl", function() {
            return !0
        });
        a("es7", function() {
            return b("2 ** 2 == 4")
        });
        a("es8", function() {
            return b("async () => 1, true")
        });
        return c
    }
    ;
    p.Transpiler.prototype.needsTranspile = function(a) {
        if ("always" == p.TRANSPILE)
            return !0;
        if ("never" == p.TRANSPILE)
            return !1;
        this.requiresTranspilation_ || (this.requiresTranspilation_ = this.createRequiresTranspilation_());
        if (a in this.requiresTranspilation_)
            return this.requiresTranspilation_[a];
        throw Error("Unknown language mode: " + a);
    }
    ;
    p.Transpiler.prototype.transpile = function(a, b) {
        return p.transpile_(a, b)
    }
    ;
    p.transpiler_ = new p.Transpiler;
    p.DebugLoader = function() {
        this.dependencies_ = {
            loadFlags: {},
            nameToPath: {},
            requires: {},
            visited: {},
            written: {},
            deferred: {}
        };
        this.lastNonModuleScriptIndex_ = 0
    }
    ;
    p.DebugLoader.IS_OLD_IE_ = !(p.global.atob || !p.global.document || !p.global.document.all);
    g = p.DebugLoader.prototype;
    g.earlyProcessLoad = function(a) {
        p.DebugLoader.IS_OLD_IE_ && this.maybeProcessDeferredDep_(a)
    }
    ;
    g.load = function(a) {
        var b = this.getPathFromDeps_(a);
        if (b) {
            var c = function(a) {
                if (!(a in f.written || a in f.visited)) {
                    f.visited[a] = !0;
                    if (a in f.requires)
                        for (var b in f.requires[a])
                            if (!l.isProvided(b))
                                if (b in f.nameToPath)
                                    c(f.nameToPath[b]);
                                else
                                    throw Error("Undefined nameToPath for " + b);
                    a in e || (e[a] = !0,
                    d.push(a))
                }
            }
              , d = []
              , e = {}
              , f = this.dependencies_
              , l = this;
            c(b);
            for (a = 0; a < d.length; a++)
                b = d[a],
                this.dependencies_.written[b] = !0;
            for (a = 0; a < d.length; a++)
                if (b = d[a]) {
                    var h = f.loadFlags[b] || {}
                      , k = h.lang || "es3";
                    k = this.getTranspiler().needsTranspile(k);
                    "goog" == h.module || k ? this.importProcessedScript_(p.basePath + b, "goog" == h.module, k) : this.importScript_(p.basePath + b)
                } else
                    throw Error("Undefined script input");
        } else if (a = "goog.require could not find: " + a,
        this.logToConsole(a),
        p.useStrictRequires)
            throw Error(a);
    }
    ;
    g.addDependency = function(a, b, c, d) {
        var e;
        a = a.replace(/\\/g, "/");
        var f = this.dependencies_;
        d && "boolean" !== typeof d || (d = d ? {
            module: "goog"
        } : {});
        for (var l = 0; e = b[l]; l++)
            f.nameToPath[e] = a,
            f.loadFlags[a] = d;
        for (d = 0; b = c[d]; d++)
            a in f.requires || (f.requires[a] = {}),
            f.requires[a][b] = !0
    }
    ;
    g.importScript_ = function(a, b) {
        var c = p.global.CLOSURE_IMPORT_SCRIPT || p.bind(this.writeScriptTag_, this);
        c(a, b) && (this.dependencies_.written[a] = !0)
    }
    ;
    g.importProcessedScript_ = function(a, b, c) {
        a = 'goog.debugLoader_.retrieveAndExec_("' + a + '", ' + b + ", " + c + ");";
        this.importScript_("", a)
    }
    ;
    g.maybeProcessDeferredDep_ = function(a) {
        this.isDeferredModule_(a) && this.allDepsAreAvailable_(a) && (a = this.getPathFromDeps_(a),
        this.maybeProcessDeferredPath_(p.basePath + a))
    }
    ;
    g.isDeferredModule_ = function(a) {
        var b = (a = this.getPathFromDeps_(a)) && this.dependencies_.loadFlags[a] || {}
          , c = b.lang || "es3";
        return a && ("goog" == b.module || this.getTranspiler().needsTranspile(c)) ? (a = p.basePath + a,
        a in this.dependencies_.deferred) : !1
    }
    ;
    g.allDepsAreAvailable_ = function(a) {
        if ((a = this.getPathFromDeps_(a)) && a in this.dependencies_.requires)
            for (var b in this.dependencies_.requires[a])
                if (!this.isProvided(b) && !this.isDeferredModule_(b))
                    return !1;
        return !0
    }
    ;
    g.maybeProcessDeferredPath_ = function(a) {
        if (a in this.dependencies_.deferred) {
            var b = this.dependencies_.deferred[a];
            delete this.dependencies_.deferred[a];
            p.globalEval(b)
        }
    }
    ;
    g.writeScriptSrcNode_ = function(a) {
        p.global.document.write('<script type="text/javascript" src="' + a + '">\x3c/script>')
    }
    ;
    g.appendScriptSrcNode_ = function(a) {
        var b = p.global.document
          , c = b.createElement("script");
        c.type = "text/javascript";
        c.src = a;
        c.defer = !1;
        c.async = !1;
        b.head.appendChild(c)
    }
    ;
    g.writeScriptTag_ = function(a, b) {
        if (this.inHtmlDocument()) {
            var c = p.global.document;
            if (!p.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && "complete" == c.readyState) {
                if (c = /\bdeps.js$/.test(a))
                    return !1;
                throw Error('Cannot write "' + a + '" after document load');
            }
            void 0 === b ? p.DebugLoader.IS_OLD_IE_ ? (b = " onreadystatechange='goog.debugLoader_.onScriptLoad_(this, " + ++this.lastNonModuleScriptIndex_ + ")' ",
            c.write('<script type="text/javascript" src="' + a + '"' + b + ">\x3c/script>")) : p.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING ? this.appendScriptSrcNode_(a) : this.writeScriptSrcNode_(a) : c.write('<script type="text/javascript">' + this.protectScriptTag_(b) + "\x3c/script>");
            return !0
        }
        return !1
    }
    ;
    g.protectScriptTag_ = function(a) {
        return a.replace(/<\/(SCRIPT)/ig, "\\x3c/$1")
    }
    ;
    g.getPathFromDeps_ = function(a) {
        return a in this.dependencies_.nameToPath ? this.dependencies_.nameToPath[a] : null
    }
    ;
    g.getTranspiler = function() {
        return p.transpiler_
    }
    ;
    g.isProvided = function(a) {
        return p.isProvided_(a)
    }
    ;
    g.inHtmlDocument = function() {
        return p.inHtmlDocument_()
    }
    ;
    g.logToConsole = function(a) {
        p.logToConsole_(a)
    }
    ;
    p.debugLoader_ = null;
    p.registerDebugLoader = function(a) {
        if (p.debugLoader_)
            throw Error("Debug loader already registered!");
        if (!(a instanceof p.DebugLoader))
            throw Error("Not a goog.DebugLoader.");
        p.debugLoader_ = a
    }
    ;
    p.getLoader_ = function() {
        if (!p.debugLoader_ && p.DEBUG_LOADER)
            throw Error("Loaded debug loader file but no loader was registered!");
        p.debugLoader_ || (p.debugLoader_ = new p.DebugLoader);
        return p.debugLoader_
    }
    ;
    var x;
    p.DEBUG_LOADER && (x = new p.DebugLoader,
    x.importScript_(p.basePath + p.DEBUG_LOADER));
    p.global.CLOSURE_NO_DEPS || (x = x || new p.DebugLoader,
    p.DEBUG_LOADER || p.registerDebugLoader(x),
    x.importScript_(p.basePath + "deps.js"))
}
;var D = {
    IronResizableBehavior: {}
};
D.IronResizableBehavior.IronResizableBehavior = {};
Polymer.IronResizableBehavior = {
    properties: {
        _parentResizable: {
            type: Object,
            observer: "_parentResizableChanged"
        },
        _notifyingDescendant: {
            type: Boolean,
            value: !1
        }
    },
    listeners: {
        "iron-request-resize-notifications": "_onIronRequestResizeNotifications"
    },
    created: function() {
        this._interestedResizables = [];
        this._boundNotifyResize = this.notifyResize.bind(this)
    },
    attached: function() {
        this._requestResizeNotifications()
    },
    detached: function() {
        this._parentResizable ? this._parentResizable.stopResizeNotificationsFor(this) : window.removeEventListener("resize", this._boundNotifyResize);
        this._parentResizable = null
    },
    notifyResize: function() {
        this.isAttached && (this._interestedResizables.forEach(function(a) {
            this._notifyDescendant(a)
        }, this),
        this._fireResize())
    },
    assignParentResizable: function(a) {
        this._parentResizable = a
    },
    stopResizeNotificationsFor: function(a) {
        var b = this._interestedResizables.indexOf(a);
        -1 < b && (this._interestedResizables.splice(b, 1),
        this.unlisten(a, "iron-resize", "_onDescendantIronResize"))
    },
    resizerShouldNotify: function() {
        return !0
    },
    _onDescendantIronResize: function(a) {
        this._notifyingDescendant ? a.stopPropagation() : Polymer.Settings.useShadow || this._fireResize()
    },
    _fireResize: function() {
        this.fire("iron-resize", null, {
            node: this,
            bubbles: !1
        })
    },
    _onIronRequestResizeNotifications: function(a) {
        var b = Polymer.dom(a).rootTarget;
        b !== this && (-1 === this._interestedResizables.indexOf(b) && (this._interestedResizables.push(b),
        this.listen(b, "iron-resize", "_onDescendantIronResize")),
        b.assignParentResizable(this),
        this._notifyDescendant(b),
        a.stopPropagation())
    },
    _parentResizableChanged: function(a) {
        a && window.removeEventListener("resize", this._boundNotifyResize)
    },
    _notifyDescendant: function(a) {
        this.isAttached && (this._notifyingDescendant = !0,
        a.notifyResize(),
        this._notifyingDescendant = !1)
    },
    _requestResizeNotifications: function() {
        if (this.isAttached)
            if ("loading" === document.readyState) {
                var a = this._requestResizeNotifications.bind(this);
                document.addEventListener("readystatechange", function c() {
                    document.removeEventListener("readystatechange", c);
                    a()
                })
            } else
                this.fire("iron-request-resize-notifications", null, {
                    node: this,
                    bubbles: !0,
                    cancelable: !0
                }),
                this._parentResizable || (window.addEventListener("resize", this._boundNotifyResize),
                this.notifyResize())
    }
};
D.IronSelector = {};
D.IronSelector.IronSelection = {};
Polymer.IronSelection = function(a) {
    this.selection = [];
    this.selectCallback = a
}
;
Polymer.IronSelection.prototype = {
    get: function() {
        return this.multi ? this.selection.slice() : this.selection[0]
    },
    clear: function(a) {
        this.selection.slice().forEach(function(b) {
            (!a || 0 > a.indexOf(b)) && this.setItemSelected(b, !1)
        }, this)
    },
    isSelected: function(a) {
        return 0 <= this.selection.indexOf(a)
    },
    setItemSelected: function(a, b) {
        if (null != a && b !== this.isSelected(a)) {
            if (b)
                this.selection.push(a);
            else {
                var c = this.selection.indexOf(a);
                0 <= c && this.selection.splice(c, 1)
            }
            this.selectCallback && this.selectCallback(a, b)
        }
    },
    select: function(a) {
        this.multi ? this.toggle(a) : this.get() !== a && (this.setItemSelected(this.get(), !1),
        this.setItemSelected(a, !0))
    },
    toggle: function(a) {
        this.setItemSelected(a, !this.isSelected(a))
    }
};
D.IronSelector.IronSelectable = {};
Polymer.IronSelectableBehavior = {
    properties: {
        attrForSelected: {
            type: String,
            value: null
        },
        selected: {
            type: String,
            notify: !0
        },
        selectedItem: {
            type: Object,
            readOnly: !0,
            notify: !0
        },
        activateEvent: {
            type: String,
            value: "tap",
            observer: "_activateEventChanged"
        },
        selectable: String,
        selectedClass: {
            type: String,
            value: "iron-selected"
        },
        selectedAttribute: {
            type: String,
            value: null
        },
        fallbackSelection: {
            type: String,
            value: null
        },
        items: {
            type: Array,
            readOnly: !0,
            notify: !0,
            value: function() {
                return []
            }
        },
        _excludedLocalNames: {
            type: Object,
            value: function() {
                return {
                    template: 1,
                    "dom-bind": 1,
                    "dom-if": 1,
                    "dom-repeat": 1
                }
            }
        }
    },
    observers: ["_updateAttrForSelected(attrForSelected)", "_updateSelected(selected)", "_checkFallback(fallbackSelection)"],
    created: function() {
        this._bindFilterItem = this._filterItem.bind(this);
        this._selection = new Polymer.IronSelection(this._applySelection.bind(this))
    },
    attached: function() {
        this._observer = this._observeItems(this);
        this._addListener(this.activateEvent)
    },
    detached: function() {
        this._observer && Polymer.dom(this).unobserveNodes(this._observer);
        this._removeListener(this.activateEvent)
    },
    indexOf: function(a) {
        return this.items.indexOf(a)
    },
    select: function(a) {
        this.selected = a
    },
    selectPrevious: function() {
        var a = this.items.length;
        a = (Number(this._valueToIndex(this.selected)) - 1 + a) % a;
        this.selected = this._indexToValue(a)
    },
    selectNext: function() {
        var a = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
        this.selected = this._indexToValue(a)
    },
    selectIndex: function(a) {
        this.select(this._indexToValue(a))
    },
    forceSynchronousItemUpdate: function() {
        this._observer && "function" === typeof this._observer.flush ? this._observer.flush() : this._updateItems()
    },
    get _shouldUpdateSelection() {
        return null != this.selected
    },
    _checkFallback: function() {
        this._updateSelected()
    },
    _addListener: function(a) {
        this.listen(this, a, "_activateHandler")
    },
    _removeListener: function(a) {
        this.unlisten(this, a, "_activateHandler")
    },
    _activateEventChanged: function(a, b) {
        this._removeListener(b);
        this._addListener(a)
    },
    _updateItems: function() {
        var a = Polymer.dom(this).queryDistributedElements(this.selectable || "*");
        a = Array.prototype.filter.call(a, this._bindFilterItem);
        this._setItems(a)
    },
    _updateAttrForSelected: function() {
        this.selectedItem && (this.selected = this._valueForItem(this.selectedItem))
    },
    _updateSelected: function() {
        this._selectSelected(this.selected)
    },
    _selectSelected: function() {
        if (this.items) {
            var a = this._valueToItem(this.selected);
            a ? this._selection.select(a) : this._selection.clear();
            this.fallbackSelection && this.items.length && void 0 === this._selection.get() && (this.selected = this.fallbackSelection)
        }
    },
    _filterItem: function(a) {
        return !this._excludedLocalNames[a.localName]
    },
    _valueToItem: function(a) {
        return null == a ? null : this.items[this._valueToIndex(a)]
    },
    _valueToIndex: function(a) {
        if (this.attrForSelected)
            for (var b = 0, c; c = this.items[b]; b++) {
                if (this._valueForItem(c) == a)
                    return b
            }
        else
            return Number(a)
    },
    _indexToValue: function(a) {
        if (this.attrForSelected) {
            if (a = this.items[a])
                return this._valueForItem(a)
        } else
            return a
    },
    _valueForItem: function(a) {
        if (!a)
            return null;
        var b = a[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
        return void 0 != b ? b : a.getAttribute(this.attrForSelected)
    },
    _applySelection: function(a, b) {
        this.selectedClass && this.toggleClass(this.selectedClass, b, a);
        this.selectedAttribute && this.toggleAttribute(this.selectedAttribute, b, a);
        this._selectionChange();
        this.fire("iron-" + (b ? "select" : "deselect"), {
            item: a
        })
    },
    _selectionChange: function() {
        this._setSelectedItem(this._selection.get())
    },
    _observeItems: function(a) {
        return Polymer.dom(a).observeNodes(function(a) {
            this._updateItems();
            this._updateSelected();
            this.fire("iron-items-changed", a, {
                bubbles: !1,
                cancelable: !1
            })
        })
    },
    _activateHandler: function(a) {
        a = a.target;
        for (var b = this.items; a && a != this; ) {
            var c = b.indexOf(a);
            if (0 <= c) {
                b = this._indexToValue(c);
                this._itemActivate(b, a);
                break
            }
            a = a.parentNode
        }
    },
    _itemActivate: function(a, b) {
        this.fire("iron-activate", {
            selected: a,
            item: b
        }, {
            cancelable: !0
        }).defaultPrevented || this.select(a)
    }
};
D.IronPages = {};
D.IronPages.IronPages = {};
Polymer({
    is: "iron-pages",
    behaviors: [Polymer.IronResizableBehavior, Polymer.IronSelectableBehavior],
    properties: {
        activateEvent: {
            type: String,
            value: null
        }
    },
    observers: ["_selectedPageChanged(selected)"],
    _selectedPageChanged: function() {
        this.async(this.notifyResize)
    }
});
D.IronFlexLayout = {};
D.IronFlexLayout.IronFlexLayout = {};
D.IronImage = {};
D.IronImage.IronImage = {};
Polymer({
    is: "iron-image",
    properties: {
        src: {
            observer: "_srcChanged",
            type: String,
            value: ""
        },
        alt: {
            type: String,
            value: null
        },
        preventLoad: {
            type: Boolean,
            value: !1,
            observer: "_preventLoadChanged"
        },
        sizing: {
            type: String,
            value: null,
            reflectToAttribute: !0
        },
        position: {
            type: String,
            value: "center"
        },
        preload: {
            type: Boolean,
            value: !1
        },
        placeholder: {
            type: String,
            value: null,
            observer: "_placeholderChanged"
        },
        fade: {
            type: Boolean,
            value: !1
        },
        loaded: {
            notify: !0,
            readOnly: !0,
            type: Boolean,
            value: !1
        },
        loading: {
            notify: !0,
            readOnly: !0,
            type: Boolean,
            value: !1
        },
        error: {
            notify: !0,
            readOnly: !0,
            type: Boolean,
            value: !1
        },
        width: {
            observer: "_widthChanged",
            type: Number,
            value: null
        },
        height: {
            observer: "_heightChanged",
            type: Number,
            value: null
        }
    },
    observers: ["_transformChanged(sizing, position)"],
    ready: function() {
        var a = this.$.img;
        a.onload = function() {
            this.$.img.src === this._resolveSrc(this.src) && (this._setLoading(!1),
            this._setLoaded(!0),
            this._setError(!1))
        }
        .bind(this);
        a.onerror = function() {
            this.$.img.src === this._resolveSrc(this.src) && (this._reset(),
            this._setLoading(!1),
            this._setLoaded(!1),
            this._setError(!0))
        }
        .bind(this);
        this._resolvedSrc = ""
    },
    _load: function(a) {
        a ? this.$.img.src = a : this.$.img.removeAttribute("src");
        this.$.sizedImgDiv.style.backgroundImage = a ? 'url("' + a + '")' : "";
        this._setLoading(!!a);
        this._setLoaded(!1);
        this._setError(!1)
    },
    _reset: function() {
        this.$.img.removeAttribute("src");
        this.$.sizedImgDiv.style.backgroundImage = "";
        this._setLoading(!1);
        this._setLoaded(!1);
        this._setError(!1)
    },
    _computePlaceholderHidden: function() {
        return !this.preload || !this.fade && !this.loading && this.loaded
    },
    _computePlaceholderClassName: function() {
        return this.preload && this.fade && !this.loading && this.loaded ? "faded-out" : ""
    },
    _computeImgDivHidden: function() {
        return !this.sizing
    },
    _computeImgDivARIAHidden: function() {
        return "" === this.alt ? "true" : void 0
    },
    _computeImgDivARIALabel: function() {
        if (null !== this.alt)
            return this.alt;
        if ("" === this.src)
            return "";
        var a = (new URL(this._resolveSrc(this.src))).pathname.split("/");
        return a[a.length - 1]
    },
    _computeImgHidden: function() {
        return !!this.sizing
    },
    _widthChanged: function() {
        this.style.width = isNaN(this.width) ? this.width : this.width + "px"
    },
    _heightChanged: function() {
        this.style.height = isNaN(this.height) ? this.height : this.height + "px"
    },
    _preventLoadChanged: function() {
        this.preventLoad || this.loaded || (this._reset(),
        this._load(this.src))
    },
    _srcChanged: function(a) {
        var b = this._resolveSrc(a);
        b !== this._resolvedSrc && (this._resolvedSrc = b,
        this._reset(),
        this.preventLoad || this._load(a))
    },
    _placeholderChanged: function() {
        this.$.placeholder.style.backgroundImage = this.placeholder ? 'url("' + this.placeholder + '")' : ""
    },
    _transformChanged: function() {
        var a = this.$.sizedImgDiv.style
          , b = this.$.placeholder.style;
        a.backgroundSize = b.backgroundSize = this.sizing;
        a.backgroundPosition = b.backgroundPosition = this.sizing ? this.position : "";
        a.backgroundRepeat = b.backgroundRepeat = this.sizing ? "no-repeat" : ""
    },
    _resolveSrc: function(a) {
        var b = this.ownerDocument.baseURI;
        return b ? (new URL(a,b)).href : a
    }
});
D.PaperStyles = {};
D.PaperStyles.Color = {};
D.PaperStyles.DefaultTheme = {};
D.PaperStyles.Shadow = {};
D.PaperMaterial = {};
D.PaperMaterial.PaperMaterialSharedStyles = {};
D.PaperMaterial.PaperMaterial = {};
Polymer({
    is: "paper-material",
    properties: {
        elevation: {
            type: Number,
            reflectToAttribute: !0,
            value: 1
        },
        animated: {
            type: Boolean,
            reflectToAttribute: !0,
            value: !1
        }
    }
});
D.PaperCard = {};
D.PaperCard.PaperCard = {};
Polymer({
    is: "paper-card",
    properties: {
        heading: {
            type: String,
            value: "",
            observer: "_headingChanged"
        },
        image: {
            type: String,
            value: ""
        },
        alt: {
            type: String
        },
        preloadImage: {
            type: Boolean,
            value: !1
        },
        fadeImage: {
            type: Boolean,
            value: !1
        },
        placeholderImage: {
            type: String,
            value: null
        },
        elevation: {
            type: Number,
            value: 1,
            reflectToAttribute: !0
        },
        animatedShadow: {
            type: Boolean,
            value: !1
        },
        animated: {
            type: Boolean,
            reflectToAttribute: !0,
            readOnly: !0,
            computed: "_computeAnimated(animatedShadow)"
        }
    },
    _isHidden: function(a) {
        return a ? "false" : "true"
    },
    _headingChanged: function(a) {
        this.getAttribute("aria-label");
        this.setAttribute("aria-label", a)
    },
    _computeHeadingClass: function(a) {
        return a ? " over-image" : ""
    },
    _computeAnimated: function(a) {
        return a
    }
});
D.IronA11yKeysBehavior = {};
D.IronA11yKeysBehavior.IronA11yKeysBehavior = {};
(function() {
    function a(a, b) {
        var d = "";
        if (a)
            if (a = a.toLowerCase(),
            " " === a || r.test(a))
                d = "space";
            else if (t.test(a))
                d = "esc";
            else if (1 == a.length) {
                if (!b || h.test(a))
                    d = a
            } else
                d = m.test(a) ? a.replace("arrow", "") : "multiply" == a ? "*" : a;
        return d
    }
    function b(b, d) {
        var c = d;
        var h = b.hasModifiers;
        if (c.key)
            c = a(c.key, h);
        else if (c.detail && c.detail.key)
            c = a(c.detail.key, h);
        else {
            h = c.keyIdentifier;
            var m = "";
            h && (h in e ? m = e[h] : k.test(h) ? (h = parseInt(h.replace("U+", "0x"), 16),
            m = String.fromCharCode(h).toLowerCase()) : m = h.toLowerCase());
            h = m;
            h || (c = c.keyCode,
            h = "",
            Number(c) && (h = 65 <= c && 90 >= c ? String.fromCharCode(32 + c) : 112 <= c && 123 >= c ? "f" + (c - 112) : 48 <= c && 57 >= c ? String(c - 48) : 96 <= c && 105 >= c ? String(c - 96) : f[c]));
            c = h || ""
        }
        return c === b.key && (!b.hasModifiers || !!d.shiftKey === !!b.shiftKey && !!d.ctrlKey === !!b.ctrlKey && !!d.altKey === !!b.altKey && !!d.metaKey === !!b.metaKey)
    }
    function c(a) {
        return 1 === a.length ? {
            combo: a,
            key: a,
            event: "keydown"
        } : a.split("+").reduce(function(a, b) {
            var d = b.split(":");
            b = d[0];
            d = d[1];
            b in l ? (a[l[b]] = !0,
            a.hasModifiers = !0) : (a.key = b,
            a.event = d || "keydown");
            return a
        }, {
            combo: a.split(":").shift()
        })
    }
    function d(a) {
        return a.trim().split(" ").map(function(a) {
            return c(a)
        })
    }
    var e = {
        "U+0008": "backspace",
        "U+0009": "tab",
        "U+001B": "esc",
        "U+0020": "space",
        "U+007F": "del"
    }
      , f = {
        8: "backspace",
        9: "tab",
        13: "enter",
        27: "esc",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        32: "space",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        46: "del",
        106: "*"
    }
      , l = {
        shift: "shiftKey",
        ctrl: "ctrlKey",
        alt: "altKey",
        meta: "metaKey"
    }
      , h = /[a-z0-9*]/
      , k = /U\+/
      , m = /^arrow/
      , r = /^space(bar)?/
      , t = /^escape$/;
    Polymer.IronA11yKeysBehavior = {
        properties: {
            keyEventTarget: {
                type: Object,
                value: function() {
                    return this
                }
            },
            stopKeyboardEventPropagation: {
                type: Boolean,
                value: !1
            },
            _boundKeyHandlers: {
                type: Array,
                value: function() {
                    return []
                }
            },
            _imperativeKeyBindings: {
                type: Object,
                value: function() {
                    return {}
                }
            }
        },
        observers: ["_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)"],
        keyBindings: {},
        registered: function() {
            this._prepKeyBindings()
        },
        attached: function() {
            this._listenKeyEventListeners()
        },
        detached: function() {
            this._unlistenKeyEventListeners()
        },
        addOwnKeyBinding: function(a, b) {
            this._imperativeKeyBindings[a] = b;
            this._prepKeyBindings();
            this._resetKeyEventListeners()
        },
        removeOwnKeyBindings: function() {
            this._imperativeKeyBindings = {};
            this._prepKeyBindings();
            this._resetKeyEventListeners()
        },
        keyboardEventMatchesKeys: function(a, c) {
            c = d(c);
            for (var e = 0; e < c.length; ++e)
                if (b(c[e], a))
                    return !0;
            return !1
        },
        _collectKeyBindings: function() {
            var a = this.behaviors.map(function(a) {
                return a.keyBindings
            });
            -1 === a.indexOf(this.keyBindings) && a.push(this.keyBindings);
            return a
        },
        _prepKeyBindings: function() {
            this._keyBindings = {};
            this._collectKeyBindings().forEach(function(a) {
                for (var b in a)
                    this._addKeyBinding(b, a[b])
            }, this);
            for (var a in this._imperativeKeyBindings)
                this._addKeyBinding(a, this._imperativeKeyBindings[a]);
            for (var b in this._keyBindings)
                this._keyBindings[b].sort(function(a, b) {
                    a = a[0].hasModifiers;
                    b = b[0].hasModifiers;
                    return a === b ? 0 : a ? -1 : 1
                })
        },
        _addKeyBinding: function(a, b) {
            d(a).forEach(function(a) {
                this._keyBindings[a.event] = this._keyBindings[a.event] || [];
                this._keyBindings[a.event].push([a, b])
            }, this)
        },
        _resetKeyEventListeners: function() {
            this._unlistenKeyEventListeners();
            this.isAttached && this._listenKeyEventListeners()
        },
        _listenKeyEventListeners: function() {
            this.keyEventTarget && Object.keys(this._keyBindings).forEach(function(a) {
                var b = this._keyBindings[a];
                b = this._onKeyBindingEvent.bind(this, b);
                this._boundKeyHandlers.push([this.keyEventTarget, a, b]);
                this.keyEventTarget.addEventListener(a, b)
            }, this)
        },
        _unlistenKeyEventListeners: function() {
            for (var a, b, d; this._boundKeyHandlers.length; )
                a = this._boundKeyHandlers.pop(),
                b = a[0],
                d = a[1],
                a = a[2],
                b.removeEventListener(d, a)
        },
        _onKeyBindingEvent: function(a, d) {
            this.stopKeyboardEventPropagation && d.stopPropagation();
            if (!d.defaultPrevented)
                for (var c = 0; c < a.length; c++) {
                    var e = a[c][0]
                      , h = a[c][1];
                    if (b(e, d) && (this._triggerKeyHandler(e, h, d),
                    d.defaultPrevented))
                        break
                }
        },
        _triggerKeyHandler: function(a, b, d) {
            var c = Object.create(a);
            c.keyboardEvent = d;
            a = new CustomEvent(a.event,{
                detail: c,
                cancelable: !0
            });
            this[b].call(this, a);
            a.defaultPrevented && d.preventDefault()
        }
    }
}
)();
D.IronBehaviors = {};
D.IronBehaviors.IronControlState = {};
Polymer.IronControlState = {
    properties: {
        focused: {
            type: Boolean,
            value: !1,
            notify: !0,
            readOnly: !0,
            reflectToAttribute: !0
        },
        disabled: {
            type: Boolean,
            value: !1,
            notify: !0,
            observer: "_disabledChanged",
            reflectToAttribute: !0
        },
        _oldTabIndex: {
            type: Number
        },
        _boundFocusBlurHandler: {
            type: Function,
            value: function() {
                return this._focusBlurHandler.bind(this)
            }
        },
        __handleEventRetargeting: {
            type: Boolean,
            value: function() {
                return !this.shadowRoot && !Polymer.Element
            }
        }
    },
    observers: ["_changedControlState(focused, disabled)"],
    ready: function() {
        this.addEventListener("focus", this._boundFocusBlurHandler, !0);
        this.addEventListener("blur", this._boundFocusBlurHandler, !0)
    },
    _focusBlurHandler: function(a) {
        if (Polymer.Element)
            this._setFocused("focus" === a.type);
        else if (a.target === this)
            this._setFocused("focus" === a.type);
        else if (this.__handleEventRetargeting) {
            var b = Polymer.dom(a).localTarget;
            this.isLightDescendant(b) || this.fire(a.type, {
                sourceEvent: a
            }, {
                node: this,
                bubbles: a.bubbles,
                cancelable: a.cancelable
            })
        }
    },
    _disabledChanged: function(a) {
        this.setAttribute("aria-disabled", a ? "true" : "false");
        this.style.pointerEvents = a ? "none" : "";
        a ? (this._oldTabIndex = this.tabIndex,
        this._setFocused(!1),
        this.tabIndex = -1,
        this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
    },
    _changedControlState: function() {
        this._controlStateChanged && this._controlStateChanged()
    }
};
D.IronBehaviors.IronButtonState = {};
Polymer.IronButtonStateImpl = {
    properties: {
        pressed: {
            type: Boolean,
            readOnly: !0,
            value: !1,
            reflectToAttribute: !0,
            observer: "_pressedChanged"
        },
        toggles: {
            type: Boolean,
            value: !1,
            reflectToAttribute: !0
        },
        active: {
            type: Boolean,
            value: !1,
            notify: !0,
            reflectToAttribute: !0
        },
        pointerDown: {
            type: Boolean,
            readOnly: !0,
            value: !1
        },
        receivedFocusFromKeyboard: {
            type: Boolean,
            readOnly: !0
        },
        ariaActiveAttribute: {
            type: String,
            value: "aria-pressed",
            observer: "_ariaActiveAttributeChanged"
        }
    },
    listeners: {
        down: "_downHandler",
        up: "_upHandler",
        tap: "_tapHandler"
    },
    observers: ["_focusChanged(focused)", "_activeChanged(active, ariaActiveAttribute)"],
    keyBindings: {
        "enter:keydown": "_asyncClick",
        "space:keydown": "_spaceKeyDownHandler",
        "space:keyup": "_spaceKeyUpHandler"
    },
    _mouseEventRe: /^mouse/,
    _tapHandler: function() {
        this.toggles ? this._userActivate(!this.active) : this.active = !1
    },
    _focusChanged: function(a) {
        this._detectKeyboardFocus(a);
        a || this._setPressed(!1)
    },
    _detectKeyboardFocus: function(a) {
        this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
    },
    _userActivate: function(a) {
        this.active !== a && (this.active = a,
        this.fire("change"))
    },
    _downHandler: function() {
        this._setPointerDown(!0);
        this._setPressed(!0);
        this._setReceivedFocusFromKeyboard(!1)
    },
    _upHandler: function() {
        this._setPointerDown(!1);
        this._setPressed(!1)
    },
    _spaceKeyDownHandler: function(a) {
        a = a.detail.keyboardEvent;
        var b = Polymer.dom(a).localTarget;
        this.isLightDescendant(b) || (a.preventDefault(),
        a.stopImmediatePropagation(),
        this._setPressed(!0))
    },
    _spaceKeyUpHandler: function(a) {
        a = a.detail.keyboardEvent;
        a = Polymer.dom(a).localTarget;
        this.isLightDescendant(a) || (this.pressed && this._asyncClick(),
        this._setPressed(!1))
    },
    _asyncClick: function() {
        this.async(function() {
            this.click()
        }, 1)
    },
    _pressedChanged: function() {
        this._changedButtonState()
    },
    _ariaActiveAttributeChanged: function(a, b) {
        b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
    },
    _activeChanged: function(a) {
        this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
        this._changedButtonState()
    },
    _controlStateChanged: function() {
        this.disabled ? this._setPressed(!1) : this._changedButtonState()
    },
    _changedButtonState: function() {
        this._buttonStateChanged && this._buttonStateChanged()
    }
};
Polymer.IronButtonState = [Polymer.IronA11yKeysBehavior, Polymer.IronButtonStateImpl];
D.PaperRipple = {};
D.PaperRipple.PaperRipple = {};
(function() {
    function a(a) {
        this.element = a;
        this.width = this.boundingRect.width;
        this.height = this.boundingRect.height;
        this.size = Math.max(this.width, this.height)
    }
    function b(a) {
        this.element = a;
        this.color = window.getComputedStyle(a).color;
        this.wave = document.createElement("div");
        this.waveContainer = document.createElement("div");
        this.wave.style.backgroundColor = this.color;
        this.wave.classList.add("wave");
        this.waveContainer.classList.add("wave-container");
        Polymer.dom(this.waveContainer).appendChild(this.wave);
        this.resetInteractionState()
    }
    var c = {
        distance: function(a, b, c, l) {
            a -= c;
            b -= l;
            return Math.sqrt(a * a + b * b)
        },
        now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
    };
    a.prototype = {
        get boundingRect() {
            return this.element.getBoundingClientRect()
        },
        furthestCornerDistanceFrom: function(a, b) {
            var d = c.distance(a, b, 0, 0)
              , e = c.distance(a, b, this.width, 0)
              , h = c.distance(a, b, 0, this.height);
            a = c.distance(a, b, this.width, this.height);
            return Math.max(d, e, h, a)
        }
    };
    b.MAX_RADIUS = 300;
    b.prototype = {
        get recenters() {
            return this.element.recenters
        },
        get center() {
            return this.element.center
        },
        get mouseDownElapsed() {
            if (!this.mouseDownStart)
                return 0;
            var a = c.now() - this.mouseDownStart;
            this.mouseUpStart && (a -= this.mouseUpElapsed);
            return a
        },
        get mouseUpElapsed() {
            return this.mouseUpStart ? c.now() - this.mouseUpStart : 0
        },
        get mouseDownElapsedSeconds() {
            return this.mouseDownElapsed / 1E3
        },
        get mouseUpElapsedSeconds() {
            return this.mouseUpElapsed / 1E3
        },
        get mouseInteractionSeconds() {
            return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds
        },
        get initialOpacity() {
            return this.element.initialOpacity
        },
        get opacityDecayVelocity() {
            return this.element.opacityDecayVelocity
        },
        get radius() {
            var a = this.containerMetrics.width * this.containerMetrics.width
              , c = this.containerMetrics.height * this.containerMetrics.height;
            a = 1.1 * Math.min(Math.sqrt(a + c), b.MAX_RADIUS) + 5;
            c = 1.1 - a / b.MAX_RADIUS * .2;
            c = this.mouseInteractionSeconds / c;
            a *= 1 - Math.pow(80, -c);
            return Math.abs(a)
        },
        get opacity() {
            return this.mouseUpStart ? Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity) : this.initialOpacity
        },
        get outerOpacity() {
            var a = .3 * this.mouseUpElapsedSeconds
              , b = this.opacity;
            return Math.max(0, Math.min(a, b))
        },
        get isOpacityFullyDecayed() {
            return .01 > this.opacity && this.radius >= Math.min(this.maxRadius, b.MAX_RADIUS)
        },
        get isRestingAtMaxRadius() {
            return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, b.MAX_RADIUS)
        },
        get isAnimationComplete() {
            return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius
        },
        get translationFraction() {
            return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2))
        },
        get xNow() {
            return this.xEnd ? this.xStart + this.translationFraction * (this.xEnd - this.xStart) : this.xStart
        },
        get yNow() {
            return this.yEnd ? this.yStart + this.translationFraction * (this.yEnd - this.yStart) : this.yStart
        },
        get isMouseDown() {
            return this.mouseDownStart && !this.mouseUpStart
        },
        resetInteractionState: function() {
            this.yEnd = this.xEnd = this.yStart = this.xStart = this.mouseUpStart = this.mouseDownStart = this.maxRadius = 0;
            this.containerMetrics = new a(this.element)
        },
        draw: function() {
            this.wave.style.opacity = this.opacity;
            var a = this.radius / (this.containerMetrics.size / 2);
            var b = this.xNow - this.containerMetrics.width / 2;
            var c = this.yNow - this.containerMetrics.height / 2;
            this.waveContainer.style.webkitTransform = "translate(" + b + "px, " + c + "px)";
            this.waveContainer.style.transform = "translate3d(" + b + "px, " + c + "px, 0)";
            this.wave.style.webkitTransform = "scale(" + a + "," + a + ")";
            this.wave.style.transform = "scale3d(" + a + "," + a + ",1)"
        },
        downAction: function(a) {
            var b = this.containerMetrics.width / 2
              , d = this.containerMetrics.height / 2;
            this.resetInteractionState();
            this.mouseDownStart = c.now();
            this.center ? (this.xStart = b,
            this.yStart = d) : (this.xStart = a ? a.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2,
            this.yStart = a ? a.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2);
            this.recenters && (this.xEnd = b,
            this.yEnd = d);
            this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart, this.yStart);
            this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + "px";
            this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + "px";
            this.waveContainer.style.width = this.containerMetrics.size + "px";
            this.waveContainer.style.height = this.containerMetrics.size + "px"
        },
        upAction: function() {
            this.isMouseDown && (this.mouseUpStart = c.now())
        },
        remove: function() {
            Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer)
        }
    };
    Polymer({
        is: "paper-ripple",
        behaviors: [Polymer.IronA11yKeysBehavior],
        properties: {
            initialOpacity: {
                type: Number,
                value: .25
            },
            opacityDecayVelocity: {
                type: Number,
                value: .8
            },
            recenters: {
                type: Boolean,
                value: !1
            },
            center: {
                type: Boolean,
                value: !1
            },
            ripples: {
                type: Array,
                value: function() {
                    return []
                }
            },
            animating: {
                type: Boolean,
                readOnly: !0,
                reflectToAttribute: !0,
                value: !1
            },
            holdDown: {
                type: Boolean,
                value: !1,
                observer: "_holdDownChanged"
            },
            noink: {
                type: Boolean,
                value: !1
            },
            _animating: {
                type: Boolean
            },
            _boundAnimate: {
                type: Function,
                value: function() {
                    return this.animate.bind(this)
                }
            }
        },
        get target() {
            return this.keyEventTarget
        },
        keyBindings: {
            "enter:keydown": "_onEnterKeydown",
            "space:keydown": "_onSpaceKeydown",
            "space:keyup": "_onSpaceKeyup"
        },
        attached: function() {
            var a = this.keyEventTarget = 11 == this.parentNode.nodeType ? Polymer.dom(this).getOwnerRoot().host : this.parentNode;
            this.listen(a, "up", "uiUpAction");
            this.listen(a, "down", "uiDownAction")
        },
        detached: function() {
            this.unlisten(this.keyEventTarget, "up", "uiUpAction");
            this.unlisten(this.keyEventTarget, "down", "uiDownAction");
            this.keyEventTarget = null
        },
        get shouldKeepAnimating() {
            for (var a = 0; a < this.ripples.length; ++a)
                if (!this.ripples[a].isAnimationComplete)
                    return !0;
            return !1
        },
        simulatedRipple: function() {
            this.downAction(null);
            this.async(function() {
                this.upAction()
            }, 1)
        },
        uiDownAction: function(a) {
            this.noink || this.downAction(a)
        },
        downAction: function(a) {
            if (!(this.holdDown && 0 < this.ripples.length)) {
                var b = this.addRipple();
                b.downAction(a);
                this._animating || (this._animating = !0,
                this.animate())
            }
        },
        uiUpAction: function(a) {
            this.noink || this.upAction(a)
        },
        upAction: function(a) {
            this.holdDown || (this.ripples.forEach(function(b) {
                b.upAction(a)
            }),
            this._animating = !0,
            this.animate())
        },
        onAnimationComplete: function() {
            this._animating = !1;
            this.$.background.style.backgroundColor = null;
            this.fire("transitionend")
        },
        addRipple: function() {
            var a = new b(this);
            Polymer.dom(this.$.waves).appendChild(a.waveContainer);
            this.$.background.style.backgroundColor = a.color;
            this.ripples.push(a);
            this._setAnimating(!0);
            return a
        },
        removeRipple: function(a) {
            var b = this.ripples.indexOf(a);
            0 > b || (this.ripples.splice(b, 1),
            a.remove(),
            this.ripples.length || this._setAnimating(!1))
        },
        animate: function() {
            if (this._animating) {
                var a;
                for (a = 0; a < this.ripples.length; ++a) {
                    var b = this.ripples[a];
                    b.draw();
                    this.$.background.style.opacity = b.outerOpacity;
                    b.isOpacityFullyDecayed && !b.isRestingAtMaxRadius && this.removeRipple(b)
                }
                if (this.shouldKeepAnimating || 0 !== this.ripples.length)
                    window.requestAnimationFrame(this._boundAnimate);
                else
                    this.onAnimationComplete()
            }
        },
        _onEnterKeydown: function() {
            this.uiDownAction();
            this.async(this.uiUpAction, 1)
        },
        _onSpaceKeydown: function() {
            this.uiDownAction()
        },
        _onSpaceKeyup: function() {
            this.uiUpAction()
        },
        _holdDownChanged: function(a, b) {
            void 0 !== b && (a ? this.downAction() : this.upAction())
        }
    })
}
)();
D.PaperBehaviors = {};
D.PaperBehaviors.PaperRippleBehavior = {};
Polymer.PaperRippleBehavior = {
    properties: {
        noink: {
            type: Boolean,
            observer: "_noinkChanged"
        },
        _rippleContainer: {
            type: Object
        }
    },
    _buttonStateChanged: function() {
        this.focused && this.ensureRipple()
    },
    _downHandler: function(a) {
        Polymer.IronButtonStateImpl._downHandler.call(this, a);
        this.pressed && this.ensureRipple(a)
    },
    ensureRipple: function(a) {
        if (!this.hasRipple()) {
            this._ripple = this._createRipple();
            this._ripple.noink = this.noink;
            var b = this._rippleContainer || this.root;
            b && Polymer.dom(b).appendChild(this._ripple);
            if (a) {
                b = Polymer.dom(this._rippleContainer || this);
                var c = Polymer.dom(a).rootTarget;
                b.deepContains(c) && this._ripple.uiDownAction(a)
            }
        }
    },
    getRipple: function() {
        this.ensureRipple();
        return this._ripple
    },
    hasRipple: function() {
        return !!this._ripple
    },
    _createRipple: function() {
        return document.createElement("paper-ripple")
    },
    _noinkChanged: function(a) {
        this.hasRipple() && (this._ripple.noink = a)
    }
};
D.PaperBehaviors.PaperButtonBehavior = {};
Polymer.PaperButtonBehaviorImpl = {
    properties: {
        elevation: {
            type: Number,
            reflectToAttribute: !0,
            readOnly: !0
        }
    },
    observers: ["_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)", "_computeKeyboardClass(receivedFocusFromKeyboard)"],
    hostAttributes: {
        role: "button",
        tabindex: "0",
        animated: !0
    },
    _calculateElevation: function() {
        var a = 1;
        this.disabled ? a = 0 : this.active || this.pressed ? a = 4 : this.receivedFocusFromKeyboard && (a = 3);
        this._setElevation(a)
    },
    _computeKeyboardClass: function(a) {
        this.toggleClass("keyboard-focus", a)
    },
    _spaceKeyDownHandler: function(a) {
        Polymer.IronButtonStateImpl._spaceKeyDownHandler.call(this, a);
        this.hasRipple() && 1 > this.getRipple().ripples.length && this._ripple.uiDownAction()
    },
    _spaceKeyUpHandler: function(a) {
        Polymer.IronButtonStateImpl._spaceKeyUpHandler.call(this, a);
        this.hasRipple() && this._ripple.uiUpAction()
    }
};
Polymer.PaperButtonBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperButtonBehaviorImpl];
D.PaperButton = {};
D.PaperButton.PaperButton = {};
Polymer({
    is: "paper-button",
    behaviors: [Polymer.PaperButtonBehavior],
    properties: {
        raised: {
            type: Boolean,
            reflectToAttribute: !0,
            value: !1,
            observer: "_calculateElevation"
        }
    },
    _calculateElevation: function() {
        this.raised ? Polymer.PaperButtonBehaviorImpl._calculateElevation.apply(this) : this._setElevation(0)
    }
});
D.FontRoboto = {};
D.FontRoboto.Roboto = {};
D.IronFlexLayout.Classes = {};
D.IronFlexLayout.Classes.IronShadowFlexLayout = {};
console.warn("This file is deprecated. Please use `iron-flex-layout/iron-flex-layout-classes.html`, and one of the specific dom-modules instead");
D.IronFlexLayout.Classes.IronFlexLayout = {};
console.warn("This file is deprecated. Please use `iron-flex-layout/iron-flex-layout-classes.html`, and one of the specific dom-modules instead");
D.PaperStyles.Classes = {};
D.PaperStyles.Classes.Shadow = {};
D.PaperStyles.Classes.Typography = {};
D.PaperStyles.PaperStylesClasses = {};
D.PaperStyles.Classes.Global = {};
D.PaperStyles.Typography = {};
D.PaperStyles.DemoPages = {};
D.PaperStyles.ElementStyles = {};
D.PaperStyles.ElementStyles.PaperItemStyles = {};
D.PaperStyles.ElementStyles.PaperMaterialStyles = {};
D.PaperStyles.PaperStyles = {};
D.IronMeta = {};
D.IronMeta.IronMeta = {};
(function() {
    var a = {}
      , b = {}
      , c = null;
    Polymer.IronMeta = function(a) {
        if (a)
            for (var b in a)
                switch (b) {
                case "type":
                case "key":
                case "value":
                    this[b] = a[b]
                }
    }
    ;
    Polymer.IronMeta = Polymer({
        is: "iron-meta",
        properties: {
            type: {
                type: String,
                value: "default",
                observer: "_typeChanged"
            },
            key: {
                type: String,
                observer: "_keyChanged"
            },
            value: {
                type: Object,
                notify: !0,
                observer: "_valueChanged"
            },
            self: {
                type: Boolean,
                observer: "_selfChanged"
            },
            list: {
                type: Array,
                notify: !0
            }
        },
        hostAttributes: {
            hidden: !0
        },
        factoryImpl: function(a) {
            if (a)
                for (var b in a)
                    switch (b) {
                    case "type":
                    case "key":
                    case "value":
                        this[b] = a[b]
                    }
        },
        created: function() {
            this._metaDatas = a;
            this._metaArrays = b
        },
        _keyChanged: function(a, b) {
            this._resetRegistration(b)
        },
        _valueChanged: function() {
            this._resetRegistration(this.key)
        },
        _selfChanged: function(a) {
            a && (this.value = this)
        },
        _typeChanged: function(c) {
            this._unregisterKey(this.key);
            a[c] || (a[c] = {});
            this._metaData = a[c];
            b[c] || (b[c] = []);
            this.list = b[c];
            this._registerKeyValue(this.key, this.value)
        },
        byKey: function(a) {
            return this._metaData && this._metaData[a]
        },
        _resetRegistration: function(a) {
            this._unregisterKey(a);
            this._registerKeyValue(this.key, this.value)
        },
        _unregisterKey: function(a) {
            this._unregister(a, this._metaData, this.list)
        },
        _registerKeyValue: function(a, b) {
            this._register(a, b, this._metaData, this.list)
        },
        _register: function(a, b, c, l) {
            a && c && void 0 !== b && (c[a] = b,
            l.push(b))
        },
        _unregister: function(a, b, c) {
            if (a && b && a in b) {
                var d = b[a];
                delete b[a];
                this.arrayDelete(c, d)
            }
        }
    });
    Polymer.IronMeta.getIronMeta = function() {
        null === c && (c = new Polymer.IronMeta);
        return c
    }
    ;
    Polymer.IronMetaQuery = function(a) {
        if (a)
            for (var b in a)
                switch (b) {
                case "type":
                case "key":
                    this[b] = a[b]
                }
    }
    ;
    Polymer.IronMetaQuery.prototype._setValue = function() {}
    ;
    Polymer.IronMetaQuery = Polymer({
        is: "iron-meta-query",
        properties: {
            type: {
                type: String,
                value: "default",
                observer: "_typeChanged"
            },
            key: {
                type: String,
                observer: "_keyChanged"
            },
            value: {
                type: Object,
                notify: !0,
                readOnly: !0
            },
            list: {
                type: Array,
                notify: !0
            }
        },
        factoryImpl: function(a) {
            if (a)
                for (var b in a)
                    switch (b) {
                    case "type":
                    case "key":
                        this[b] = a[b]
                    }
        },
        created: function() {
            this._metaDatas = a;
            this._metaArrays = b
        },
        _keyChanged: function(a) {
            this._setValue(this._metaData && this._metaData[a])
        },
        _typeChanged: function(c) {
            this._metaData = a[c];
            this.list = b[c];
            this.key && this._keyChanged(this.key)
        },
        byKey: function(a) {
            return this._metaData && this._metaData[a]
        }
    })
}
)();
D.IronIcon = {};
D.IronIcon.IronIcon = {};
Polymer({
    is: "iron-icon",
    properties: {
        icon: {
            type: String
        },
        theme: {
            type: String
        },
        src: {
            type: String
        },
        _meta: {
            value: Polymer.Base.create("iron-meta", {
                type: "iconset"
            })
        }
    },
    observers: ["_updateIcon(_meta, isAttached)", "_updateIcon(theme, isAttached)", "_srcChanged(src, isAttached)", "_iconChanged(icon, isAttached)"],
    _DEFAULT_ICONSET: "icons",
    _iconChanged: function(a) {
        a = (a || "").split(":");
        this._iconName = a.pop();
        this._iconsetName = a.pop() || this._DEFAULT_ICONSET;
        this._updateIcon()
    },
    _srcChanged: function() {
        this._updateIcon()
    },
    _usesIconset: function() {
        return this.icon || !this.src
    },
    _updateIcon: function() {
        this._usesIconset() ? (this._img && this._img.parentNode && Polymer.dom(this.root).removeChild(this._img),
        "" === this._iconName ? this._iconset && this._iconset.removeIcon(this) : this._iconsetName && this._meta && ((this._iconset = this._meta.byKey(this._iconsetName)) ? (this._iconset.applyIcon(this, this._iconName, this.theme),
        this.unlisten(window, "iron-iconset-added", "_updateIcon")) : this.listen(window, "iron-iconset-added", "_updateIcon"))) : (this._iconset && this._iconset.removeIcon(this),
        this._img || (this._img = document.createElement("img"),
        this._img.style.width = "100%",
        this._img.style.height = "100%",
        this._img.draggable = !1),
        this._img.src = this.src,
        Polymer.dom(this.root).appendChild(this._img))
    }
});
D.IronIconsetSvg = {};
D.IronIconsetSvg.IronIconsetSvg = {};
Polymer({
    is: "iron-iconset-svg",
    properties: {
        name: {
            type: String,
            observer: "_nameChanged"
        },
        size: {
            type: Number,
            value: 24
        },
        rtlMirroring: {
            type: Boolean,
            value: !1
        },
        useGlobalRtlAttribute: {
            type: Boolean,
            value: !1
        }
    },
    created: function() {
        this._meta = new Polymer.IronMeta({
            type: "iconset",
            key: null,
            value: null
        })
    },
    attached: function() {
        this.style.display = "none"
    },
    getIconNames: function() {
        this._icons = this._createIconMap();
        return Object.keys(this._icons).map(function(a) {
            return this.name + ":" + a
        }, this)
    },
    applyIcon: function(a, b) {
        this.removeIcon(a);
        if (b = this._cloneIcon(b, this.rtlMirroring && this._targetIsRTL(a))) {
            var c = Polymer.dom(a.root || a);
            c.insertBefore(b, c.childNodes[0]);
            return a._svgIcon = b
        }
        return null
    },
    removeIcon: function(a) {
        a._svgIcon && (Polymer.dom(a.root || a).removeChild(a._svgIcon),
        a._svgIcon = null)
    },
    _targetIsRTL: function(a) {
        null == this.__targetIsRTL && (this.useGlobalRtlAttribute ? (a = document.body && document.body.hasAttribute("dir") ? document.body : document.documentElement,
        this.__targetIsRTL = "rtl" === a.getAttribute("dir")) : (a && a.nodeType !== Node.ELEMENT_NODE && (a = a.host),
        this.__targetIsRTL = a && "rtl" === window.getComputedStyle(a).direction));
        return this.__targetIsRTL
    },
    _nameChanged: function() {
        this._meta.value = null;
        this._meta.key = this.name;
        this._meta.value = this;
        this.async(function() {
            this.fire("iron-iconset-added", this, {
                node: window
            })
        })
    },
    _createIconMap: function() {
        var a = Object.create(null);
        Polymer.dom(this).querySelectorAll("[id]").forEach(function(b) {
            a[b.id] = b
        });
        return a
    },
    _cloneIcon: function(a, b) {
        this._icons = this._icons || this._createIconMap();
        return this._prepareSvgClone(this._icons[a], this.size, b)
    },
    _prepareSvgClone: function(a, b, c) {
        if (a) {
            a = a.cloneNode(!0);
            var d = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            b = a.getAttribute("viewBox") || "0 0 " + b + " " + b;
            var e = "pointer-events: none; display: block; width: 100%; height: 100%;";
            c && a.hasAttribute("mirror-in-rtl") && (e += "-webkit-transform:scale(-1,1);transform:scale(-1,1);");
            d.setAttribute("viewBox", b);
            d.setAttribute("preserveAspectRatio", "xMidYMid meet");
            d.setAttribute("focusable", "false");
            d.style.cssText = e;
            d.appendChild(a).removeAttribute("id");
            return d
        }
        return null
    }
});
D.IronSelector.IronMultiSelectable = {};
Polymer.IronMultiSelectableBehaviorImpl = {
    properties: {
        multi: {
            type: Boolean,
            value: !1,
            observer: "multiChanged"
        },
        selectedValues: {
            type: Array,
            notify: !0,
            value: function() {
                return []
            }
        },
        selectedItems: {
            type: Array,
            readOnly: !0,
            notify: !0,
            value: function() {
                return []
            }
        }
    },
    observers: ["_updateSelected(selectedValues.splices)"],
    select: function(a) {
        this.multi ? this._toggleSelected(a) : this.selected = a
    },
    multiChanged: function(a) {
        this._selection.multi = a;
        this._updateSelected()
    },
    get _shouldUpdateSelection() {
        return null != this.selected || null != this.selectedValues && this.selectedValues.length
    },
    _updateAttrForSelected: function() {
        this.multi ? this.selectedItems && 0 < this.selectedItems.length && (this.selectedValues = this.selectedItems.map(function(a) {
            return this._indexToValue(this.indexOf(a))
        }, this).filter(function(a) {
            return null != a
        }, this)) : Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this)
    },
    _updateSelected: function() {
        this.multi ? this._selectMulti(this.selectedValues) : this._selectSelected(this.selected)
    },
    _selectMulti: function(a) {
        a = a || [];
        a = (this._valuesToItems(a) || []).filter(function(a) {
            return null !== a && void 0 !== a
        });
        this._selection.clear(a);
        for (var b = 0; b < a.length; b++)
            this._selection.setItemSelected(a[b], !0);
        this.fallbackSelection && !this._selection.get().length && (a = this._valueToItem(this.fallbackSelection)) && this.select(this.fallbackSelection)
    },
    _selectionChange: function() {
        var a = this._selection.get();
        this.multi ? (this._setSelectedItems(a),
        this._setSelectedItem(a.length ? a[0] : null)) : null !== a && void 0 !== a ? (this._setSelectedItems([a]),
        this._setSelectedItem(a)) : (this._setSelectedItems([]),
        this._setSelectedItem(null))
    },
    _toggleSelected: function(a) {
        var b = this.selectedValues.indexOf(a)
          , c = 0 > b;
        c ? this.push("selectedValues", a) : this.splice("selectedValues", b, 1)
    },
    _valuesToItems: function(a) {
        return null == a ? null : a.map(function(a) {
            return this._valueToItem(a)
        }, this)
    }
};
Polymer.IronMultiSelectableBehavior = [Polymer.IronSelectableBehavior, Polymer.IronMultiSelectableBehaviorImpl];
D.IronMenuBehavior = {};
D.IronMenuBehavior.IronMenuBehavior = {};
Polymer.IronMenuBehaviorImpl = {
    properties: {
        focusedItem: {
            observer: "_focusedItemChanged",
            readOnly: !0,
            type: Object
        },
        attrForItemTitle: {
            type: String
        },
        disabled: {
            type: Boolean,
            value: !1,
            observer: "_disabledChanged"
        }
    },
    _SEARCH_RESET_TIMEOUT_MS: 1E3,
    _previousTabIndex: 0,
    hostAttributes: {
        role: "menu"
    },
    observers: ["_updateMultiselectable(multi)"],
    listeners: {
        focus: "_onFocus",
        keydown: "_onKeydown",
        "iron-items-changed": "_onIronItemsChanged"
    },
    keyBindings: {
        up: "_onUpKey",
        down: "_onDownKey",
        esc: "_onEscKey",
        "shift+tab:keydown": "_onShiftTabDown"
    },
    attached: function() {
        this._resetTabindices()
    },
    select: function(a) {
        this._defaultFocusAsync && (this.cancelAsync(this._defaultFocusAsync),
        this._defaultFocusAsync = null);
        var b = this._valueToItem(a);
        b && b.hasAttribute("disabled") || (this._setFocusedItem(b),
        Polymer.IronMultiSelectableBehaviorImpl.select.apply(this, arguments))
    },
    _resetTabindices: function() {
        var a = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;
        this.items.forEach(function(b) {
            b.setAttribute("tabindex", b === a ? "0" : "-1")
        }, this)
    },
    _updateMultiselectable: function(a) {
        a ? this.setAttribute("aria-multiselectable", "true") : this.removeAttribute("aria-multiselectable")
    },
    _focusWithKeyboardEvent: function(a) {
        this.cancelDebouncer("_clearSearchText");
        var b = this._searchText || "";
        a = a.key && 1 == a.key.length ? a.key : String.fromCharCode(a.keyCode);
        b += a.toLocaleLowerCase();
        a = b.length;
        for (var c = 0, d; d = this.items[c]; c++)
            if (!d.hasAttribute("disabled")) {
                var e = this.attrForItemTitle || "textContent";
                e = (d[e] || d.getAttribute(e) || "").trim();
                if (!(e.length < a) && e.slice(0, a).toLocaleLowerCase() == b) {
                    this._setFocusedItem(d);
                    break
                }
            }
        this._searchText = b;
        this.debounce("_clearSearchText", this._clearSearchText, this._SEARCH_RESET_TIMEOUT_MS)
    },
    _clearSearchText: function() {
        this._searchText = ""
    },
    _focusPrevious: function() {
        for (var a = this.items.length, b = Number(this.indexOf(this.focusedItem)), c = 1; c < a + 1; c++) {
            var d = this.items[(b - c + a) % a];
            if (!d.hasAttribute("disabled")) {
                var e = Polymer.dom(d).getOwnerRoot() || document;
                this._setFocusedItem(d);
                if (Polymer.dom(e).activeElement == d)
                    break
            }
        }
    },
    _focusNext: function() {
        for (var a = this.items.length, b = Number(this.indexOf(this.focusedItem)), c = 1; c < a + 1; c++) {
            var d = this.items[(b + c) % a];
            if (!d.hasAttribute("disabled")) {
                var e = Polymer.dom(d).getOwnerRoot() || document;
                this._setFocusedItem(d);
                if (Polymer.dom(e).activeElement == d)
                    break
            }
        }
    },
    _applySelection: function(a, b) {
        b ? a.setAttribute("aria-selected", "true") : a.removeAttribute("aria-selected");
        Polymer.IronSelectableBehavior._applySelection.apply(this, arguments)
    },
    _focusedItemChanged: function(a, b) {
        b && b.setAttribute("tabindex", "-1");
        !a || a.hasAttribute("disabled") || this.disabled || (a.setAttribute("tabindex", "0"),
        a.focus())
    },
    _onIronItemsChanged: function(a) {
        a.detail.addedNodes.length && this._resetTabindices()
    },
    _onShiftTabDown: function() {
        var a = this.getAttribute("tabindex");
        Polymer.IronMenuBehaviorImpl._shiftTabPressed = !0;
        this._setFocusedItem(null);
        this.setAttribute("tabindex", "-1");
        this.async(function() {
            this.setAttribute("tabindex", a);
            Polymer.IronMenuBehaviorImpl._shiftTabPressed = !1
        }, 1)
    },
    _onFocus: function(a) {
        !Polymer.IronMenuBehaviorImpl._shiftTabPressed && (a = Polymer.dom(a).rootTarget,
        a === this || "undefined" === typeof a.tabIndex || this.isLightDescendant(a)) && (this._defaultFocusAsync = this.async(function() {
            var a = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;
            this._setFocusedItem(null);
            a ? this._setFocusedItem(a) : this.items[0] && this._focusNext()
        }))
    },
    _onUpKey: function(a) {
        this._focusPrevious();
        a.detail.keyboardEvent.preventDefault()
    },
    _onDownKey: function(a) {
        this._focusNext();
        a.detail.keyboardEvent.preventDefault()
    },
    _onEscKey: function() {
        var a = this.focusedItem;
        a && a.blur()
    },
    _onKeydown: function(a) {
        this.keyboardEventMatchesKeys(a, "up down esc") || this._focusWithKeyboardEvent(a);
        a.stopPropagation()
    },
    _activateHandler: function(a) {
        Polymer.IronSelectableBehavior._activateHandler.call(this, a);
        a.stopPropagation()
    },
    _disabledChanged: function(a) {
        a ? (this._previousTabIndex = this.hasAttribute("tabindex") ? this.tabIndex : 0,
        this.removeAttribute("tabindex")) : this.hasAttribute("tabindex") || this.setAttribute("tabindex", this._previousTabIndex)
    }
};
Polymer.IronMenuBehaviorImpl._shiftTabPressed = !1;
Polymer.IronMenuBehavior = [Polymer.IronMultiSelectableBehavior, Polymer.IronA11yKeysBehavior, Polymer.IronMenuBehaviorImpl];
D.IronMenuBehavior.IronMenubarBehavior = {};
Polymer.IronMenubarBehaviorImpl = {
    hostAttributes: {
        role: "menubar"
    },
    keyBindings: {
        left: "_onLeftKey",
        right: "_onRightKey"
    },
    _onUpKey: function(a) {
        this.focusedItem.click();
        a.detail.keyboardEvent.preventDefault()
    },
    _onDownKey: function(a) {
        this.focusedItem.click();
        a.detail.keyboardEvent.preventDefault()
    },
    get _isRTL() {
        return "rtl" === window.getComputedStyle(this).direction
    },
    _onLeftKey: function(a) {
        this._isRTL ? this._focusNext() : this._focusPrevious();
        a.detail.keyboardEvent.preventDefault()
    },
    _onRightKey: function(a) {
        this._isRTL ? this._focusPrevious() : this._focusNext();
        a.detail.keyboardEvent.preventDefault()
    },
    _onKeydown: function(a) {
        this.keyboardEventMatchesKeys(a, "up down left right esc") || this._focusWithKeyboardEvent(a)
    }
};
Polymer.IronMenubarBehavior = [Polymer.IronMenuBehavior, Polymer.IronMenubarBehaviorImpl];
D.PaperBehaviors.PaperInkyFocusBehavior = {};
Polymer.PaperInkyFocusBehaviorImpl = {
    observers: ["_focusedChanged(receivedFocusFromKeyboard)"],
    _focusedChanged: function(a) {
        a && this.ensureRipple();
        this.hasRipple() && (this._ripple.holdDown = a)
    },
    _createRipple: function() {
        var a = Polymer.PaperRippleBehavior._createRipple();
        a.id = "ink";
        a.setAttribute("center", "");
        a.classList.add("circle");
        return a
    }
};
Polymer.PaperInkyFocusBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperInkyFocusBehaviorImpl];
D.PaperIconButton = {};
D.PaperIconButton.PaperIconButton = {};
Polymer({
    is: "paper-icon-button",
    hostAttributes: {
        role: "button",
        tabindex: "0"
    },
    behaviors: [Polymer.PaperInkyFocusBehavior],
    properties: {
        src: {
            type: String
        },
        icon: {
            type: String
        },
        alt: {
            type: String,
            observer: "_altChanged"
        }
    },
    _altChanged: function(a, b) {
        var c = this.getAttribute("aria-label");
        c && b != c || this.setAttribute("aria-label", a)
    }
});
D.PaperTabs = {};
D.PaperTabs.PaperTab = {};
Polymer({
    is: "paper-tab",
    behaviors: [Polymer.IronControlState, Polymer.IronButtonState, Polymer.PaperRippleBehavior],
    properties: {
        link: {
            type: Boolean,
            value: !1,
            reflectToAttribute: !0
        }
    },
    hostAttributes: {
        role: "tab"
    },
    listeners: {
        down: "_updateNoink",
        tap: "_onTap"
    },
    attached: function() {
        this._updateNoink()
    },
    get _parentNoink() {
        var a = Polymer.dom(this).parentNode;
        return !!a && !!a.noink
    },
    _updateNoink: function() {
        this.noink = !!this.noink || !!this._parentNoink
    },
    _onTap: function(a) {
        if (this.link) {
            var b = this.queryEffectiveChildren("a");
            b && a.target !== b && b.click()
        }
    }
});
D.PaperTabs.PaperTabsIcons = {};
D.PaperTabs.PaperTabs = {};
Polymer({
    is: "paper-tabs",
    behaviors: [Polymer.IronResizableBehavior, Polymer.IronMenubarBehavior],
    properties: {
        noink: {
            type: Boolean,
            value: !1,
            observer: "_noinkChanged"
        },
        noBar: {
            type: Boolean,
            value: !1
        },
        noSlide: {
            type: Boolean,
            value: !1
        },
        scrollable: {
            type: Boolean,
            value: !1
        },
        fitContainer: {
            type: Boolean,
            value: !1
        },
        disableDrag: {
            type: Boolean,
            value: !1
        },
        hideScrollButtons: {
            type: Boolean,
            value: !1
        },
        alignBottom: {
            type: Boolean,
            value: !1
        },
        selectable: {
            type: String,
            value: "paper-tab"
        },
        autoselect: {
            type: Boolean,
            value: !1
        },
        autoselectDelay: {
            type: Number,
            value: 0
        },
        _step: {
            type: Number,
            value: 10
        },
        _holdDelay: {
            type: Number,
            value: 1
        },
        _leftHidden: {
            type: Boolean,
            value: !1
        },
        _rightHidden: {
            type: Boolean,
            value: !1
        },
        _previousTab: {
            type: Object
        }
    },
    hostAttributes: {
        role: "tablist"
    },
    listeners: {
        "iron-resize": "_onTabSizingChanged",
        "iron-items-changed": "_onTabSizingChanged",
        "iron-select": "_onIronSelect",
        "iron-deselect": "_onIronDeselect"
    },
    keyBindings: {
        "left:keyup right:keyup": "_onArrowKeyup"
    },
    created: function() {
        this._holdJob = null;
        this._pendingActivationTimeout = this._pendingActivationItem = void 0;
        this._bindDelayedActivationHandler = this._delayedActivationHandler.bind(this);
        this.addEventListener("blur", this._onBlurCapture.bind(this), !0)
    },
    ready: function() {
        this.setScrollDirection("y", this.$.tabsContainer)
    },
    detached: function() {
        this._cancelPendingActivation()
    },
    _noinkChanged: function(a) {
        var b = Polymer.dom(this).querySelectorAll("paper-tab");
        b.forEach(a ? this._setNoinkAttribute : this._removeNoinkAttribute)
    },
    _setNoinkAttribute: function(a) {
        a.setAttribute("noink", "")
    },
    _removeNoinkAttribute: function(a) {
        a.removeAttribute("noink")
    },
    _computeScrollButtonClass: function(a, b, c) {
        return !b || c ? "hidden" : a ? "not-visible" : ""
    },
    _computeTabsContentClass: function(a, b) {
        return a ? "scrollable" + (b ? " fit-container" : "") : " fit-container"
    },
    _computeSelectionBarClass: function(a, b) {
        return a ? "hidden" : b ? "align-bottom" : ""
    },
    _onTabSizingChanged: function() {
        this.debounce("_onTabSizingChanged", function() {
            this._scroll();
            this._tabChanged(this.selectedItem)
        }, 10)
    },
    _onIronSelect: function(a) {
        this._tabChanged(a.detail.item, this._previousTab);
        this._previousTab = a.detail.item;
        this.cancelDebouncer("tab-changed")
    },
    _onIronDeselect: function() {
        this.debounce("tab-changed", function() {
            this._tabChanged(null, this._previousTab);
            this._previousTab = null
        }, 1)
    },
    _activateHandler: function() {
        this._cancelPendingActivation();
        Polymer.IronMenuBehaviorImpl._activateHandler.apply(this, arguments)
    },
    _scheduleActivation: function(a, b) {
        this._pendingActivationItem = a;
        this._pendingActivationTimeout = this.async(this._bindDelayedActivationHandler, b)
    },
    _delayedActivationHandler: function() {
        var a = this._pendingActivationItem;
        this._pendingActivationTimeout = this._pendingActivationItem = void 0;
        a.fire(this.activateEvent, null, {
            bubbles: !0,
            cancelable: !0
        })
    },
    _cancelPendingActivation: function() {
        void 0 !== this._pendingActivationTimeout && (this.cancelAsync(this._pendingActivationTimeout),
        this._pendingActivationTimeout = this._pendingActivationItem = void 0)
    },
    _onArrowKeyup: function() {
        this.autoselect && this._scheduleActivation(this.focusedItem, this.autoselectDelay)
    },
    _onBlurCapture: function(a) {
        a.target === this._pendingActivationItem && this._cancelPendingActivation()
    },
    get _tabContainerScrollSize() {
        return Math.max(0, this.$.tabsContainer.scrollWidth - this.$.tabsContainer.offsetWidth)
    },
    _scroll: function(a, b) {
        this.scrollable && (a = b && -b.ddx || 0,
        this._affectScroll(a))
    },
    _down: function() {
        this.async(function() {
            this._defaultFocusAsync && (this.cancelAsync(this._defaultFocusAsync),
            this._defaultFocusAsync = null)
        }, 1)
    },
    _affectScroll: function(a) {
        this.$.tabsContainer.scrollLeft += a;
        a = this.$.tabsContainer.scrollLeft;
        this._leftHidden = 0 === a;
        this._rightHidden = a === this._tabContainerScrollSize
    },
    _onLeftScrollButtonDown: function() {
        this._scrollToLeft();
        this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay)
    },
    _onRightScrollButtonDown: function() {
        this._scrollToRight();
        this._holdJob = setInterval(this._scrollToRight.bind(this), this._holdDelay)
    },
    _onScrollButtonUp: function() {
        clearInterval(this._holdJob);
        this._holdJob = null
    },
    _scrollToLeft: function() {
        this._affectScroll(-this._step)
    },
    _scrollToRight: function() {
        this._affectScroll(this._step)
    },
    _tabChanged: function(a, b) {
        if (a) {
            var c = this.$.tabsContent.getBoundingClientRect()
              , d = c.width
              , e = a.getBoundingClientRect();
            c = e.left - c.left;
            this._pos = {
                width: this._calcPercent(e.width, d),
                left: this._calcPercent(c, d)
            };
            if (this.noSlide || null == b)
                this.$.selectionBar.classList.remove("expand"),
                this.$.selectionBar.classList.remove("contract"),
                this._positionBar(this._pos.width, this._pos.left);
            else {
                var f = b.getBoundingClientRect();
                b = this.items.indexOf(b);
                a = this.items.indexOf(a);
                this.$.selectionBar.classList.add("expand");
                a = b < a;
                (b = this._isRTL) && (a = !a);
                a ? this._positionBar(this._calcPercent(e.left + e.width - f.left, d) - 5, this._left) : this._positionBar(this._calcPercent(f.left + f.width - e.left, d) - 5, this._calcPercent(c, d) + 5);
                this.scrollable && this._scrollToSelectedIfNeeded(e.width, c)
            }
        } else
            this.$.selectionBar.classList.remove("expand"),
            this.$.selectionBar.classList.remove("contract"),
            this._positionBar(0, 0)
    },
    _scrollToSelectedIfNeeded: function(a, b) {
        b -= this.$.tabsContainer.scrollLeft;
        0 > b ? this.$.tabsContainer.scrollLeft += b : (b += a - this.$.tabsContainer.offsetWidth,
        0 < b && (this.$.tabsContainer.scrollLeft += b))
    },
    _calcPercent: function(a, b) {
        return 100 * a / b
    },
    _positionBar: function(a, b) {
        a = a || 0;
        b = b || 0;
        this._width = a;
        this._left = b;
        this.transform("translateX(" + b + "%) scaleX(" + a / 100 + ")", this.$.selectionBar)
    },
    _onBarTransitionEnd: function() {
        var a = this.$.selectionBar.classList;
        a.contains("expand") ? (a.remove("expand"),
        a.add("contract"),
        this._positionBar(this._pos.width, this._pos.left)) : a.contains("contract") && a.remove("contract")
    }
});
D.NeonAnimation = {};
D.NeonAnimation.NeonAnimationBehavior = {};
Polymer.NeonAnimationBehavior = {
    properties: {
        animationTiming: {
            type: Object,
            value: function() {
                return {
                    duration: 500,
                    easing: "cubic-bezier(0.4, 0, 0.2, 1)",
                    fill: "both"
                }
            }
        }
    },
    isNeonAnimation: !0,
    timingFromConfig: function(a) {
        if (a.timing)
            for (var b in a.timing)
                this.animationTiming[b] = a.timing[b];
        return this.animationTiming
    },
    setPrefixedProperty: function(a, b, c) {
        var d = {
            transform: ["webkitTransform"],
            transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
        };
        d = d[b];
        for (var e, f = 0; e = d[f]; f++)
            a.style[e] = c;
        a.style[b] = c
    },
    complete: function() {}
};
/*

 Copyright 2014 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
 limitations under the License.
*/
(function() {
    !function(a, b) {
        var c = {}
          , d = {}
          , e = {};
        !function(a) {
            function b(a) {
                if ("number" == typeof a)
                    return a;
                var b = {}, c;
                for (c in a)
                    b[c] = a[c];
                return b
            }
            function c() {
                this._endDelay = this._delay = 0;
                this._fill = "none";
                this._iterationStart = 0;
                this._iterations = 1;
                this._duration = 0;
                this._playbackRate = 1;
                this._direction = "normal";
                this._easing = "linear";
                this._easingFunction = A
            }
            function d() {
                return a.isDeprecated("Invalid timing inputs", "2016-03-02", "TypeError exceptions will be thrown instead.", !0)
            }
            function e(b, d) {
                var e = new c;
                return d && (e.fill = "both",
                e.duration = "auto"),
                "number" != typeof b || isNaN(b) ? void 0 !== b && Object.getOwnPropertyNames(b).forEach(function(c) {
                    "auto" == b[c] || ("number" == typeof e[c] || "duration" == c) && ("number" != typeof b[c] || isNaN(b[c])) || "fill" == c && -1 == C.indexOf(b[c]) || "direction" == c && -1 == y.indexOf(b[c]) || "playbackRate" == c && 1 !== b[c] && a.isDeprecated("AnimationEffectTiming.playbackRate", "2014-11-28", "Use Animation.playbackRate instead.") || (e[c] = b[c])
                }) : e.duration = b,
                e
            }
            function f(a) {
                return "number" == typeof a && (a = isNaN(a) ? {
                    duration: 0
                } : {
                    duration: a
                }),
                a
            }
            function t(b, c) {
                return b = a.numericTimingToObject(b),
                e(b, c)
            }
            function v(a, b, c, d) {
                return 0 > a || 1 < a || 0 > c || 1 < c ? A : function(e) {
                    if (0 == e || 1 == e)
                        return e;
                    for (var h = 0, f = 1; ; ) {
                        var k = (h + f) / 2
                          , m = 3 * a * (1 - k) * (1 - k) * k + 3 * c * (1 - k) * k * k + k * k * k;
                        if (1E-4 > Math.abs(e - m))
                            return 3 * b * (1 - k) * (1 - k) * k + 3 * d * (1 - k) * k * k + k * k * k;
                        e > m ? h = k : f = k
                    }
                }
            }
            function z(a, b) {
                return function(c) {
                    if (1 <= c)
                        return 1;
                    var d = 1 / a;
                    return c += b * d,
                    c - c % d
                }
            }
            function B(a) {
                E || (E = document.createElement("div").style);
                E.animationTimingFunction = "";
                E.animationTimingFunction = a;
                var b = E.animationTimingFunction;
                if ("" == b && d())
                    throw new TypeError(a + " is not a valid value for easing");
                return (a = M.exec(b)) ? v.apply(this, a.slice(1).map(Number)) : (a = N.exec(b)) ? z(Number(a[1]), {
                    start: G,
                    middle: H,
                    end: I
                }[a[2]]) : (b = O[b]) ? b : A
            }
            function q(a) {
                return Math.abs(a.duration * a.iterations / a.playbackRate)
            }
            function u(a, b, c) {
                return null == b ? J : b < c.delay ? F : b >= c.delay + a ? K : L
            }
            function w(a, b, c) {
                var d = u(a, b, c);
                a: {
                    var e = c.fill;
                    switch (d) {
                    case F:
                        b = "backwards" == e || "both" == e ? 0 : null;
                        break a;
                    case L:
                        b -= c.delay;
                        break a;
                    case K:
                        b = "forwards" == e || "both" == e ? a : null;
                        break a;
                    case J:
                        b = null;
                        break a
                    }
                    b = void 0
                }
                if (null === b)
                    return null;
                if (0 === a)
                    return d === F ? 0 : 1;
                d = c.iterationStart * c.duration;
                b = (0 > c.playbackRate ? b - a : b) * c.playbackRate + d;
                a = c.duration;
                a = b === 1 / 0 || b === -(1 / 0) || b - d == c.duration * c.iterations && c.iterations && 0 == (c.iterations + c.iterationStart) % 1 ? a : b % a;
                d = c.duration;
                b = 0 === b ? 0 : a == d ? c.iterationStart + c.iterations - 1 : Math.floor(b / d);
                d = c.duration;
                b = 1 <= b % 2;
                a = (b = "normal" == c.direction || c.direction == (b ? "alternate-reverse" : "alternate")) ? a : d - a;
                a /= d;
                a = d * c._easingFunction(a);
                return a / c.duration
            }
            var C = ["backwards", "forwards", "both", "none"]
              , y = ["reverse", "alternate", "alternate-reverse"]
              , A = function(a) {
                return a
            };
            c.prototype = {
                _setMember: function(b, c) {
                    this["_" + b] = c;
                    this._effect && (this._effect._timingInput[b] = c,
                    this._effect._timing = a.normalizeTimingInput(this._effect._timingInput),
                    this._effect.activeDuration = a.calculateActiveDuration(this._effect._timing),
                    this._effect._animation && this._effect._animation._rebuildUnderlyingAnimation())
                },
                get playbackRate() {
                    return this._playbackRate
                },
                set delay(a) {
                    this._setMember("delay", a)
                },
                get delay() {
                    return this._delay
                },
                set endDelay(a) {
                    this._setMember("endDelay", a)
                },
                get endDelay() {
                    return this._endDelay
                },
                set fill(a) {
                    this._setMember("fill", a)
                },
                get fill() {
                    return this._fill
                },
                set iterationStart(a) {
                    if ((isNaN(a) || 0 > a) && d())
                        throw new TypeError("iterationStart must be a non-negative number, received: " + timing.iterationStart);
                    this._setMember("iterationStart", a)
                },
                get iterationStart() {
                    return this._iterationStart
                },
                set duration(a) {
                    if ("auto" != a && (isNaN(a) || 0 > a) && d())
                        throw new TypeError("duration must be non-negative or auto, received: " + a);
                    this._setMember("duration", a)
                },
                get duration() {
                    return this._duration
                },
                set direction(a) {
                    this._setMember("direction", a)
                },
                get direction() {
                    return this._direction
                },
                set easing(a) {
                    this._easingFunction = B(a);
                    this._setMember("easing", a)
                },
                get easing() {
                    return this._easing
                },
                set iterations(a) {
                    if ((isNaN(a) || 0 > a) && d())
                        throw new TypeError("iterations must be non-negative, received: " + a);
                    this._setMember("iterations", a)
                },
                get iterations() {
                    return this._iterations
                }
            };
            var G = 1
              , H = .5
              , I = 0
              , O = {
                ease: v(.25, .1, .25, 1),
                "ease-in": v(.42, 0, 1, 1),
                "ease-out": v(0, 0, .58, 1),
                "ease-in-out": v(.42, 0, .58, 1),
                "step-start": z(1, G),
                "step-middle": z(1, H),
                "step-end": z(1, I)
            }
              , E = null
              , M = /cubic-bezier\(\s*(-?\d+\.?\d*|-?\.\d+)\s*,\s*(-?\d+\.?\d*|-?\.\d+)\s*,\s*(-?\d+\.?\d*|-?\.\d+)\s*,\s*(-?\d+\.?\d*|-?\.\d+)\s*\)/
              , N = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/
              , J = 0
              , F = 1
              , K = 2
              , L = 3;
            a.cloneTimingInput = b;
            a.makeTiming = e;
            a.numericTimingToObject = f;
            a.normalizeTimingInput = t;
            a.calculateActiveDuration = q;
            a.calculateTimeFraction = w;
            a.calculatePhase = u;
            a.toTimingFunction = B
        }(c, null);
        (function(a) {
            function b(a) {
                var b = [], c;
                for (c in a)
                    if (!(c in ["easing", "offset", "composite"])) {
                        var d = a[c];
                        Array.isArray(d) || (d = [d]);
                        for (var e, h = d.length, f = 0; h > f; f++)
                            e = {},
                            "offset"in a ? e.offset = a.offset : 1 == h ? e.offset = 1 : e.offset = f / (h - 1),
                            "easing"in a && (e.easing = a.easing),
                            "composite"in a && (e.composite = a.composite),
                            e[c] = d[f],
                            b.push(e)
                    }
                return b.sort(function(a, b) {
                    return a.offset - b.offset
                }),
                b
            }
            function c(a) {
                function c() {
                    var a = h.length;
                    null == h[a - 1].offset && (h[a - 1].offset = 1);
                    1 < a && null == h[0].offset && (h[0].offset = 0);
                    for (var b = 0, c = h[0].offset, d = 1; a > d; d++) {
                        var e = h[d].offset;
                        if (null != e) {
                            for (var f = 1; d - b > f; f++)
                                h[b + f].offset = c + (e - c) * f / (d - b);
                            b = d;
                            c = e
                        }
                    }
                }
                if (null == a)
                    return [];
                window.Symbol && Symbol.iterator && Array.prototype.from && a[Symbol.iterator] && (a = Array.from(a));
                Array.isArray(a) || (a = b(a));
                var h = a.map(function(a) {
                    var b = {}, c;
                    for (c in a) {
                        var h = a[c];
                        if ("offset" == c) {
                            if (null != h && (h = Number(h),
                            !isFinite(h)))
                                throw new TypeError("keyframe offsets must be numbers.");
                        } else {
                            if ("composite" == c)
                                throw {
                                    type: DOMException.NOT_SUPPORTED_ERR,
                                    name: "NotSupportedError",
                                    message: "add compositing is not supported"
                                };
                            h = "" + h
                        }
                        var f = void 0
                          , k = c
                          , m = h;
                        h = b;
                        var r = d[k];
                        if (r)
                            for (f in e.style[k] = m,
                            r)
                                k = r[f],
                                m = e.style[k],
                                h[k] = k in t ? t[k][m] || m : m;
                        else
                            h[k] = k in t ? t[k][m] || m : m
                    }
                    return void 0 == b.offset && (b.offset = null),
                    b
                });
                a = !0;
                for (var f = -(1 / 0), k = 0; k < h.length; k++) {
                    var m = h[k].offset;
                    if (null != m) {
                        if (f > m)
                            throw {
                                code: DOMException.INVALID_MODIFICATION_ERR,
                                name: "InvalidModificationError",
                                message: "Keyframes are not loosely sorted by offset. Sort or specify offsets."
                            };
                        f = m
                    } else
                        a = !1
                }
                return h = h.filter(function(a) {
                    return 0 <= a.offset && 1 >= a.offset
                }),
                a || c(),
                h
            }
            var d = {
                background: "backgroundImage backgroundPosition backgroundSize backgroundRepeat backgroundAttachment backgroundOrigin backgroundClip backgroundColor".split(" "),
                border: "borderTopColor borderTopStyle borderTopWidth borderRightColor borderRightStyle borderRightWidth borderBottomColor borderBottomStyle borderBottomWidth borderLeftColor borderLeftStyle borderLeftWidth".split(" "),
                borderBottom: ["borderBottomWidth", "borderBottomStyle", "borderBottomColor"],
                borderColor: ["borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor"],
                borderLeft: ["borderLeftWidth", "borderLeftStyle", "borderLeftColor"],
                borderRadius: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                borderRight: ["borderRightWidth", "borderRightStyle", "borderRightColor"],
                borderTop: ["borderTopWidth", "borderTopStyle", "borderTopColor"],
                borderWidth: ["borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth"],
                flex: ["flexGrow", "flexShrink", "flexBasis"],
                font: "fontFamily fontSize fontStyle fontVariant fontWeight lineHeight".split(" "),
                margin: ["marginTop", "marginRight", "marginBottom", "marginLeft"],
                outline: ["outlineColor", "outlineStyle", "outlineWidth"],
                padding: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]
            }
              , e = document.createElementNS("http://www.w3.org/1999/xhtml", "div")
              , f = {
                thin: "1px",
                medium: "3px",
                thick: "5px"
            }
              , t = {
                borderBottomWidth: f,
                borderLeftWidth: f,
                borderRightWidth: f,
                borderTopWidth: f,
                fontSize: {
                    "xx-small": "60%",
                    "x-small": "75%",
                    small: "89%",
                    medium: "100%",
                    large: "120%",
                    "x-large": "150%",
                    "xx-large": "200%"
                },
                fontWeight: {
                    normal: "400",
                    bold: "700"
                },
                outlineWidth: f,
                textShadow: {
                    none: "0px 0px 0px transparent"
                },
                boxShadow: {
                    none: "0px 0px 0px 0px transparent"
                }
            };
            a.convertToArrayForm = b;
            a.normalizeKeyframes = c
        }
        )(c, null);
        (function(a) {
            var b = {};
            a.isDeprecated = function(a, c, d, e) {
                e = e ? "are" : "is";
                var h = new Date;
                c = new Date(c);
                return c.setMonth(c.getMonth() + 3),
                c > h ? (a in b || console.warn("Web Animations: " + a + " " + e + " deprecated and will stop working on " + c.toDateString() + ". " + d),
                b[a] = !0,
                !1) : !0
            }
            ;
            a.deprecated = function(b, c, d, e) {
                var h = e ? "are" : "is";
                if (a.isDeprecated(b, c, d, e))
                    throw Error(b + " " + h + " no longer supported. " + d);
            }
        }
        )(c);
        (function() {
            if (document.documentElement.animate) {
                var a = document.documentElement.animate([], 0)
                  , b = !0;
                if (a && (b = !1,
                "play currentTime pause reverse playbackRate cancel finish startTime playState".split(" ").forEach(function(c) {
                    void 0 === a[c] && (b = !0)
                })),
                !b)
                    return
            }
            !function(a, b) {
                function c(a) {
                    for (var b = {}, c = 0; c < a.length; c++)
                        for (var d in a[c])
                            if ("offset" != d && "easing" != d && "composite" != d) {
                                var e = {
                                    offset: a[c].offset,
                                    easing: a[c].easing,
                                    value: a[c][d]
                                };
                                b[d] = b[d] || [];
                                b[d].push(e)
                            }
                    for (var h in b)
                        if (a = b[h],
                        0 != a[0].offset || 1 != a[a.length - 1].offset)
                            throw {
                                type: DOMException.NOT_SUPPORTED_ERR,
                                name: "NotSupportedError",
                                message: "Partial keyframes are not supported"
                            };
                    return b
                }
                function d(c) {
                    var d = [], e;
                    for (e in c)
                        for (var h = c[e], f = 0; f < h.length - 1; f++) {
                            var k = h[f].offset
                              , m = h[f + 1].offset
                              , r = h[f].value
                              , t = h[f + 1].value
                              , l = h[f].easing;
                            k == m && (1 == m ? r = t : t = r);
                            d.push({
                                startTime: k,
                                endTime: m,
                                easing: a.toTimingFunction(l ? l : "linear"),
                                property: e,
                                interpolation: b.propertyInterpolation(e, r, t)
                            })
                        }
                    return d.sort(function(a, b) {
                        return a.startTime - b.startTime
                    }),
                    d
                }
                b.convertEffectInput = function(e) {
                    e = a.normalizeKeyframes(e);
                    var h = c(e)
                      , f = d(h);
                    return function(a, c) {
                        if (null != c)
                            f.filter(function(a) {
                                return 0 >= c && 0 == a.startTime || 1 <= c && 1 == a.endTime || c >= a.startTime && c <= a.endTime
                            }).forEach(function(d) {
                                var e = c - d.startTime
                                  , h = d.endTime - d.startTime;
                                e = 0 == h ? 0 : d.easing(e / h);
                                b.apply(a, d.property, d.interpolation(e))
                            });
                        else
                            for (var d in h)
                                "offset" != d && "easing" != d && "composite" != d && b.clear(a, d)
                    }
                }
            }(c, d, null);
            (function(a, b) {
                function c(a) {
                    return a.replace(/-(.)/g, function(a, b) {
                        return b.toUpperCase()
                    })
                }
                function d(a, b, d) {
                    for (var e = 0; e < d.length; e++) {
                        var f = d[e]
                          , k = a
                          , m = b;
                        f = c(f);
                        h[f] = h[f] || [];
                        h[f].push([k, m])
                    }
                }
                function e(d, e, k) {
                    var m = d;
                    /-/.test(d) && !a.isDeprecated("Hyphenated property names", "2016-03-22", "Use camelCase instead.", !0) && (m = c(d));
                    "initial" != e && "initial" != k || ("initial" == e && (e = f[m]),
                    "initial" == k && (k = f[m]));
                    d = e == k ? [] : h[m];
                    for (m = 0; d && m < d.length; m++) {
                        var r = d[m][0](e)
                          , l = d[m][0](k);
                        if (void 0 !== r && void 0 !== l && (r = d[m][1](r, l))) {
                            var t = b.Interpolation.apply(null, r);
                            return function(a) {
                                return 0 == a ? e : 1 == a ? k : t(a)
                            }
                        }
                    }
                    return b.Interpolation(!1, !0, function(a) {
                        return a ? k : e
                    })
                }
                var h = {};
                b.addPropertiesHandler = d;
                var f = {
                    backgroundColor: "transparent",
                    backgroundPosition: "0% 0%",
                    borderBottomColor: "currentColor",
                    borderBottomLeftRadius: "0px",
                    borderBottomRightRadius: "0px",
                    borderBottomWidth: "3px",
                    borderLeftColor: "currentColor",
                    borderLeftWidth: "3px",
                    borderRightColor: "currentColor",
                    borderRightWidth: "3px",
                    borderSpacing: "2px",
                    borderTopColor: "currentColor",
                    borderTopLeftRadius: "0px",
                    borderTopRightRadius: "0px",
                    borderTopWidth: "3px",
                    bottom: "auto",
                    clip: "rect(0px, 0px, 0px, 0px)",
                    color: "black",
                    fontSize: "100%",
                    fontWeight: "400",
                    height: "auto",
                    left: "auto",
                    letterSpacing: "normal",
                    lineHeight: "120%",
                    marginBottom: "0px",
                    marginLeft: "0px",
                    marginRight: "0px",
                    marginTop: "0px",
                    maxHeight: "none",
                    maxWidth: "none",
                    minHeight: "0px",
                    minWidth: "0px",
                    opacity: "1.0",
                    outlineColor: "invert",
                    outlineOffset: "0px",
                    outlineWidth: "3px",
                    paddingBottom: "0px",
                    paddingLeft: "0px",
                    paddingRight: "0px",
                    paddingTop: "0px",
                    right: "auto",
                    textIndent: "0px",
                    textShadow: "0px 0px 0px transparent",
                    top: "auto",
                    transform: "",
                    verticalAlign: "0px",
                    visibility: "visible",
                    width: "auto",
                    wordSpacing: "normal",
                    zIndex: "auto"
                };
                b.propertyInterpolation = e
            }
            )(c, d, null);
            (function(a, b) {
                function c(b) {
                    var c = a.calculateActiveDuration(b)
                      , d = function(d) {
                        return a.calculateTimeFraction(c, d, b)
                    };
                    return d._totalDuration = b.delay + c + b.endDelay,
                    d._isCurrent = function(d) {
                        d = a.calculatePhase(c, d, b);
                        return d === PhaseActive || d === PhaseBefore
                    }
                    ,
                    d
                }
                b.KeyframeEffect = function(d, e, h, f) {
                    var k, m = c(a.normalizeTimingInput(h)), r = b.convertEffectInput(e);
                    e = function() {
                        r(d, k)
                    }
                    ;
                    return e._update = function(a) {
                        return k = m(a),
                        null !== k
                    }
                    ,
                    e._clear = function() {
                        r(d, null)
                    }
                    ,
                    e._hasSameTarget = function(a) {
                        return d === a
                    }
                    ,
                    e._isCurrent = m._isCurrent,
                    e._totalDuration = m._totalDuration,
                    e._id = f,
                    e
                }
                ;
                b.NullEffect = function(a) {
                    var b = function() {
                        a && (a(),
                        a = null)
                    };
                    return b._update = function() {
                        return null
                    }
                    ,
                    b._totalDuration = 0,
                    b._isCurrent = function() {
                        return !1
                    }
                    ,
                    b._hasSameTarget = function() {
                        return !1
                    }
                    ,
                    b
                }
            }
            )(c, d, null);
            (function(a) {
                a.apply = function(b, c, d) {
                    b.style[a.propertyName(c)] = d
                }
                ;
                a.clear = function(b, c) {
                    b.style[a.propertyName(c)] = ""
                }
            }
            )(d, null);
            (function(a) {
                window.Element.prototype.animate = function(b, c) {
                    var d = "";
                    return c && c.id && (d = c.id),
                    a.timeline._play(a.KeyframeEffect(this, b, c, d))
                }
            }
            )(d);
            (function(a) {
                function b(a, c, d) {
                    if ("number" == typeof a && "number" == typeof c)
                        return a * (1 - d) + c * d;
                    if ("boolean" == typeof a && "boolean" == typeof c)
                        return .5 > d ? a : c;
                    if (a.length == c.length) {
                        for (var e = [], h = 0; h < a.length; h++)
                            e.push(b(a[h], c[h], d));
                        return e
                    }
                    throw "Mismatched interpolation arguments " + a + ":" + c;
                }
                a.Interpolation = function(a, c, d) {
                    return function(e) {
                        return d(b(a, c, e))
                    }
                }
            }
            )(d, null);
            (function(a, b) {
                a.sequenceNumber = 0;
                var c = function(a, b) {
                    this.target = a;
                    this.currentTime = b;
                    this.type = "finish";
                    this.cancelable = this.bubbles = !1;
                    this.currentTarget = a;
                    this.defaultPrevented = !1;
                    this.eventPhase = Event.AT_TARGET;
                    this.timeStamp = Date.now()
                };
                b.Animation = function(b) {
                    this.id = "";
                    b && b._id && (this.id = b._id);
                    this._sequenceNumber = a.sequenceNumber++;
                    this._currentTime = 0;
                    this._startTime = null;
                    this._paused = !1;
                    this._playbackRate = 1;
                    this._finishedFlag = this._inTimeline = !0;
                    this.onfinish = null;
                    this._finishHandlers = [];
                    this._effect = b;
                    this._inEffect = this._effect._update(0);
                    this._idle = !0;
                    this._currentTimePending = !1
                }
                ;
                b.Animation.prototype = {
                    _ensureAlive: function() {
                        0 > this.playbackRate && 0 === this.currentTime ? this._inEffect = this._effect._update(-1) : this._inEffect = this._effect._update(this.currentTime);
                        this._inTimeline || !this._inEffect && this._finishedFlag || (this._inTimeline = !0,
                        b.timeline._animations.push(this))
                    },
                    _tickCurrentTime: function(a, b) {
                        a != this._currentTime && (this._currentTime = a,
                        this._isFinished && !b && (this._currentTime = 0 < this._playbackRate ? this._totalDuration : 0),
                        this._ensureAlive())
                    },
                    get currentTime() {
                        return this._idle || this._currentTimePending ? null : this._currentTime
                    },
                    set currentTime(a) {
                        a = +a;
                        isNaN(a) || (b.restart(),
                        this._paused || null == this._startTime || (this._startTime = this._timeline.currentTime - a / this._playbackRate),
                        this._currentTimePending = !1,
                        this._currentTime != a && (this._tickCurrentTime(a, !0),
                        b.invalidateEffects()))
                    },
                    get startTime() {
                        return this._startTime
                    },
                    set startTime(a) {
                        a = +a;
                        isNaN(a) || this._paused || this._idle || (this._startTime = a,
                        this._tickCurrentTime((this._timeline.currentTime - this._startTime) * this.playbackRate),
                        b.invalidateEffects())
                    },
                    get playbackRate() {
                        return this._playbackRate
                    },
                    set playbackRate(a) {
                        if (a != this._playbackRate) {
                            var b = this.currentTime;
                            this._playbackRate = a;
                            this._startTime = null;
                            "paused" != this.playState && "idle" != this.playState && this.play();
                            null != b && (this.currentTime = b)
                        }
                    },
                    get _isFinished() {
                        return !this._idle && (0 < this._playbackRate && this._currentTime >= this._totalDuration || 0 > this._playbackRate && 0 >= this._currentTime)
                    },
                    get _totalDuration() {
                        return this._effect._totalDuration
                    },
                    get playState() {
                        return this._idle ? "idle" : null == this._startTime && !this._paused && 0 != this.playbackRate || this._currentTimePending ? "pending" : this._paused ? "paused" : this._isFinished ? "finished" : "running"
                    },
                    play: function() {
                        this._paused = !1;
                        (this._isFinished || this._idle) && (this._currentTime = 0 < this._playbackRate ? 0 : this._totalDuration,
                        this._startTime = null);
                        this._idle = this._finishedFlag = !1;
                        this._ensureAlive();
                        b.invalidateEffects()
                    },
                    pause: function() {
                        this._isFinished || this._paused || this._idle || (this._currentTimePending = !0);
                        this._startTime = null;
                        this._paused = !0
                    },
                    finish: function() {
                        this._idle || (this.currentTime = 0 < this._playbackRate ? this._totalDuration : 0,
                        this._startTime = this._totalDuration - this.currentTime,
                        this._currentTimePending = !1,
                        b.invalidateEffects())
                    },
                    cancel: function() {
                        this._inEffect && (this._inEffect = !1,
                        this._idle = !0,
                        this._finishedFlag = !0,
                        this.currentTime = 0,
                        this._startTime = null,
                        this._effect._update(null),
                        b.invalidateEffects())
                    },
                    reverse: function() {
                        this.playbackRate *= -1;
                        this.play()
                    },
                    addEventListener: function(a, b) {
                        "function" == typeof b && "finish" == a && this._finishHandlers.push(b)
                    },
                    removeEventListener: function(a, b) {
                        "finish" == a && (a = this._finishHandlers.indexOf(b),
                        0 <= a && this._finishHandlers.splice(a, 1))
                    },
                    _fireEvents: function(a) {
                        if (this._isFinished) {
                            if (!this._finishedFlag) {
                                var b = new c(this,this._currentTime,a)
                                  , d = this._finishHandlers.concat(this.onfinish ? [this.onfinish] : []);
                                setTimeout(function() {
                                    d.forEach(function(a) {
                                        a.call(b.target, b)
                                    })
                                }, 0);
                                this._finishedFlag = !0
                            }
                        } else
                            this._finishedFlag = !1
                    },
                    _tick: function(a, b) {
                        this._idle || this._paused || (null == this._startTime ? b && (this.startTime = a - this._currentTime / this.playbackRate) : this._isFinished || this._tickCurrentTime((a - this._startTime) * this.playbackRate));
                        b && (this._currentTimePending = !1,
                        this._fireEvents(a))
                    },
                    get _needsTick() {
                        return this.playState in {
                            pending: 1,
                            running: 1
                        } || !this._finishedFlag
                    }
                }
            }
            )(c, d, null);
            (function(a, b) {
                function c(a) {
                    var b = l;
                    l = [];
                    a < A.currentTime && (a = A.currentTime);
                    f(a, !0);
                    b.forEach(function(b) {
                        b[1](a)
                    });
                    h()
                }
                function d(a, b) {
                    return a._sequenceNumber - b._sequenceNumber
                }
                function e() {
                    this._animations = [];
                    this.currentTime = window.performance && performance.now ? performance.now() : 0
                }
                function h() {
                    y.forEach(function(a) {
                        a()
                    });
                    y.length = 0
                }
                function f(a, c) {
                    C = !1;
                    var e = b.timeline;
                    e.currentTime = a;
                    e._animations.sort(d);
                    w = !1;
                    var h = e._animations;
                    e._animations = [];
                    var f = []
                      , k = [];
                    h = h.filter(function(b) {
                        b._tick(a, c);
                        b._inEffect ? k.push(b._effect) : f.push(b._effect);
                        b._needsTick && (w = !0);
                        var d = b._inEffect || b._needsTick;
                        return b._inTimeline = d,
                        d
                    });
                    y.push.apply(y, f);
                    y.push.apply(y, k);
                    e._animations.push.apply(e._animations, h);
                    w && requestAnimationFrame(function() {})
                }
                var k = window.requestAnimationFrame
                  , l = []
                  , u = 0;
                window.requestAnimationFrame = function(a) {
                    var b = u++;
                    return 0 == l.length && k(c),
                    l.push([b, a]),
                    b
                }
                ;
                window.cancelAnimationFrame = function(a) {
                    l.forEach(function(b) {
                        b[0] == a && (b[1] = function() {}
                        )
                    })
                }
                ;
                e.prototype = {
                    _play: function(c) {
                        c._timing = a.normalizeTimingInput(c.timing);
                        c = new b.Animation(c);
                        return c._idle = !1,
                        c._timeline = this,
                        this._animations.push(c),
                        b.restart(),
                        b.invalidateEffects(),
                        c
                    }
                };
                var w = !1
                  , C = !1;
                b.restart = function() {
                    return w || (w = !0,
                    requestAnimationFrame(function() {}),
                    C = !0),
                    C
                }
                ;
                b.invalidateEffects = function() {
                    f(b.timeline.currentTime, !1);
                    h()
                }
                ;
                var y = []
                  , A = new e;
                b.timeline = A
            }
            )(c, d, null);
            (function(a) {
                function b(a, b) {
                    var c = a.exec(b);
                    return c ? (c = a.ignoreCase ? c[0].toLowerCase() : c[0],
                    [c, b.substr(c.length)]) : void 0
                }
                function c(a, b) {
                    b = b.replace(/^\s*/, "");
                    return (a = a(b)) ? [a[0], a[1].replace(/^\s*/, "")] : void 0
                }
                function d(a, d, e) {
                    a = c.bind(null, a);
                    for (var h = []; ; ) {
                        var f = a(e);
                        if (!f || (h.push(f[0]),
                        e = f[1],
                        f = b(d, e),
                        !f || "" == f[1]))
                            return [h, e];
                        e = f[1]
                    }
                }
                function e(a, b) {
                    for (var c = 0, d = 0; d < b.length && (!/\s|,/.test(b[d]) || 0 != c); d++)
                        if ("(" == b[d])
                            c++;
                        else if (")" == b[d] && (c--,
                        0 == c && d++,
                        0 >= c))
                            break;
                    a = a(b.substr(0, d));
                    return void 0 == a ? void 0 : [a, b.substr(d)]
                }
                function h(a, b) {
                    for (var c = a, d = b; c && d; )
                        c > d ? c %= d : d %= c;
                    return a * b / (c + d)
                }
                function f(a) {
                    return function(b) {
                        b = a(b);
                        return b && (b[0] = void 0),
                        b
                    }
                }
                function l(a, b) {
                    return function(c) {
                        var d = a(c);
                        return d ? d : [b, c]
                    }
                }
                function q(b, c) {
                    for (var d = [], e = 0; e < b.length; e++) {
                        c = a.consumeTrimmed(b[e], c);
                        if (!c || "" == c[0])
                            return;
                        void 0 !== c[0] && d.push(c[0]);
                        c = c[1]
                    }
                    return "" == c ? d : void 0
                }
                function u(a, b, c, d, e) {
                    for (var f = [], k = [], m = [], l = h(d.length, e.length), r = 0; l > r; r++) {
                        var t = b(d[r % d.length], e[r % e.length]);
                        if (!t)
                            return;
                        f.push(t[0]);
                        k.push(t[1]);
                        m.push(t[2])
                    }
                    return [f, k, function(b) {
                        b = b.map(function(a, b) {
                            return m[b](a)
                        }).join(c);
                        return a ? a(b) : b
                    }
                    ]
                }
                function w(a, b, c) {
                    for (var d = [], e = [], h = [], f = 0, k = 0; k < c.length; k++)
                        if ("function" == typeof c[k]) {
                            var m = c[k](a[f], b[f++]);
                            d.push(m[0]);
                            e.push(m[1]);
                            h.push(m[2])
                        } else
                            !function(a) {
                                d.push(!1);
                                e.push(!1);
                                h.push(function() {
                                    return c[a]
                                })
                            }(k);
                    return [d, e, function(a) {
                        for (var b = "", c = 0; c < a.length; c++)
                            b += h[c](a[c]);
                        return b
                    }
                    ]
                }
                a.consumeToken = b;
                a.consumeTrimmed = c;
                a.consumeRepeated = d;
                a.consumeParenthesised = e;
                a.ignore = f;
                a.optional = l;
                a.consumeList = q;
                a.mergeNestedRepeated = u.bind(null, null);
                a.mergeWrappedNestedRepeated = u;
                a.mergeList = w
            }
            )(d);
            (function(a) {
                function b(b) {
                    function c(b) {
                        var c = a.consumeToken(/^inset/i, b);
                        return c ? (d.inset = !0,
                        c) : (c = a.consumeLengthOrPercent(b)) ? (d.lengths.push(c[0]),
                        c) : (c = a.consumeColor(b)) ? (d.color = c[0],
                        c) : void 0
                    }
                    var d = {
                        inset: !1,
                        lengths: [],
                        color: null
                    };
                    return (b = a.consumeRepeated(c, /^/, b)) && b[0].length ? [d, b[1]] : void 0
                }
                function c(c) {
                    return (c = a.consumeRepeated(b, /^,/, c)) && "" == c[1] ? c[0] : void 0
                }
                function d(b, c) {
                    for (; b.lengths.length < Math.max(b.lengths.length, c.lengths.length); )
                        b.lengths.push({
                            px: 0
                        });
                    for (; c.lengths.length < Math.max(b.lengths.length, c.lengths.length); )
                        c.lengths.push({
                            px: 0
                        });
                    if (b.inset == c.inset && !!b.color == !!c.color) {
                        for (var d, e = [], h = [[], 0], f = [[], 0], k = 0; k < b.lengths.length; k++) {
                            var m = a.mergeDimensions(b.lengths[k], c.lengths[k], 2 == k);
                            h[0].push(m[0]);
                            f[0].push(m[1]);
                            e.push(m[2])
                        }
                        b.color && c.color && (c = a.mergeColors(b.color, c.color),
                        h[1] = c[0],
                        f[1] = c[1],
                        d = c[2]);
                        return [h, f, function(a) {
                            for (var c = b.inset ? "inset " : " ", h = 0; h < e.length; h++)
                                c += e[h](a[0][h]) + " ";
                            return d && (c += d(a[1])),
                            c
                        }
                        ]
                    }
                }
                function e(b, c, d, e) {
                    function h(a) {
                        return {
                            inset: a,
                            color: [0, 0, 0, 0],
                            lengths: [{
                                px: 0
                            }, {
                                px: 0
                            }, {
                                px: 0
                            }, {
                                px: 0
                            }]
                        }
                    }
                    for (var f = [], k = [], m = 0; m < d.length || m < e.length; m++) {
                        var l = d[m] || h(e[m].inset)
                          , r = e[m] || h(d[m].inset);
                        f.push(l);
                        k.push(r)
                    }
                    return a.mergeNestedRepeated(b, c, f, k)
                }
                var h = e.bind(null, d, ", ");
                a.addPropertiesHandler(c, h, ["box-shadow", "text-shadow"])
            }
            )(d);
            (function(a) {
                function b(a) {
                    return a.toFixed(3).replace(".000", "")
                }
                function c(a, b, c) {
                    return Math.min(b, Math.max(a, c))
                }
                function d(a) {
                    return /^\s*[-+]?(\d*\.)?\d+\s*$/.test(a) ? Number(a) : void 0
                }
                function e(a, c) {
                    return [a, c, b]
                }
                function h(a, b) {
                    return 0 != a ? l(0, 1 / 0)(a, b) : void 0
                }
                function f(a, b) {
                    return [a, b, function(a) {
                        return Math.round(c(1, 1 / 0, a))
                    }
                    ]
                }
                function l(a, d) {
                    return function(e, h) {
                        return [e, h, function(e) {
                            return b(c(a, d, e))
                        }
                        ]
                    }
                }
                function q(a, b) {
                    return [a, b, Math.round]
                }
                a.clamp = c;
                a.addPropertiesHandler(d, l(0, 1 / 0), ["border-image-width", "line-height"]);
                a.addPropertiesHandler(d, l(0, 1), ["opacity", "shape-image-threshold"]);
                a.addPropertiesHandler(d, h, ["flex-grow", "flex-shrink"]);
                a.addPropertiesHandler(d, f, ["orphans", "widows"]);
                a.addPropertiesHandler(d, q, ["z-index"]);
                a.parseNumber = d;
                a.mergeNumbers = e;
                a.numberToString = b
            }
            )(d, null);
            (function(a) {
                function b(a, b) {
                    return "visible" == a || "visible" == b ? [0, 1, function(c) {
                        return 0 >= c ? a : 1 <= c ? b : "visible"
                    }
                    ] : void 0
                }
                a.addPropertiesHandler(String, b, ["visibility"])
            }
            )(d);
            (function(a) {
                function b(a) {
                    a = a.trim();
                    e.fillStyle = "#000";
                    e.fillStyle = a;
                    var b = e.fillStyle;
                    if (e.fillStyle = "#fff",
                    e.fillStyle = a,
                    b == e.fillStyle)
                        return e.fillRect(0, 0, 1, 1),
                        a = e.getImageData(0, 0, 1, 1).data,
                        e.clearRect(0, 0, 1, 1),
                        b = a[3] / 255,
                        [a[0] * b, a[1] * b, a[2] * b, b]
                }
                function c(b, c) {
                    return [b, c, function(b) {
                        if (b[3])
                            for (var c = 0; 3 > c; c++)
                                b[c] = Math.round(Math.max(0, Math.min(255, b[c] / b[3])));
                        return b[3] = a.numberToString(a.clamp(0, 1, b[3])),
                        "rgba(" + b.join(",") + ")"
                    }
                    ]
                }
                var d = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                d.width = d.height = 1;
                var e = d.getContext("2d");
                a.addPropertiesHandler(b, c, "background-color border-bottom-color border-left-color border-right-color border-top-color color outline-color text-decoration-color".split(" "));
                a.consumeColor = a.consumeParenthesised.bind(null, b);
                a.mergeColors = c
            }
            )(d, null);
            (function(a) {
                function b(a, b) {
                    if (b = b.trim().toLowerCase(),
                    "0" == b && 0 <= "px".search(a))
                        return {
                            px: 0
                        };
                    if (/^[^(]*$|^calc/.test(b)) {
                        b = b.replace(/calc\(/g, "(");
                        var c = {};
                        b = b.replace(a, function(a) {
                            return c[a] = null,
                            "U" + a
                        });
                        a = "U(" + a.source + ")";
                        for (var d = b.replace(/[-+]?(\d*\.)?\d+/g, "N").replace(new RegExp("N" + a,"g"), "D").replace(/\s[+-]\s/g, "O").replace(/\s/g, ""), e = [/N\*(D)/g, /(N|D)[*\/]N/g, /(N|D)O\1/g, /\((N|D)\)/g], f = 0; f < e.length; )
                            e[f].test(d) ? (d = d.replace(e[f], "$1"),
                            f = 0) : f++;
                        if ("D" == d) {
                            for (var h in c) {
                                d = eval(b.replace(new RegExp("U" + h,"g"), "").replace(new RegExp(a,"g"), "*0"));
                                if (!isFinite(d))
                                    return;
                                c[h] = d
                            }
                            return c
                        }
                    }
                }
                function c(a, b) {
                    return d(a, b, !0)
                }
                function d(b, c, d) {
                    var e, f = [];
                    for (e in b)
                        f.push(e);
                    for (e in c)
                        0 > f.indexOf(e) && f.push(e);
                    return b = f.map(function(a) {
                        return b[a] || 0
                    }),
                    c = f.map(function(a) {
                        return c[a] || 0
                    }),
                    [b, c, function(b) {
                        var c = b.map(function(c, e) {
                            return 1 == b.length && d && (c = Math.max(c, 0)),
                            a.numberToString(c) + f[e]
                        }).join(" + ");
                        return 1 < b.length ? "calc(" + c + ")" : c
                    }
                    ]
                }
                var e = b.bind(null, /px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc/g)
                  , f = b.bind(null, /px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|%/g)
                  , h = b.bind(null, /deg|rad|grad|turn/g);
                a.parseLength = e;
                a.parseLengthOrPercent = f;
                a.consumeLengthOrPercent = a.consumeParenthesised.bind(null, f);
                a.parseAngle = h;
                a.mergeDimensions = d;
                e = a.consumeParenthesised.bind(null, e);
                e = a.consumeRepeated.bind(void 0, e, /^/);
                var l = a.consumeRepeated.bind(void 0, e, /^,/);
                a.consumeSizePairList = l;
                e = function(a) {
                    return (a = l(a)) && "" == a[1] ? a[0] : void 0
                }
                ;
                h = a.mergeNestedRepeated.bind(void 0, c, " ");
                var q = a.mergeNestedRepeated.bind(void 0, h, ",");
                a.mergeNonNegativeSizePair = h;
                a.addPropertiesHandler(e, q, ["background-size"]);
                a.addPropertiesHandler(f, c, "border-bottom-width border-image-width border-left-width border-right-width border-top-width flex-basis font-size height line-height max-height max-width outline-width width".split(" "));
                a.addPropertiesHandler(f, d, "border-bottom-left-radius border-bottom-right-radius border-top-left-radius border-top-right-radius bottom left letter-spacing margin-bottom margin-left margin-right margin-top min-height min-width outline-offset padding-bottom padding-left padding-right padding-top perspective right shape-margin text-indent top vertical-align word-spacing".split(" "))
            }
            )(d, null);
            (function(a) {
                function b(b) {
                    return a.consumeLengthOrPercent(b) || a.consumeToken(/^auto/, b)
                }
                function c(c) {
                    return (c = a.consumeList([a.ignore(a.consumeToken.bind(null, /^rect/)), a.ignore(a.consumeToken.bind(null, /^\(/)), a.consumeRepeated.bind(null, b, /^,/), a.ignore(a.consumeToken.bind(null, /^\)/))], c)) && 4 == c[0].length ? c[0] : void 0
                }
                function d(b, c) {
                    return "auto" == b || "auto" == c ? [!0, !1, function(d) {
                        d = d ? b : c;
                        if ("auto" == d)
                            return "auto";
                        d = a.mergeDimensions(d, d);
                        return d[2](d[0])
                    }
                    ] : a.mergeDimensions(b, c)
                }
                function e(a) {
                    return "rect(" + a + ")"
                }
                var f = a.mergeWrappedNestedRepeated.bind(null, e, d, ", ");
                a.parseBox = c;
                a.mergeBoxes = f;
                a.addPropertiesHandler(c, f, ["clip"])
            }
            )(d, null);
            (function(a) {
                function b(a) {
                    return function(b) {
                        var c = 0;
                        return a.map(function(a) {
                            return a === q ? b[c++] : a
                        })
                    }
                }
                function c(a) {
                    return a
                }
                function d(b) {
                    if (b = b.toLowerCase().trim(),
                    "none" == b)
                        return [];
                    for (var c, d = /\s*(\w+)\(([^)]*)\)/g, e = [], f = 0; (c = d.exec(b)) && c.index == f; ) {
                        f = c.index + c[0].length;
                        var h = c[1]
                          , k = C[h];
                        if (!k)
                            break;
                        c = c[2].split(",");
                        k = k[0];
                        if (k.length < c.length)
                            break;
                        for (var m = [], l = 0; l < k.length; l++) {
                            var r, t = c[l], B = k[l];
                            if (r = t ? {
                                A: function(b) {
                                    return "0" == b.trim() ? w : a.parseAngle(b)
                                },
                                N: a.parseNumber,
                                T: a.parseLengthOrPercent,
                                L: a.parseLength
                            }[B.toUpperCase()](t) : {
                                a: w,
                                n: m[0],
                                t: u
                            }[B],
                            void 0 === r)
                                return;
                            m.push(r)
                        }
                        if (e.push({
                            t: h,
                            d: m
                        }),
                        d.lastIndex == b.length)
                            return e
                    }
                }
                function e(a) {
                    return a.toFixed(6).replace(".000000", "")
                }
                function f(b, c) {
                    if (b.decompositionPair !== c) {
                        b.decompositionPair = c;
                        var d = a.makeMatrixDecomposition(b)
                    }
                    if (c.decompositionPair !== b) {
                        c.decompositionPair = b;
                        var f = a.makeMatrixDecomposition(c)
                    }
                    return null == d[0] || null == f[0] ? [[!1], [!0], function(a) {
                        return a ? c[0].d : b[0].d
                    }
                    ] : (d[0].push(0),
                    f[0].push(1),
                    [d, f, function(b) {
                        var c = a.quat(d[0][3], f[0][3], b[5]);
                        b = a.composeMatrix(b[0], b[1], b[2], c, b[4]);
                        return b = b.map(e).join(",")
                    }
                    ])
                }
                function h(a) {
                    return a.replace(/(x|y|z|3d)?$/, "3d")
                }
                function l(b, c) {
                    var d = a.makeMatrixDecomposition && !0
                      , e = !1;
                    if (!b.length || !c.length) {
                        b.length || (e = !0,
                        b = c,
                        c = []);
                        for (var k = 0; k < b.length; k++) {
                            var m = b[k].t
                              , l = b[k].d
                              , r = "scale" == m.substr(0, 5) ? 1 : 0;
                            c.push({
                                t: m,
                                d: l.map(function(a) {
                                    if ("number" == typeof a)
                                        return r;
                                    var b = {}, c;
                                    for (c in a)
                                        b[c] = r;
                                    return b
                                })
                            })
                        }
                    }
                    l = [];
                    var t = []
                      , B = [];
                    if (b.length != c.length) {
                        if (!d)
                            return;
                        var q = f(b, c);
                        l = [q[0]];
                        t = [q[1]];
                        B = [["matrix", [q[2]]]]
                    } else
                        for (k = 0; k < b.length; k++) {
                            m = b[k].t;
                            var v = c[k].t
                              , u = b[k].d
                              , w = c[k].d
                              , z = C[m]
                              , y = C[v];
                            if ("perspective" == m && "perspective" == v || !("matrix" != m && "matrix3d" != m || "matrix" != v && "matrix3d" != v)) {
                                if (!d)
                                    return;
                                q = f([b[k]], [c[k]]);
                                l.push(q[0]);
                                t.push(q[1]);
                                B.push(["matrix", [q[2]]])
                            } else {
                                if (m != v)
                                    if (z[2] && y[2] && m.replace(/[xy]/, "") == v.replace(/[xy]/, ""))
                                        m = m.replace(/[xy]/, ""),
                                        u = z[2](u),
                                        w = y[2](w);
                                    else {
                                        if (!z[1] || !y[1] || h(m) != h(v)) {
                                            if (!d)
                                                return;
                                            q = f(b, c);
                                            l = [q[0]];
                                            t = [q[1]];
                                            B = [["matrix", [q[2]]]];
                                            break
                                        }
                                        m = h(m);
                                        u = z[1](u);
                                        w = y[1](w)
                                    }
                                z = [];
                                y = [];
                                v = [];
                                for (var A = 0; A < u.length; A++)
                                    q = "number" == typeof u[A] ? a.mergeNumbers : a.mergeDimensions,
                                    q = q(u[A], w[A]),
                                    z[A] = q[0],
                                    y[A] = q[1],
                                    v.push(q[2]);
                                l.push(z);
                                t.push(y);
                                B.push([m, v])
                            }
                        }
                    e && (b = l,
                    l = t,
                    t = b);
                    return [l, t, function(a) {
                        return a.map(function(a, b) {
                            a = a.map(function(a, c) {
                                return B[b][1][c](a)
                            }).join(",");
                            return "matrix" == B[b][0] && 16 == a.split(",").length && (B[b][0] = "matrix3d"),
                            B[b][0] + "(" + a + ")"
                        }).join(" ")
                    }
                    ]
                }
                var q = null
                  , u = {
                    px: 0
                }
                  , w = {
                    deg: 0
                }
                  , C = {
                    matrix: ["NNNNNN", [q, q, 0, 0, q, q, 0, 0, 0, 0, 1, 0, q, q, 0, 1], c],
                    matrix3d: ["NNNNNNNNNNNNNNNN", c],
                    rotate: ["A"],
                    rotatex: ["A"],
                    rotatey: ["A"],
                    rotatez: ["A"],
                    rotate3d: ["NNNA"],
                    perspective: ["L"],
                    scale: ["Nn", b([q, q, 1]), c],
                    scalex: ["N", b([q, 1, 1]), b([q, 1])],
                    scaley: ["N", b([1, q, 1]), b([1, q])],
                    scalez: ["N", b([1, 1, q])],
                    scale3d: ["NNN", c],
                    skew: ["Aa", null, c],
                    skewx: ["A", null, b([q, w])],
                    skewy: ["A", null, b([w, q])],
                    translate: ["Tt", b([q, q, u]), c],
                    translatex: ["T", b([q, u, u]), b([q, u])],
                    translatey: ["T", b([u, q, u]), b([u, q])],
                    translatez: ["L", b([u, u, q])],
                    translate3d: ["TTL", c]
                };
                a.addPropertiesHandler(d, l, ["transform"])
            }
            )(d, null);
            (function(a) {
                function b(a, b) {
                    b.concat([a]).forEach(function(b) {
                        b in document.documentElement.style && (c[a] = b)
                    })
                }
                var c = {};
                b("transform", ["webkitTransform", "msTransform"]);
                b("transformOrigin", ["webkitTransformOrigin"]);
                b("perspective", ["webkitPerspective"]);
                b("perspectiveOrigin", ["webkitPerspectiveOrigin"]);
                a.propertyName = function(a) {
                    return c[a] || a
                }
            }
            )(d, null)
        }
        )();
        !function() {
            if (void 0 === document.createElement("div").animate([]).oncancel) {
                var a = window.performance && performance.now ? function() {
                    return performance.now()
                }
                : function() {
                    return Date.now()
                }
                ;
                var b = function(a, b) {
                    this.target = a;
                    this.currentTime = b;
                    this.type = "cancel";
                    this.cancelable = this.bubbles = !1;
                    this.currentTarget = a;
                    this.defaultPrevented = !1;
                    this.eventPhase = Event.AT_TARGET;
                    this.timeStamp = Date.now()
                }
                  , c = window.Element.prototype.animate;
                window.Element.prototype.animate = function(d, e) {
                    d = c.call(this, d, e);
                    d._cancelHandlers = [];
                    d.oncancel = null;
                    var f = d.cancel;
                    d.cancel = function() {
                        f.call(this);
                        var c = new b(this,null,a())
                          , d = this._cancelHandlers.concat(this.oncancel ? [this.oncancel] : []);
                        setTimeout(function() {
                            d.forEach(function(a) {
                                a.call(c.target, c)
                            })
                        }, 0)
                    }
                    ;
                    var h = d.addEventListener;
                    d.addEventListener = function(a, b) {
                        "function" == typeof b && "cancel" == a ? this._cancelHandlers.push(b) : h.call(this, a, b)
                    }
                    ;
                    var k = d.removeEventListener;
                    return d.removeEventListener = function(a, b) {
                        "cancel" == a ? (a = this._cancelHandlers.indexOf(b),
                        0 <= a && this._cancelHandlers.splice(a, 1)) : k.call(this, a, b)
                    }
                    ,
                    d
                }
            }
        }();
        (function(a) {
            var b = document.documentElement
              , c = null
              , d = !1;
            try {
                var e = getComputedStyle(b).getPropertyValue("opacity");
                e = "0" == e ? "1" : "0";
                c = b.animate({
                    opacity: [e, e]
                }, {
                    duration: 1
                });
                c.currentTime = 0;
                d = getComputedStyle(b).getPropertyValue("opacity") == e
            } catch (t) {} finally {
                c && c.cancel()
            }
            if (!d) {
                var f = window.Element.prototype.animate;
                window.Element.prototype.animate = function(b, c) {
                    return window.Symbol && Symbol.iterator && Array.prototype.from && b[Symbol.iterator] && (b = Array.from(b)),
                    Array.isArray(b) || null === b || (b = a.convertToArrayForm(b)),
                    f.call(this, b, c)
                }
            }
        }
        )(c);
        !function(a, b) {
            function c(a) {
                var b = window.document.timeline;
                b.currentTime = a;
                b._discardAnimations();
                0 == b._animations.length ? e = !1 : requestAnimationFrame(c)
            }
            var d = window.requestAnimationFrame;
            window.requestAnimationFrame = function(a) {
                return d(function(b) {
                    window.document.timeline._updateAnimationsPromises();
                    a(b);
                    window.document.timeline._updateAnimationsPromises()
                })
            }
            ;
            b.AnimationTimeline = function() {
                this._animations = [];
                this.currentTime = void 0
            }
            ;
            b.AnimationTimeline.prototype = {
                getAnimations: function() {
                    return this._discardAnimations(),
                    this._animations.slice()
                },
                _updateAnimationsPromises: function() {
                    b.animationsWithPromises = b.animationsWithPromises.filter(function(a) {
                        return a._updatePromises()
                    })
                },
                _discardAnimations: function() {
                    this._updateAnimationsPromises();
                    this._animations = this._animations.filter(function(a) {
                        return "finished" != a.playState && "idle" != a.playState
                    })
                },
                _play: function(a) {
                    a = new b.Animation(a,this);
                    return this._animations.push(a),
                    b.restartWebAnimationsNextTick(),
                    a._updatePromises(),
                    a._animation.play(),
                    a._updatePromises(),
                    a
                },
                play: function(a) {
                    return a && a.remove(),
                    this._play(a)
                }
            };
            var e = !1;
            b.restartWebAnimationsNextTick = function() {
                e || (e = !0,
                requestAnimationFrame(c))
            }
            ;
            var f = new b.AnimationTimeline;
            b.timeline = f;
            try {
                Object.defineProperty(window.document, "timeline", {
                    configurable: !0,
                    get: function() {
                        return f
                    }
                })
            } catch (t) {}
            try {
                window.document.timeline = f
            } catch (t) {}
        }(c, e, null);
        (function(a, b) {
            b.animationsWithPromises = [];
            b.Animation = function(b, c) {
                if (this.id = "",
                b && b._id && (this.id = b._id),
                this.effect = b,
                b && (b._animation = this),
                !c)
                    throw Error("Animation with null timeline is not supported");
                this._timeline = c;
                this._sequenceNumber = a.sequenceNumber++;
                this._holdTime = 0;
                this._isGroup = this._paused = !1;
                this._animation = null;
                this._childAnimations = [];
                this._callback = null;
                this._oldPlayState = "idle";
                this._rebuildUnderlyingAnimation();
                this._animation.cancel();
                this._updatePromises()
            }
            ;
            b.Animation.prototype = {
                _updatePromises: function() {
                    var a = this._oldPlayState
                      , b = this.playState;
                    return this._readyPromise && b !== a && ("idle" == b ? (this._rejectReadyPromise(),
                    this._readyPromise = void 0) : "pending" == a ? this._resolveReadyPromise() : "pending" == b && (this._readyPromise = void 0)),
                    this._finishedPromise && b !== a && ("idle" == b ? (this._rejectFinishedPromise(),
                    this._finishedPromise = void 0) : "finished" == b ? this._resolveFinishedPromise() : "finished" == a && (this._finishedPromise = void 0)),
                    this._oldPlayState = this.playState,
                    this._readyPromise || this._finishedPromise
                },
                _rebuildUnderlyingAnimation: function() {
                    this._updatePromises();
                    var a, c, d, e, f = !!this._animation;
                    f && (a = this.playbackRate,
                    c = this._paused,
                    d = this.startTime,
                    e = this.currentTime,
                    this._animation.cancel(),
                    this._animation._wrapper = null,
                    this._animation = null);
                    (!this.effect || this.effect instanceof window.KeyframeEffect) && (this._animation = b.newUnderlyingAnimationForKeyframeEffect(this.effect),
                    b.bindAnimationForKeyframeEffect(this));
                    (this.effect instanceof window.SequenceEffect || this.effect instanceof window.GroupEffect) && (this._animation = b.newUnderlyingAnimationForGroup(this.effect),
                    b.bindAnimationForGroup(this));
                    this.effect && this.effect._onsample && b.bindAnimationForCustomEffect(this);
                    f && (1 != a && (this.playbackRate = a),
                    null !== d ? this.startTime = d : null !== e ? this.currentTime = e : null !== this._holdTime && (this.currentTime = this._holdTime),
                    c && this.pause());
                    this._updatePromises()
                },
                _updateChildren: function() {
                    if (this.effect && "idle" != this.playState) {
                        var a = this.effect._timing.delay;
                        this._childAnimations.forEach(function(c) {
                            this._arrangeChildren(c, a);
                            this.effect instanceof window.SequenceEffect && (a += b.groupChildDuration(c.effect))
                        }
                        .bind(this))
                    }
                },
                _setExternalAnimation: function(a) {
                    if (this.effect && this._isGroup)
                        for (var b = 0; b < this.effect.children.length; b++)
                            this.effect.children[b]._animation = a,
                            this._childAnimations[b]._setExternalAnimation(a)
                },
                _constructChildAnimations: function() {
                    if (this.effect && this._isGroup) {
                        var a = this.effect._timing.delay;
                        this._removeChildAnimations();
                        this.effect.children.forEach(function(c) {
                            var d = window.document.timeline._play(c);
                            this._childAnimations.push(d);
                            d.playbackRate = this.playbackRate;
                            this._paused && d.pause();
                            c._animation = this.effect._animation;
                            this._arrangeChildren(d, a);
                            this.effect instanceof window.SequenceEffect && (a += b.groupChildDuration(c))
                        }
                        .bind(this))
                    }
                },
                _arrangeChildren: function(a, b) {
                    null === this.startTime ? a.currentTime = this.currentTime - b / this.playbackRate : a.startTime !== this.startTime + b / this.playbackRate && (a.startTime = this.startTime + b / this.playbackRate)
                },
                get timeline() {
                    return this._timeline
                },
                get playState() {
                    return this._animation ? this._animation.playState : "idle"
                },
                get finished() {
                    return window.Promise ? (this._finishedPromise || (-1 == b.animationsWithPromises.indexOf(this) && b.animationsWithPromises.push(this),
                    this._finishedPromise = new Promise(function(a, b) {
                        this._resolveFinishedPromise = function() {
                            a(this)
                        }
                        ;
                        this._rejectFinishedPromise = function() {
                            b({
                                type: DOMException.ABORT_ERR,
                                name: "AbortError"
                            })
                        }
                    }
                    .bind(this)),
                    "finished" == this.playState && this._resolveFinishedPromise()),
                    this._finishedPromise) : (console.warn("Animation Promises require JavaScript Promise constructor"),
                    null)
                },
                get ready() {
                    return window.Promise ? (this._readyPromise || (-1 == b.animationsWithPromises.indexOf(this) && b.animationsWithPromises.push(this),
                    this._readyPromise = new Promise(function(a, b) {
                        this._resolveReadyPromise = function() {
                            a(this)
                        }
                        ;
                        this._rejectReadyPromise = function() {
                            b({
                                type: DOMException.ABORT_ERR,
                                name: "AbortError"
                            })
                        }
                    }
                    .bind(this)),
                    "pending" !== this.playState && this._resolveReadyPromise()),
                    this._readyPromise) : (console.warn("Animation Promises require JavaScript Promise constructor"),
                    null)
                },
                get onfinish() {
                    return this._animation.onfinish
                },
                set onfinish(a) {
                    "function" == typeof a ? this._animation.onfinish = function(b) {
                        b.target = this;
                        a.call(this, b)
                    }
                    .bind(this) : this._animation.onfinish = a
                },
                get oncancel() {
                    return this._animation.oncancel
                },
                set oncancel(a) {
                    "function" == typeof a ? this._animation.oncancel = function(b) {
                        b.target = this;
                        a.call(this, b)
                    }
                    .bind(this) : this._animation.oncancel = a
                },
                get currentTime() {
                    this._updatePromises();
                    var a = this._animation.currentTime;
                    return this._updatePromises(),
                    a
                },
                set currentTime(a) {
                    this._updatePromises();
                    this._animation.currentTime = isFinite(a) ? a : Math.sign(a) * Number.MAX_VALUE;
                    this._register();
                    this._forEachChild(function(b, c) {
                        b.currentTime = a - c
                    });
                    this._updatePromises()
                },
                get startTime() {
                    return this._animation.startTime
                },
                set startTime(a) {
                    this._updatePromises();
                    this._animation.startTime = isFinite(a) ? a : Math.sign(a) * Number.MAX_VALUE;
                    this._register();
                    this._forEachChild(function(b, c) {
                        b.startTime = a + c
                    });
                    this._updatePromises()
                },
                get playbackRate() {
                    return this._animation.playbackRate
                },
                set playbackRate(a) {
                    this._updatePromises();
                    var b = this.currentTime;
                    this._animation.playbackRate = a;
                    this._forEachChild(function(b) {
                        b.playbackRate = a
                    });
                    "paused" != this.playState && "idle" != this.playState && this.play();
                    null !== b && (this.currentTime = b);
                    this._updatePromises()
                },
                play: function() {
                    this._updatePromises();
                    this._paused = !1;
                    this._animation.play();
                    -1 == this._timeline._animations.indexOf(this) && this._timeline._animations.push(this);
                    this._register();
                    b.awaitStartTime(this);
                    this._forEachChild(function(a) {
                        var b = a.currentTime;
                        a.play();
                        a.currentTime = b
                    });
                    this._updatePromises()
                },
                pause: function() {
                    this._updatePromises();
                    this.currentTime && (this._holdTime = this.currentTime);
                    this._animation.pause();
                    this._register();
                    this._forEachChild(function(a) {
                        a.pause()
                    });
                    this._paused = !0;
                    this._updatePromises()
                },
                finish: function() {
                    this._updatePromises();
                    this._animation.finish();
                    this._register();
                    this._updatePromises()
                },
                cancel: function() {
                    this._updatePromises();
                    this._animation.cancel();
                    this._register();
                    this._removeChildAnimations();
                    this._updatePromises()
                },
                reverse: function() {
                    this._updatePromises();
                    var a = this.currentTime;
                    this._animation.reverse();
                    this._forEachChild(function(a) {
                        a.reverse()
                    });
                    null !== a && (this.currentTime = a);
                    this._updatePromises()
                },
                addEventListener: function(a, b) {
                    var c = b;
                    "function" == typeof b && (c = function(a) {
                        a.target = this;
                        b.call(this, a)
                    }
                    .bind(this),
                    b._wrapper = c);
                    this._animation.addEventListener(a, c)
                },
                removeEventListener: function(a, b) {
                    this._animation.removeEventListener(a, b && b._wrapper || b)
                },
                _removeChildAnimations: function() {
                    for (; this._childAnimations.length; )
                        this._childAnimations.pop().cancel()
                },
                _forEachChild: function(b) {
                    var c = 0;
                    if (this.effect.children && this._childAnimations.length < this.effect.children.length && this._constructChildAnimations(),
                    this._childAnimations.forEach(function(a) {
                        b.call(this, a, c);
                        this.effect instanceof window.SequenceEffect && (c += a.effect.activeDuration)
                    }
                    .bind(this)),
                    "pending" != this.playState) {
                        var d = this.effect._timing
                          , e = this.currentTime;
                        null !== e && (e = a.calculateTimeFraction(a.calculateActiveDuration(d), e, d));
                        (null == e || isNaN(e)) && this._removeChildAnimations()
                    }
                }
            };
            window.Animation = b.Animation
        }
        )(c, e, null);
        (function(a, b) {
            function c(b) {
                this._frames = a.normalizeKeyframes(b)
            }
            function d() {
                for (var a = !1; v.length; )
                    a = v.shift(),
                    a._updateChildren(),
                    a = !0;
                return a
            }
            var e = function(a) {
                if (a._animation = void 0,
                a instanceof window.SequenceEffect || a instanceof window.GroupEffect)
                    for (var b = 0; b < a.children.length; b++)
                        e(a.children[b])
            };
            b.removeMulti = function(a) {
                for (var b = [], c = 0; c < a.length; c++) {
                    var d = a[c];
                    d._parent ? (-1 == b.indexOf(d._parent) && b.push(d._parent),
                    d._parent.children.splice(d._parent.children.indexOf(d), 1),
                    d._parent = null,
                    e(d)) : d._animation && d._animation.effect == d && (d._animation.cancel(),
                    d._animation.effect = new KeyframeEffect(null,[]),
                    d._animation._callback && (d._animation._callback._animation = null),
                    d._animation._rebuildUnderlyingAnimation(),
                    e(d))
                }
                for (c = 0; c < b.length; c++)
                    b[c]._rebuild()
            }
            ;
            b.KeyframeEffect = function(b, d, e, f) {
                return this.target = b,
                this._parent = null,
                e = a.numericTimingToObject(e),
                this._timingInput = a.cloneTimingInput(e),
                this._timing = a.normalizeTimingInput(e),
                this.timing = a.makeTiming(e, !1, this),
                this.timing._effect = this,
                "function" == typeof d ? (a.deprecated("Custom KeyframeEffect", "2015-06-22", "Use KeyframeEffect.onsample instead."),
                this._normalizedKeyframes = d) : this._normalizedKeyframes = new c(d),
                this._keyframes = d,
                this.activeDuration = a.calculateActiveDuration(this._timing),
                this._id = f,
                this
            }
            ;
            b.KeyframeEffect.prototype = {
                getFrames: function() {
                    return "function" == typeof this._normalizedKeyframes ? this._normalizedKeyframes : this._normalizedKeyframes._frames
                },
                set onsample(a) {
                    if ("function" == typeof this.getFrames())
                        throw Error("Setting onsample on custom effect KeyframeEffect is not supported.");
                    this._onsample = a;
                    this._animation && this._animation._rebuildUnderlyingAnimation()
                },
                get parent() {
                    return this._parent
                },
                clone: function() {
                    if ("function" == typeof this.getFrames())
                        throw Error("Cloning custom effects is not supported.");
                    var b = new KeyframeEffect(this.target,[],a.cloneTimingInput(this._timingInput),this._id);
                    return b._normalizedKeyframes = this._normalizedKeyframes,
                    b._keyframes = this._keyframes,
                    b
                },
                remove: function() {
                    b.removeMulti([this])
                }
            };
            var f = Element.prototype.animate;
            Element.prototype.animate = function(a, c) {
                var d = "";
                return c && c.id && (d = c.id),
                b.timeline._play(new b.KeyframeEffect(this,a,c,d))
            }
            ;
            var l = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
            b.newUnderlyingAnimationForKeyframeEffect = function(a) {
                if (a) {
                    var b = a.target || l
                      , c = a._keyframes;
                    "function" == typeof c && (c = []);
                    var d = a._timingInput;
                    d.id = a._id
                } else
                    b = l,
                    c = [],
                    d = 0;
                return f.apply(b, [c, d])
            }
            ;
            b.bindAnimationForKeyframeEffect = function(a) {
                a.effect && "function" == typeof a.effect._normalizedKeyframes && b.bindAnimationForCustomEffect(a)
            }
            ;
            var v = [];
            b.awaitStartTime = function(a) {
                null === a.startTime && a._isGroup && (0 == v.length && requestAnimationFrame(d),
                v.push(a))
            }
            ;
            var z = window.getComputedStyle;
            Object.defineProperty(window, "getComputedStyle", {
                configurable: !0,
                enumerable: !0,
                value: function() {
                    window.document.timeline._updateAnimationsPromises();
                    var a = z.apply(this, arguments);
                    return d() && (a = z.apply(this, arguments)),
                    window.document.timeline._updateAnimationsPromises(),
                    a
                }
            });
            window.KeyframeEffect = b.KeyframeEffect;
            window.Element.prototype.getAnimations = function() {
                return document.timeline.getAnimations().filter(function(a) {
                    return null !== a.effect && a.effect.target == this
                }
                .bind(this))
            }
        }
        )(c, e, null);
        (function(a, b) {
            function c(a) {
                a._registered || (a._registered = !0,
                f.push(a),
                l || (l = !0,
                requestAnimationFrame(d)))
            }
            function d() {
                var a = f;
                f = [];
                a.sort(function(a, b) {
                    return a._sequenceNumber - b._sequenceNumber
                });
                a = a.filter(function(a) {
                    a();
                    var b = a._animation ? a._animation.playState : "idle";
                    return "running" != b && "pending" != b && (a._registered = !1),
                    a._registered
                });
                f.push.apply(f, a);
                f.length ? (l = !0,
                requestAnimationFrame(d)) : l = !1
            }
            var e = (document.createElementNS("http://www.w3.org/1999/xhtml", "div"),
            0);
            b.bindAnimationForCustomEffect = function(b) {
                var d = b.effect.target
                  , f = "function" == typeof b.effect.getFrames();
                var h = f ? b.effect.getFrames() : b.effect._onsample;
                var m = b.effect.timing
                  , l = null;
                m = a.normalizeTimingInput(m);
                var k = function() {
                    var c = k._animation ? k._animation.currentTime : null;
                    null !== c && (c = a.calculateTimeFraction(a.calculateActiveDuration(m), c, m),
                    isNaN(c) && (c = null));
                    c !== l && (f ? h(c, d, b.effect) : h(c, b.effect, b.effect._animation));
                    l = c
                };
                k._animation = b;
                k._registered = !1;
                k._sequenceNumber = e++;
                b._callback = k;
                c(k)
            }
            ;
            var f = []
              , l = !1;
            b.Animation.prototype._register = function() {
                this._callback && c(this._callback)
            }
        }
        )(c, e, null);
        (function(a, b) {
            function c(a) {
                return a._timing.delay + a.activeDuration + a._timing.endDelay
            }
            function d(b, c, d) {
                this._id = d;
                this._parent = null;
                this.children = b || [];
                this._reparent(this.children);
                c = a.numericTimingToObject(c);
                this._timingInput = a.cloneTimingInput(c);
                this._timing = a.normalizeTimingInput(c, !0);
                this.timing = a.makeTiming(c, !0, this);
                this.timing._effect = this;
                "auto" === this._timing.duration && (this._timing.duration = this.activeDuration)
            }
            window.SequenceEffect = function() {
                d.apply(this, arguments)
            }
            ;
            window.GroupEffect = function() {
                d.apply(this, arguments)
            }
            ;
            d.prototype = {
                _isAncestor: function(a) {
                    for (var b = this; null !== b; ) {
                        if (b == a)
                            return !0;
                        b = b._parent
                    }
                    return !1
                },
                _rebuild: function() {
                    for (var a = this; a; )
                        "auto" === a.timing.duration && (a._timing.duration = a.activeDuration),
                        a = a._parent;
                    this._animation && this._animation._rebuildUnderlyingAnimation()
                },
                _reparent: function(a) {
                    b.removeMulti(a);
                    for (var c = 0; c < a.length; c++)
                        a[c]._parent = this
                },
                _putChild: function(a, b) {
                    for (var c = b ? "Cannot append an ancestor or self" : "Cannot prepend an ancestor or self", d = 0; d < a.length; d++)
                        if (this._isAncestor(a[d]))
                            throw {
                                type: DOMException.HIERARCHY_REQUEST_ERR,
                                name: "HierarchyRequestError",
                                message: c
                            };
                    for (d = 0; d < a.length; d++)
                        b ? this.children.push(a[d]) : this.children.unshift(a[d]);
                    this._reparent(a);
                    this._rebuild()
                },
                append: function() {
                    this._putChild(arguments, !0)
                },
                get parent() {
                    return this._parent
                },
                get firstChild() {
                    return this.children.length ? this.children[0] : null
                },
                get lastChild() {
                    return this.children.length ? this.children[this.children.length - 1] : null
                },
                clone: function() {
                    for (var b = a.cloneTimingInput(this._timingInput), c = [], d = 0; d < this.children.length; d++)
                        c.push(this.children[d].clone());
                    return this instanceof GroupEffect ? new GroupEffect(c,b) : new SequenceEffect(c,b)
                },
                remove: function() {
                    b.removeMulti([this])
                }
            };
            window.SequenceEffect.prototype = Object.create(d.prototype);
            Object.defineProperty(window.SequenceEffect.prototype, "activeDuration", {
                get: function() {
                    var a = 0;
                    return this.children.forEach(function(b) {
                        a += c(b)
                    }),
                    Math.max(a, 0)
                }
            });
            window.GroupEffect.prototype = Object.create(d.prototype);
            Object.defineProperty(window.GroupEffect.prototype, "activeDuration", {
                get: function() {
                    var a = 0;
                    return this.children.forEach(function(b) {
                        a = Math.max(a, c(b))
                    }),
                    a
                }
            });
            b.newUnderlyingAnimationForGroup = function(c) {
                var d, e = null, f = function(b) {
                    var c = d._wrapper;
                    return c && "pending" != c.playState && c.effect ? null == b ? void c._removeChildAnimations() : 0 == b && 0 > c.playbackRate && (e || (e = a.normalizeTimingInput(c.effect.timing)),
                    b = a.calculateTimeFraction(a.calculateActiveDuration(e), -1, e),
                    isNaN(b) || null == b) ? (c._forEachChild(function(a) {
                        a.currentTime = -1
                    }),
                    void c._removeChildAnimations()) : void 0 : void 0
                };
                c = new KeyframeEffect(null,[],c._timing,c._id);
                return c.onsample = f,
                d = b.timeline._play(c)
            }
            ;
            b.bindAnimationForGroup = function(a) {
                a._animation._wrapper = a;
                a._isGroup = !0;
                b.awaitStartTime(a);
                a._constructChildAnimations();
                a._setExternalAnimation(a)
            }
            ;
            b.groupChildDuration = c
        }
        )(c, e, null);
        b["true"] = a
    }({}, function() {
        return this
    }())
}
)();
D.NeonAnimation.Animations = {};
D.NeonAnimation.Animations.FadeInAnimation = {};
Polymer({
    is: "fade-in-animation",
    behaviors: [Polymer.NeonAnimationBehavior],
    configure: function(a) {
        var b = a.node;
        return this._effect = new KeyframeEffect(b,[{
            opacity: "0"
        }, {
            opacity: "1"
        }],this.timingFromConfig(a))
    }
});
D.NeonAnimation.Animations.FadeOutAnimation = {};
Polymer({
    is: "fade-out-animation",
    behaviors: [Polymer.NeonAnimationBehavior],
    configure: function(a) {
        var b = a.node;
        return this._effect = new KeyframeEffect(b,[{
            opacity: "1"
        }, {
            opacity: "0"
        }],this.timingFromConfig(a))
    }
});
D.NeonAnimation.Animations.OpaqueAnimation = {};
Polymer({
    is: "opaque-animation",
    behaviors: [Polymer.NeonAnimationBehavior],
    configure: function(a) {
        var b = a.node;
        b.style.opacity = "0";
        return this._effect = new KeyframeEffect(b,[{
            opacity: "1"
        }, {
            opacity: "1"
        }],this.timingFromConfig(a))
    },
    complete: function(a) {
        a.node.style.opacity = ""
    }
});
D.NeonAnimation.NeonAnimatableBehavior = {};
Polymer.NeonAnimatableBehavior = {
    properties: {
        animationConfig: {
            type: Object
        },
        entryAnimation: {
            observer: "_entryAnimationChanged",
            type: String
        },
        exitAnimation: {
            observer: "_exitAnimationChanged",
            type: String
        }
    },
    _entryAnimationChanged: function() {
        this.animationConfig = this.animationConfig || {};
        this.animationConfig.entry = "fade-in-animation" !== this.entryAnimation ? [{
            name: "opaque-animation",
            node: this
        }, {
            name: this.entryAnimation,
            node: this
        }] : [{
            name: this.entryAnimation,
            node: this
        }]
    },
    _exitAnimationChanged: function() {
        this.animationConfig = this.animationConfig || {};
        this.animationConfig.exit = [{
            name: this.exitAnimation,
            node: this
        }]
    },
    _copyProperties: function(a, b) {
        for (var c in b)
            a[c] = b[c]
    },
    _cloneConfig: function(a) {
        var b = {
            isClone: !0
        };
        this._copyProperties(b, a);
        return b
    },
    _getAnimationConfigRecursive: function(a, b, c) {
        if (this.animationConfig)
            if (this.animationConfig.value && "function" === typeof this.animationConfig.value)
                this._warn(this._logf("playAnimation", "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
            else {
                var d = a ? this.animationConfig[a] : this.animationConfig;
                Array.isArray(d) || (d = [d]);
                if (d)
                    for (var e, f = 0; e = d[f]; f++)
                        if (e.animatable)
                            e.animatable._getAnimationConfigRecursive(e.type || a, b, c);
                        else if (e.id) {
                            var l = b[e.id];
                            l ? (l.isClone || (b[e.id] = this._cloneConfig(l),
                            l = b[e.id]),
                            this._copyProperties(l, e)) : b[e.id] = e
                        } else
                            c.push(e)
            }
    },
    getAnimationConfig: function(a) {
        var b = {}
          , c = [];
        this._getAnimationConfigRecursive(a, b, c);
        for (var d in b)
            c.push(b[d]);
        return c
    }
};
D.NeonAnimation.NeonAnimationRunnerBehavior = {};
Polymer.NeonAnimationRunnerBehaviorImpl = {
    properties: {
        _player: {
            type: Object
        }
    },
    _configureAnimationEffects: function(a) {
        var b = [];
        if (0 < a.length)
            for (var c, d = 0; c = a[d]; d++) {
                var e = document.createElement(c.name);
                if (e.isNeonAnimation) {
                    var f = e.configure(c);
                    f && b.push({
                        animation: e,
                        config: c,
                        effect: f
                    })
                } else
                    Polymer.Base._warn(this.is + ":", c.name, "not found!")
            }
        return b
    },
    _runAnimationEffects: function(a) {
        return document.timeline.play(new GroupEffect(a))
    },
    _completeAnimations: function(a) {
        for (var b, c = 0; b = a[c]; c++)
            b.animation.complete(b.config)
    },
    playAnimation: function(a, b) {
        if (a = this.getAnimationConfig(a)) {
            var c = this._configureAnimationEffects(a);
            a = c.map(function(a) {
                return a.effect
            });
            0 < a.length ? (this._player = this._runAnimationEffects(a),
            this._player.onfinish = function() {
                this._completeAnimations(c);
                this._player && (this._player.cancel(),
                this._player = null);
                this.fire("neon-animation-finish", b, {
                    bubbles: !1
                })
            }
            .bind(this)) : this.fire("neon-animation-finish", b, {
                bubbles: !1
            })
        }
    },
    cancelAnimation: function() {
        this._player && this._player.cancel()
    }
};
Polymer.NeonAnimationRunnerBehavior = [Polymer.NeonAnimatableBehavior, Polymer.NeonAnimationRunnerBehaviorImpl];
D.PaperTooltip = {};
D.PaperTooltip.PaperTooltip = {};
Polymer({
    is: "paper-tooltip",
    hostAttributes: {
        role: "tooltip",
        tabindex: -1
    },
    behaviors: [Polymer.NeonAnimationRunnerBehavior],
    properties: {
        for: {
            type: String,
            observer: "_findTarget"
        },
        manualMode: {
            type: Boolean,
            value: !1,
            observer: "_manualModeChanged"
        },
        position: {
            type: String,
            value: "bottom"
        },
        fitToVisibleBounds: {
            type: Boolean,
            value: !1
        },
        offset: {
            type: Number,
            value: 14
        },
        marginTop: {
            type: Number,
            value: 14
        },
        animationDelay: {
            type: Number,
            value: 500
        },
        animationConfig: {
            type: Object,
            value: function() {
                return {
                    entry: [{
                        name: "fade-in-animation",
                        node: this,
                        timing: {
                            delay: 0
                        }
                    }],
                    exit: [{
                        name: "fade-out-animation",
                        node: this
                    }]
                }
            }
        },
        _showing: {
            type: Boolean,
            value: !1
        }
    },
    listeners: {
        "neon-animation-finish": "_onAnimationFinish"
    },
    get target() {
        var a = Polymer.dom(this).parentNode
          , b = Polymer.dom(this).getOwnerRoot();
        return a = this.for ? Polymer.dom(b).querySelector("#" + this.for) : a.nodeType == Node.DOCUMENT_FRAGMENT_NODE ? b.host : a
    },
    attached: function() {
        this._findTarget()
    },
    detached: function() {
        this.manualMode || this._removeListeners()
    },
    show: function() {
        if (!this._showing) {
            if ("" === Polymer.dom(this).textContent.trim()) {
                for (var a = !0, b = Polymer.dom(this).getEffectiveChildNodes(), c = 0; c < b.length; c++)
                    if ("" !== b[c].textContent.trim()) {
                        a = !1;
                        break
                    }
                if (a)
                    return
            }
            this.cancelAnimation();
            this._showing = !0;
            this.toggleClass("hidden", !1, this.$.tooltip);
            this.updatePosition();
            this.animationConfig.entry[0].timing = this.animationConfig.entry[0].timing || {};
            this.animationConfig.entry[0].timing.delay = this.animationDelay;
            this._animationPlaying = !0;
            this.playAnimation("entry")
        }
    },
    hide: function() {
        this._showing && (this._animationPlaying ? (this.cancelAnimation(),
        this._showing = !1,
        this._onAnimationFinish()) : (this._showing = !1,
        this._animationPlaying = !0,
        this.playAnimation("exit")))
    },
    updatePosition: function() {
        if (this._target && this.offsetParent) {
            var a = this.offset;
            14 != this.marginTop && 14 == this.offset && (a = this.marginTop);
            var b = this.offsetParent.getBoundingClientRect()
              , c = this._target.getBoundingClientRect()
              , d = this.getBoundingClientRect()
              , e = (c.width - d.width) / 2
              , f = (c.height - d.height) / 2
              , l = c.left - b.left
              , h = c.top - b.top;
            switch (this.position) {
            case "top":
                var k = l + e;
                var m = h - d.height - a;
                break;
            case "bottom":
                k = l + e;
                m = h + c.height + a;
                break;
            case "left":
                k = l - d.width - a;
                m = h + f;
                break;
            case "right":
                k = l + c.width + a,
                m = h + f
            }
            this.fitToVisibleBounds ? (b.left + k + d.width > window.innerWidth ? (this.style.right = "0px",
            this.style.left = "auto") : (this.style.left = Math.max(0, k) + "px",
            this.style.right = "auto"),
            b.top + m + d.height > window.innerHeight ? (this.style.bottom = b.height + "px",
            this.style.top = "auto") : (this.style.top = Math.max(-b.top, m) + "px",
            this.style.bottom = "auto")) : (this.style.left = k + "px",
            this.style.top = m + "px")
        }
    },
    _addListeners: function() {
        this._target && (this.listen(this._target, "mouseenter", "show"),
        this.listen(this._target, "focus", "show"),
        this.listen(this._target, "mouseleave", "hide"),
        this.listen(this._target, "blur", "hide"),
        this.listen(this._target, "tap", "hide"));
        this.listen(this, "mouseenter", "hide")
    },
    _findTarget: function() {
        this.manualMode || this._removeListeners();
        this._target = this.target;
        this.manualMode || this._addListeners()
    },
    _manualModeChanged: function() {
        this.manualMode ? this._removeListeners() : this._addListeners()
    },
    _onAnimationFinish: function() {
        this._animationPlaying = !1;
        this._showing || this.toggleClass("hidden", !0, this.$.tooltip)
    },
    _removeListeners: function() {
        this._target && (this.unlisten(this._target, "mouseenter", "show"),
        this.unlisten(this._target, "focus", "show"),
        this.unlisten(this._target, "mouseleave", "hide"),
        this.unlisten(this._target, "blur", "hide"),
        this.unlisten(this._target, "tap", "hide"));
        this.unlisten(this, "mouseenter", "hide")
    }
});
D.IronJsonpLibrary = {};
D.IronJsonpLibrary.IronJsonpLibrary = {};
(function() {
    Polymer.IronJsonpLibraryBehavior = {
        properties: {
            libraryLoaded: {
                type: Boolean,
                value: !1,
                notify: !0,
                readOnly: !0
            },
            libraryErrorMessage: {
                type: String,
                value: null,
                notify: !0,
                readOnly: !0
            }
        },
        observers: ["_libraryUrlChanged(libraryUrl)"],
        _libraryUrlChanged: function() {
            this._isReady && this.libraryUrl && this._loadLibrary()
        },
        _libraryLoadCallback: function(a, b) {
            a ? (Polymer.Base._warn("Library load failed:", a.message),
            this._setLibraryErrorMessage(a.message)) : (this._setLibraryErrorMessage(null),
            this._setLibraryLoaded(!0),
            this.notifyEvent && this.fire(this.notifyEvent, b, {
                composed: !0
            }))
        },
        _loadLibrary: function() {
            a.require(this.libraryUrl, this._libraryLoadCallback.bind(this), this.callbackName)
        },
        ready: function() {
            this._isReady = !0;
            this.libraryUrl && this._loadLibrary()
        }
    };
    var a = {
        apiMap: {},
        require: function(a, d, e) {
            var c = this.nameFromUrl(a);
            this.apiMap[c] || (this.apiMap[c] = new b(c,a,e));
            this.apiMap[c].requestNotify(d)
        },
        nameFromUrl: function(a) {
            return a.replace(/[:\/%\?&\.=\-,]/g, "_") + "_api"
        }
    }
      , b = function(a, b, e) {
        this.notifiers = [];
        if (!e)
            if (0 <= b.indexOf(this.callbackMacro))
                e = a + "_loaded",
                b = b.replace(this.callbackMacro, e);
            else {
                this.error = Error("IronJsonpLibraryBehavior a %%callback%% parameter is required in libraryUrl");
                return
            }
        this.callbackName = e;
        window[this.callbackName] = this.success.bind(this);
        this.addScript(b)
    };
    b.prototype = {
        callbackMacro: "%%callback%%",
        loaded: !1,
        addScript: function(a) {
            var b = document.createElement("script");
            b.src = a;
            b.onerror = this.handleError.bind(this);
            a = document.querySelector("script") || document.body;
            a.parentNode.insertBefore(b, a)
        },
        handleError: function() {
            this.error = Error("Library failed to load");
            this.notifyAll();
            this.cleanup()
        },
        success: function() {
            this.loaded = !0;
            this.result = Array.prototype.slice.call(arguments);
            this.notifyAll();
            this.cleanup()
        },
        cleanup: function() {
            delete window[this.callbackName]
        },
        notifyAll: function() {
            this.notifiers.forEach(function(a) {
                a(this.error, this.result)
            }
            .bind(this));
            this.notifiers = []
        },
        requestNotify: function(a) {
            this.loaded || this.error ? a(this.error, this.result) : this.notifiers.push(a)
        }
    }
}
)();
Polymer({
    is: "iron-jsonp-library",
    behaviors: [Polymer.IronJsonpLibraryBehavior],
    properties: {
        libraryUrl: String,
        callbackName: String,
        notifyEvent: String
    }
});
D.GoogleApis = {};
D.GoogleApis.GoogleMapsApi = {};
Polymer({
    is: "google-maps-api",
    behaviors: [Polymer.IronJsonpLibraryBehavior],
    properties: {
        mapsUrl: {
            type: String,
            value: "https://maps.googleapis.com/maps/api/js?callback=%%callback%%"
        },
        apiKey: {
            type: String,
            value: ""
        },
        clientId: {
            type: String,
            value: ""
        },
        version: {
            type: String,
            value: "3.exp"
        },
        language: {
            type: String,
            value: ""
        },
        signedIn: {
            type: Boolean,
            value: !1
        },
        notifyEvent: {
            type: String,
            value: "api-load"
        },
        libraryUrl: {
            type: String,
            computed: "_computeUrl(mapsUrl, version, apiKey, clientId, language, signedIn)"
        }
    },
    _computeUrl: function(a, b, c, d, e, f) {
        a = a + "&v=" + b;
        a += "&libraries=drawing,geometry,places,visualization";
        c && !d && (a += "&key=" + c);
        d && (a += "&client=" + d);
        c || d || console.warn("No Google Maps API Key or Client ID specified. See https://developers.google.com/maps/documentation/javascript/get-api-key for instructions to get started with a key or client id.");
        e && (a += "&language=" + e);
        f && (a += "&signed_in=" + f);
        return a
    },
    get api() {
        return google.maps
    }
});
D.GoogleMap = {};
D.GoogleMap.GoogleMapDirections = {};
Polymer({
    is: "google-map-directions",
    properties: {
        apiKey: String,
        mapsUrl: {
            type: String
        },
        map: {
            type: Object,
            observer: "_mapChanged"
        },
        startAddress: {
            type: String,
            value: null
        },
        endAddress: {
            type: String,
            value: null
        },
        travelMode: {
            type: String,
            value: "DRIVING"
        },
        waypoints: {
            type: Array,
            value: function() {
                return []
            }
        },
        language: {
            type: String,
            value: null
        },
        rendererOptions: {
            type: Object,
            value: function() {
                return {}
            }
        },
        response: {
            type: Object,
            observer: "_responseChanged",
            notify: !0
        }
    },
    observers: ["_route(startAddress, endAddress, travelMode, waypoints.*)"],
    _mapApiLoaded: function() {
        this._route()
    },
    _responseChanged: function() {
        this.directionsRenderer && this.response && this.directionsRenderer.setDirections(this.response)
    },
    _mapChanged: function() {
        this.map && this.map instanceof google.maps.Map ? (this.directionsRenderer || (this.directionsRenderer = new google.maps.DirectionsRenderer(this.rendererOptions)),
        this.directionsRenderer.setMap(this.map),
        this._responseChanged()) : this.directionsRenderer && (this.directionsRenderer.setMap(null),
        this.directionsRenderer = null)
    },
    _route: function() {
        if ("undefined" != typeof google && "undefined" != typeof google.maps && this.startAddress && this.endAddress) {
            this.directionsService || (this.directionsService = new google.maps.DirectionsService);
            var a = {
                origin: this.startAddress,
                destination: this.endAddress,
                travelMode: this.travelMode,
                waypoints: this.waypoints
            };
            this.directionsService.route(a, function(a, c) {
                c == google.maps.DirectionsStatus.OK && (this.response = a,
                this.fire("google-map-response", {
                    response: a
                }))
            }
            .bind(this))
        }
    }
});
D.GoogleMap.GoogleMapMarker = {};
(function() {
    function a() {
        this.draggable ? this.dragHandler_ = google.maps.event.addListener(this.marker, "dragend", b.bind(this)) : (google.maps.event.removeListener(this.dragHandler_),
        this.dragHandler_ = null)
    }
    function b(a) {
        this.latitude = a.latLng.lat();
        this.longitude = a.latLng.lng()
    }
    Polymer({
        is: "google-map-marker",
        properties: {
            marker: {
                type: Object,
                notify: !0
            },
            map: {
                type: Object,
                observer: "_mapChanged"
            },
            info: {
                type: Object,
                value: null
            },
            clickEvents: {
                type: Boolean,
                value: !1,
                observer: "_clickEventsChanged"
            },
            dragEvents: {
                type: Boolean,
                value: !1,
                observer: "_dragEventsChanged"
            },
            icon: {
                type: Object,
                value: null,
                observer: "_iconChanged"
            },
            mouseEvents: {
                type: Boolean,
                value: !1,
                observer: "_mouseEventsChanged"
            },
            zIndex: {
                type: Number,
                value: 0,
                observer: "_zIndexChanged"
            },
            longitude: {
                type: Number,
                value: null,
                notify: !0
            },
            latitude: {
                type: Number,
                value: null,
                notify: !0
            },
            animation: {
                type: String,
                value: null,
                observer: "_animationChanged"
            },
            open: {
                type: Boolean,
                value: !1,
                observer: "_openChanged"
            }
        },
        observers: ["_updatePosition(latitude, longitude)"],
        detached: function() {
            this.marker && (google.maps.event.clearInstanceListeners(this.marker),
            this._listeners = {},
            this.marker.setMap(null));
            this._contentObserver && this._contentObserver.disconnect()
        },
        attached: function() {
            this.marker && this.marker.setMap(this.map)
        },
        _updatePosition: function() {
            this.marker && null != this.latitude && null != this.longitude && this.marker.setPosition(new google.maps.LatLng(parseFloat(this.latitude),parseFloat(this.longitude)))
        },
        _clickEventsChanged: function() {
            this.map && (this.clickEvents ? (this._forwardEvent("click"),
            this._forwardEvent("dblclick"),
            this._forwardEvent("rightclick")) : (this._clearListener("click"),
            this._clearListener("dblclick"),
            this._clearListener("rightclick")))
        },
        _dragEventsChanged: function() {
            this.map && (this.dragEvents ? (this._forwardEvent("drag"),
            this._forwardEvent("dragend"),
            this._forwardEvent("dragstart")) : (this._clearListener("drag"),
            this._clearListener("dragend"),
            this._clearListener("dragstart")))
        },
        _mouseEventsChanged: function() {
            this.map && (this.mouseEvents ? (this._forwardEvent("mousedown"),
            this._forwardEvent("mousemove"),
            this._forwardEvent("mouseout"),
            this._forwardEvent("mouseover"),
            this._forwardEvent("mouseup")) : (this._clearListener("mousedown"),
            this._clearListener("mousemove"),
            this._clearListener("mouseout"),
            this._clearListener("mouseover"),
            this._clearListener("mouseup")))
        },
        _animationChanged: function() {
            this.marker && this.marker.setAnimation(google.maps.Animation[this.animation])
        },
        _iconChanged: function() {
            this.marker && this.marker.setIcon(this.icon)
        },
        _zIndexChanged: function() {
            this.marker && this.marker.setZIndex(this.zIndex)
        },
        _mapChanged: function() {
            this.marker && (this.marker.setMap(null),
            google.maps.event.clearInstanceListeners(this.marker));
            this.map && this.map instanceof google.maps.Map && this._mapReady()
        },
        _contentChanged: function() {
            this._contentObserver && this._contentObserver.disconnect();
            this._contentObserver = new MutationObserver(this._contentChanged.bind(this));
            this._contentObserver.observe(this, {
                childList: !0,
                subtree: !0
            });
            var a = this.innerHTML.trim();
            a ? (this.info || (this.info = new google.maps.InfoWindow,
            this.openInfoHandler_ = google.maps.event.addListener(this.marker, "click", function() {
                this.open = !0
            }
            .bind(this)),
            this.closeInfoHandler_ = google.maps.event.addListener(this.info, "closeclick", function() {
                this.open = !1
            }
            .bind(this))),
            this.info.setContent(a)) : this.info && (google.maps.event.removeListener(this.openInfoHandler_),
            google.maps.event.removeListener(this.closeInfoHandler_),
            this.info = null)
        },
        _openChanged: function() {
            this.info && (this.open ? (this.info.open(this.map, this.marker),
            this.fire("google-map-marker-open")) : (this.info.close(),
            this.fire("google-map-marker-close")))
        },
        _mapReady: function() {
            this._listeners = {};
            this.marker = new google.maps.Marker({
                map: this.map,
                position: {
                    lat: parseFloat(this.latitude),
                    lng: parseFloat(this.longitude)
                },
                title: this.title,
                animation: google.maps.Animation[this.animation],
                draggable: this.draggable,
                visible: !this.hidden,
                icon: this.icon,
                zIndex: this.zIndex
            });
            this._contentChanged();
            this._clickEventsChanged();
            this._dragEventsChanged();
            this._mouseEventsChanged();
            this._openChanged();
            a.bind(this)()
        },
        _clearListener: function(a) {
            this._listeners[a] && (google.maps.event.removeListener(this._listeners[a]),
            this._listeners[a] = null)
        },
        _forwardEvent: function(a) {
            this._listeners[a] = google.maps.event.addListener(this.marker, a, function(b) {
                this.fire("google-map-marker-" + a, b)
            }
            .bind(this))
        },
        attributeChanged: function(b) {
            if (this.marker)
                switch (b) {
                case "hidden":
                    this.marker.setVisible(!this.hidden);
                    break;
                case "draggable":
                    this.marker.setDraggable(this.draggable);
                    a.bind(this)();
                    break;
                case "title":
                    this.marker.setTitle(this.title)
                }
        }
    })
}
)();
D.IronSelector.IronSelector = {};
Polymer({
    is: "iron-selector",
    behaviors: [Polymer.IronMultiSelectableBehavior]
});
D.GoogleMap.GoogleMap = {};
Polymer({
    is: "google-map",
    properties: {
        apiKey: String,
        mapsUrl: {
            type: String
        },
        clientId: String,
        latitude: {
            type: Number,
            value: 37.77493,
            notify: !0,
            reflectToAttribute: !0
        },
        map: {
            type: Object,
            notify: !0,
            value: null
        },
        longitude: {
            type: Number,
            value: -122.41942,
            notify: !0,
            reflectToAttribute: !0
        },
        kml: {
            type: String,
            value: null,
            observer: "_loadKml"
        },
        zoom: {
            type: Number,
            value: 10,
            observer: "_zoomChanged",
            notify: !0
        },
        noAutoTilt: {
            type: Boolean,
            value: !1
        },
        mapType: {
            type: String,
            value: "roadmap",
            observer: "_mapTypeChanged",
            notify: !0
        },
        version: {
            type: String,
            value: "3.exp"
        },
        disableDefaultUi: {
            type: Boolean,
            value: !1,
            observer: "_disableDefaultUiChanged"
        },
        disableMapTypeControl: {
            type: Boolean,
            value: !1,
            observer: "_disableMapTypeControlChanged"
        },
        disableStreetViewControl: {
            type: Boolean,
            value: !1,
            observer: "_disableStreetViewControlChanged"
        },
        fitToMarkers: {
            type: Boolean,
            value: !1,
            observer: "_fitToMarkersChanged"
        },
        disableZoom: {
            type: Boolean,
            value: !1,
            observer: "_disableZoomChanged"
        },
        styles: {
            type: Object,
            value: function() {
                return [
                    {
                        "featureType": "all",
                        "elementType": "all",
                        "stylers": [
                            {
                                "invert_lightness": true
                            },
                            {
                                "saturation": 20
                            },
                            {
                                "lightness": 50
                            },
                            {
                                "gamma": 0.4
                            },
                            {
                                "hue": "#00ffee"
                            }
                        ]
                    },
                    {
                        "featureType": "all",
                        "elementType": "geometry",
                        "stylers": [
                            {
                                "visibility": "simplified"
                            }
                        ]
                    },
                    {
                        "featureType": "all",
                        "elementType": "labels",
                        "stylers": [
                            {
                                "visibility": "on"
                            }
                        ]
                    },
                    {
                        "featureType": "administrative",
                        "elementType": "all",
                        "stylers": [
                            {
                                "color": "#ffffff"
                            },
                            {
                                "visibility": "simplified"
                            }
                        ]
                    },
                    {
                        "featureType": "administrative.land_parcel",
                        "elementType": "geometry.stroke",
                        "stylers": [
                            {
                                "visibility": "simplified"
                            }
                        ]
                    },
                    {
                        "featureType": "landscape",
                        "elementType": "all",
                        "stylers": [
                            {
                                "color": "#405769"
                            }
                        ]
                    },
                    {
                        "featureType": "water",
                        "elementType": "geometry.fill",
                        "stylers": [
                            {
                                "color": "#232f3a"
                            }
                        ]
                    }
                ]
            }
        },
        maxZoom: {
            type: Number,
            observer: "_maxZoomChanged"
        },
        minZoom: {
            type: Number,
            observer: "_minZoomChanged"
        },
        signedIn: {
            type: Boolean,
            value: !1
        },
        language: {
            type: String
        },
        clickEvents: {
            type: Boolean,
            value: !1,
            observer: "_clickEventsChanged"
        },
        dragEvents: {
            type: Boolean,
            value: !1,
            observer: "_dragEventsChanged"
        },
        mouseEvents: {
            type: Boolean,
            value: !1,
            observer: "_mouseEventsChanged"
        },
        additionalMapOptions: {
            type: Object,
            value: function() {
                return {}
            }
        },
        markers: {
            type: Array,
            value: function() {
                return []
            },
            readOnly: !0
        },
        objects: {
            type: Array,
            value: function() {
                return []
            },
            readOnly: !0
        },
        singleInfoWindow: {
            type: Boolean,
            value: !1
        }
    },
    behaviors: [Polymer.IronResizableBehavior],
    listeners: {
        "iron-resize": "resize"
    },
    observers: ["_debounceUpdateCenter(latitude, longitude)"],
    attached: function() {
        this._initGMap()
    },
    detached: function() {
        this._markersChildrenListener && (this.unlisten(this.$.selector, "items-changed", "_updateMarkers"),
        this._markersChildrenListener = null);
        this._objectsMutationObserver && (this._objectsMutationObserver.disconnect(),
        this._objectsMutationObserver = null)
    },
    _initGMap: function() {
        !this.map && !0 === this.$.api.libraryLoaded && this.isAttached && (this.map = new google.maps.Map(this.$.map,this._getMapOptions()),
        this._listeners = {},
        this._updateCenter(),
        this._loadKml(),
        this._updateMarkers(),
        this._updateObjects(),
        this._addMapListeners(),
        this.fire("google-map-ready"))
    },
    _mapApiLoaded: function() {
        this._initGMap()
    },
    _getMapOptions: function() {
        var a = {
            zoom: this.zoom,
            tilt: this.noAutoTilt ? 0 : 45,
            mapTypeId: this.mapType,
            disableDefaultUI: this.disableDefaultUi,
            mapTypeControl: !this.disableDefaultUi && !this.disableMapTypeControl,
            streetViewControl: !this.disableDefaultUi && !this.disableStreetViewControl,
            disableDoubleClickZoom: this.disableZoom,
            scrollwheel: !this.disableZoom,
            styles: this.styles,
            maxZoom: Number(this.maxZoom),
            minZoom: Number(this.minZoom)
        };
        null != this.getAttribute("draggable") && (a.draggable = this.draggable);
        for (var b in this.additionalMapOptions)
            a[b] = this.additionalMapOptions[b];
        return a
    },
    _attachChildrenToMap: function(a) {
        if (this.map)
            for (var b = 0, c; c = a[b]; ++b)
                c.map = this.map
    },
    _observeMarkers: function() {
        this._markersChildrenListener || (this._markersChildrenListener = this.listen(this.$.selector, "items-changed", "_updateMarkers"))
    },
    _updateMarkers: function() {
        var a = Array.prototype.slice.call(Polymer.dom(this.$.markers).getDistributedNodes());
        if (a.length === this.markers.length) {
            var b = a.filter(function(a) {
                return this.markers && -1 === this.markers.indexOf(a)
            }
            .bind(this));
            if (0 === b.length) {
                this._markersChildrenListener || this._observeMarkers();
                return
            }
        }
        this._observeMarkers();
        this.markers = this._setMarkers(a);
        this._attachChildrenToMap(this.markers);
        this.fitToMarkers && this._fitToMarkersChanged()
    },
    _observeObjects: function() {
        this._objectsMutationObserver || (this._objectsMutationObserver = new MutationObserver(this._updateObjects.bind(this)),
        this._objectsMutationObserver.observe(this, {
            childList: !0
        }))
    },
    _updateObjects: function() {
        var a = Array.prototype.slice.call(Polymer.dom(this.$.objects).getDistributedNodes());
        if (a.length === this.objects.length) {
            var b = a.filter(function(a) {
                return -1 === this.objects.indexOf(a)
            }
            .bind(this));
            if (0 === b.length) {
                this._observeObjects();
                return
            }
        }
        this._observeObjects();
        this._setObjects(a);
        this._attachChildrenToMap(this.objects)
    },
    clear: function() {
        for (var a = 0, b; b = this.markers[a]; ++a)
            b.marker.setMap(null)
    },
    resize: function() {
        if (this.map) {
            var a = this.latitude
              , b = this.longitude;
            google.maps.event.trigger(this.map, "resize");
            this.latitude = a;
            this.longitude = b;
            this.fitToMarkers && this._fitToMarkersChanged()
        }
    },
    _loadKml: function() {
        this.map && this.kml && new google.maps.KmlLayer({
            url: this.kml,
            map: this.map
        })
    },
    _debounceUpdateCenter: function() {
        this.debounce("updateCenter", this._updateCenter)
    },
    _updateCenter: function() {
        this.cancelDebouncer("updateCenter");
        if (this.map && void 0 !== this.latitude && void 0 !== this.longitude) {
            var a = Number(this.latitude);
            if (isNaN(a))
                throw new TypeError("latitude must be a number");
            var b = Number(this.longitude);
            if (isNaN(b))
                throw new TypeError("longitude must be a number");
            a = new google.maps.LatLng(a,b);
            (b = this.map.getCenter()) ? (b = new google.maps.LatLng(b.lat(),b.lng()),
            b.equals(a) || this.map.panTo(a)) : this.map.setCenter(a)
        }
    },
    _zoomChanged: function() {
        this.map && this.map.setZoom(Number(this.zoom))
    },
    _idleEvent: function() {
        this.map ? this._forwardEvent("idle") : this._clearListener("idle")
    },
    _clickEventsChanged: function() {
        this.map && (this.clickEvents ? (this._forwardEvent("click"),
        this._forwardEvent("dblclick"),
        this._forwardEvent("rightclick")) : (this._clearListener("click"),
        this._clearListener("dblclick"),
        this._clearListener("rightclick")))
    },
    _dragEventsChanged: function() {
        this.map && (this.dragEvents ? (this._forwardEvent("drag"),
        this._forwardEvent("dragend"),
        this._forwardEvent("dragstart")) : (this._clearListener("drag"),
        this._clearListener("dragend"),
        this._clearListener("dragstart")))
    },
    _mouseEventsChanged: function() {
        this.map && (this.mouseEvents ? (this._forwardEvent("mousemove"),
        this._forwardEvent("mouseout"),
        this._forwardEvent("mouseover")) : (this._clearListener("mousemove"),
        this._clearListener("mouseout"),
        this._clearListener("mouseover")))
    },
    _maxZoomChanged: function() {
        this.map && this.map.setOptions({
            maxZoom: Number(this.maxZoom)
        })
    },
    _minZoomChanged: function() {
        this.map && this.map.setOptions({
            minZoom: Number(this.minZoom)
        })
    },
    _mapTypeChanged: function() {
        this.map && this.map.setMapTypeId(this.mapType)
    },
    _disableDefaultUiChanged: function() {
        this.map && this.map.setOptions({
            disableDefaultUI: this.disableDefaultUi
        })
    },
    _disableMapTypeControlChanged: function() {
        this.map && this.map.setOptions({
            mapTypeControl: !this.disableMapTypeControl
        })
    },
    _disableStreetViewControlChanged: function() {
        this.map && this.map.setOptions({
            streetViewControl: !this.disableStreetViewControl
        })
    },
    _disableZoomChanged: function() {
        this.map && this.map.setOptions({
            disableDoubleClickZoom: this.disableZoom,
            scrollwheel: !this.disableZoom
        })
    },
    attributeChanged: function(a) {
        if (this.map)
            switch (a) {
            case "draggable":
                this.map.setOptions({
                    draggable: this.draggable
                })
            }
    },
    _fitToMarkersChanged: function() {
        if (this.map && this.fitToMarkers && 0 < this.markers.length) {
            for (var a = new google.maps.LatLngBounds, b = 0, c; c = this.markers[b]; ++b)
                a.extend(new google.maps.LatLng(c.latitude,c.longitude));
            1 < this.markers.length && this.map.fitBounds(a);
            this.map.setCenter(a.getCenter())
        }
    },
    _addMapListeners: function() {
        google.maps.event.addListener(this.map, "center_changed", function() {
            var a = this.map.getCenter();
            this.latitude = a.lat();
            this.longitude = a.lng()
        }
        .bind(this));
        google.maps.event.addListener(this.map, "zoom_changed", function() {
            this.zoom = this.map.getZoom()
        }
        .bind(this));
        google.maps.event.addListener(this.map, "maptypeid_changed", function() {
            this.mapType = this.map.getMapTypeId()
        }
        .bind(this));
        this._clickEventsChanged();
        this._dragEventsChanged();
        this._mouseEventsChanged();
        this._idleEvent()
    },
    _clearListener: function(a) {
        this._listeners[a] && (google.maps.event.removeListener(this._listeners[a]),
        this._listeners[a] = null)
    },
    _forwardEvent: function(a) {
        this._listeners[a] = google.maps.event.addListener(this.map, a, function(b) {
            this.fire("google-map-" + a, b)
        }
        .bind(this))
    },
    _deselectMarker: function(a) {
        var b = this.$.selector.indexOf(a.target);
        this.singleInfoWindow ? this.$.selector.selected = null : this.$.selector.selectedValues && (this.$.selector.selectedValues = this.$.selector.selectedValues.filter(function(a) {
            return a !== b
        }))
    }
});
D.GoogleMap.GoogleMapPoint = {};
Polymer({
    is: "google-map-point",
    hostAttributes: {
        hidden: !0
    },
    properties: {
        longitude: {
            type: Number,
            value: null
        },
        latitude: {
            type: Number,
            value: null
        }
    },
    getPosition: function() {
        return new google.maps.LatLng(this.latitude,this.longitude)
    }
});
D.GoogleMap.GoogleMapPoly = {};
Polymer({
    is: "google-map-poly",
    properties: {
        poly: {
            type: Object,
            readOnly: !0
        },
        path: {
            type: Object,
            readOnly: !0
        },
        map: {
            type: Object,
            observer: "_mapChanged"
        },
        clickable: {
            type: Boolean,
            value: !1,
            observer: "_clickableChanged"
        },
        clickEvents: {
            type: Boolean,
            value: !1,
            observer: "_clickEventsChanged"
        },
        closed: {
            type: Boolean,
            value: !1,
            observer: "_closedChanged"
        },
        draggable: {
            type: Boolean,
            value: !1
        },
        dragEvents: {
            type: Boolean,
            value: !1,
            observer: "_dragEventsChanged"
        },
        editable: {
            type: Boolean,
            value: !1,
            observer: "_editableChanged"
        },
        editing: {
            type: Boolean,
            value: !1,
            notify: !0,
            readOnly: !0
        },
        fillColor: {
            type: String,
            value: "",
            observer: "_fillColorChanged"
        },
        fillOpacity: {
            type: Number,
            value: 0,
            observer: "_fillOpacityChanged"
        },
        geodesic: {
            type: Boolean,
            value: !1,
            observer: "_geodesicChanged"
        },
        icons: {
            type: Array,
            value: null,
            observer: "_iconsChanged"
        },
        mouseEvents: {
            type: Boolean,
            value: !1,
            observer: "_mouseEventsChanged"
        },
        strokeColor: {
            type: String,
            value: "black",
            observer: "_strokeColorChanged"
        },
        strokeOpacity: {
            type: Number,
            value: 1,
            observer: "_strokeOpacityChanged"
        },
        strokePosition: {
            type: String,
            value: "center",
            observer: "_strokePositionChanged"
        },
        strokeWeight: {
            type: Number,
            value: 3,
            observer: "_strokeWeightChanged"
        },
        zIndex: {
            type: Number,
            value: 0,
            observer: "_zIndexChanged"
        }
    },
    detached: function() {
        this.poly.setMap(null);
        this._pointsObserver && (this._pointsObserver.disconnect(),
        this._pointsObserver = null);
        for (var a in this._listeners)
            this._clearListener(a)
    },
    attached: function() {
        this.poly && this.poly.setMap(this.map)
    },
    attributeChanged: function(a) {
        if (this.poly)
            switch (a) {
            case "hidden":
                this.poly.setVisible(!this.hidden);
                break;
            case "draggable":
                this.poly.setDraggable(this.draggable)
            }
    },
    _clickableChanged: function() {
        this.poly && this.poly.set("clickable", this.clickable)
    },
    _clickEventsChanged: function() {
        this.poly && (this.clickEvents ? (this._forwardEvent("click"),
        this._forwardEvent("dblclick"),
        this._forwardEvent("rightclick")) : (this._clearListener("click"),
        this._clearListener("dblclick"),
        this._clearListener("rightclick")))
    },
    _closedChanged: function() {
        this._mapChanged()
    },
    _dragEventsChanged: function() {
        this.poly && (this.clickEvents ? (this._forwardEvent("drag"),
        this._forwardEvent("dragend"),
        this._forwardEvent("dragstart")) : (this._clearListener("drag"),
        this._clearListener("dragend"),
        this._clearListener("dragstart")))
    },
    _editableChanged: function() {
        this.poly && this.poly.setEditable(this.editable)
    },
    _fillColorChanged: function() {
        this.poly && this.poly.set("fillColor", this.fillColor)
    },
    _fillOpacityChanged: function() {
        this.poly && this.poly.set("fillOpacity", this.fillOpacity)
    },
    _geodesicChanged: function() {
        this.poly && this.poly.set("geodesic", this.geodesic)
    },
    _iconsChanged: function() {
        this.poly && this.poly.set("icons", this.icons)
    },
    _mapChanged: function() {
        this.poly && (this.poly.setMap(null),
        google.maps.event.clearInstanceListeners(this.poly));
        this.map && this.map instanceof google.maps.Map && this._createPoly()
    },
    _mouseEventsChanged: function() {
        this.poly && (this.mouseEvents ? (this._forwardEvent("mousedown"),
        this._forwardEvent("mousemove"),
        this._forwardEvent("mouseout"),
        this._forwardEvent("mouseover"),
        this._forwardEvent("mouseup")) : (this._clearListener("mousedown"),
        this._clearListener("mousemove"),
        this._clearListener("mouseout"),
        this._clearListener("mouseover"),
        this._clearListener("mouseup")))
    },
    _strokeColorChanged: function() {
        this.poly && this.poly.set("strokeColor", this.strokeColor)
    },
    _strokeOpacityChanged: function() {
        this.poly && this.poly.set("strokeOpacity", this.strokeOpacity)
    },
    _strokePositionChanged: function() {
        this.poly && this.poly.set("strokePosition", this._convertStrokePosition())
    },
    _strokeWeightChanged: function() {
        this.poly && this.poly.set("strokeWeight", this.strokeWeight)
    },
    _zIndexChanged: function() {
        this.poly && this.poly.set("zIndex", this.zIndex)
    },
    _buildPathFromPoints: function() {
        this._points = Array.prototype.slice.call(Polymer.dom(this.$.points).getDistributedNodes());
        this._building = !0;
        this.path.clear();
        for (var a = 0, b; b = this._points[a]; ++a)
            this.path.push(b.getPosition());
        this._building = !1;
        this.fire("google-map-poly-path-built", this.path);
        this._pointsObserver || (this._pointsObserver = new MutationObserver(this._buildPathFromPoints.bind(this)),
        this._pointsObserver.observe(this, {
            childList: !0
        }))
    },
    _clearListener: function(a) {
        this._listeners[a] && (google.maps.event.removeListener(this._listeners[a]),
        this._listeners[a] = null)
    },
    _convertStrokePosition: function() {
        return google.maps.StrokePosition && this.strokePosition ? google.maps.StrokePosition[this.strokePosition.toUpperCase()] : 0
    },
    _createPoly: function() {
        this.path || (this._setPath(new google.maps.MVCArray),
        google.maps.event.addListener(this.path, "insert_at", this._startEditing.bind(this)),
        google.maps.event.addListener(this.path, "set_at", this._updatePoint.bind(this)),
        this._buildPathFromPoints());
        var a = {
            clickable: this.clickable || this.draggable,
            draggable: this.draggable,
            editable: this.editable,
            geodesic: this.geodesic,
            map: this.map,
            path: this.path,
            strokeColor: this.strokeColor,
            strokeOpacity: this.strokeOpacity,
            strokePosition: this._convertStrokePosition(),
            strokeWeight: this.strokeWeight,
            visible: !this.hidden,
            zIndex: this.zIndex
        };
        this.closed ? (a.fillColor = this.fillColor,
        a.fillOpacity = this.fillOpacity,
        this._setPoly(new google.maps.Polygon(a))) : (a.icons = this.icons,
        this._setPoly(new google.maps.Polyline(a)));
        this._listeners = {};
        this._clickEventsChanged();
        this._mouseEventsChanged();
        this._dragEventsChanged()
    },
    _forwardEvent: function(a) {
        this._listeners[a] = google.maps.event.addListener(this.poly, a, function(b) {
            this.fire("google-map-poly-" + a, b)
        }
        .bind(this))
    },
    _startEditing: function() {
        this._building || this.editing || (this._setEditing(!0),
        this._points = null,
        google.maps.event.addListenerOnce(this.map, "click", function() {
            this._setEditing(!1);
            this.fire("google-map-poly-path-updated", this.path)
        }
        .bind(this)))
    },
    _updatePoint: function(a, b) {
        this._points && (this._points[a].latitude = b.lat(),
        this._points[a].longitude = b.lng())
    }
});
D.GoogleMap.GoogleMapSearch = {};
Polymer({
    is: "google-map-search",
    properties: {
        map: {
            type: Object,
            value: null
        },
        query: {
            type: String,
            value: null
        },
        latitude: {
            type: Number,
            value: null
        },
        longitude: {
            type: Number,
            value: null
        },
        radius: {
            type: Number,
            value: null
        },
        globalSearch: {
            type: Boolean,
            value: !1
        },
        types: {
            type: String,
            value: null
        },
        results: {
            type: Array,
            value: function() {
                return []
            },
            notify: !0
        },
        location: {
            type: Object,
            value: null,
            readOnly: !0
        }
    },
    observers: ["search(query,map,location,radius,types,globalSearch)", "_updateLocation(latitude,longitude)"],
    search: function() {
        if (this.query && this.map) {
            var a = new google.maps.places.PlacesService(this.map);
            if (this.types && "string" == typeof this.types)
                var b = this.types.split(" ");
            if (this.radius)
                var c = this.radius
                  , d = this.location ? this.location : this.map.getCenter();
            else if (!this.globalSearch)
                var e = this.map.getBounds();
            a.textSearch({
                query: this.query,
                types: b,
                bounds: e,
                radius: c,
                location: d
            }, this._gotResults.bind(this))
        }
    },
    getDetails: function(a) {
        var b = new google.maps.places.PlacesService(this.map);
        return new Promise(function(c, d) {
            b.getDetails({
                placeId: a
            }, function(a, b) {
                b === google.maps.places.PlacesServiceStatus.OK ? (c(a),
                this.fire("google-map-search-place-detail", a)) : d(b)
            }
            .bind(this))
        }
        .bind(this))
    },
    _gotResults: function(a) {
        this.results = a.map(function(a) {
            a.latitude = a.geometry.location.lat();
            a.longitude = a.geometry.location.lng();
            return a
        });
        this.fire("google-map-search-results", this.results)
    },
    _updateLocation: function() {
        if (this.map) {
            if ("number" !== typeof this.latitude || isNaN(this.latitude))
                throw new TypeError("latitude must be a number");
            if ("number" !== typeof this.longitude || isNaN(this.longitude))
                throw new TypeError("longitude must be a number");
            this._setLocation({
                lat: this.latitude,
                lng: this.longitude
            })
        }
    }
});
D.GoogleMap.GoogleMapElements = {};
D.IronDropdown = {};
D.IronDropdown.IronDropdownScrollManager = {};
(function() {
    var a = {
        pageX: 0,
        pageY: 0
    }
      , b = null
      , c = [];
    Polymer.IronDropdownScrollManager = {
        get currentLockingElement() {
            return this._lockingElements[this._lockingElements.length - 1]
        },
        elementIsScrollLocked: function(a) {
            var b = this.currentLockingElement;
            if (void 0 === b)
                return !1;
            if (this._hasCachedLockedElement(a))
                return !0;
            if (this._hasCachedUnlockedElement(a))
                return !1;
            (b = !!b && b !== a && !this._composedTreeContains(b, a)) ? this._lockedElementCache.push(a) : this._unlockedElementCache.push(a);
            return b
        },
        pushScrollLock: function(a) {
            0 <= this._lockingElements.indexOf(a) || (0 === this._lockingElements.length && this._lockScrollInteractions(),
            this._lockingElements.push(a),
            this._lockedElementCache = [],
            this._unlockedElementCache = [])
        },
        removeScrollLock: function(a) {
            a = this._lockingElements.indexOf(a);
            -1 !== a && (this._lockingElements.splice(a, 1),
            this._lockedElementCache = [],
            this._unlockedElementCache = [],
            0 === this._lockingElements.length && this._unlockScrollInteractions())
        },
        _lockingElements: [],
        _lockedElementCache: null,
        _unlockedElementCache: null,
        _hasCachedLockedElement: function(a) {
            return -1 < this._lockedElementCache.indexOf(a)
        },
        _hasCachedUnlockedElement: function(a) {
            return -1 < this._unlockedElementCache.indexOf(a)
        },
        _composedTreeContains: function(a, b) {
            var c, d;
            if (a.contains(b))
                return !0;
            a = Polymer.dom(a).querySelectorAll("content");
            for (c = 0; c < a.length; ++c) {
                var e = Polymer.dom(a[c]).getDistributedNodes();
                for (d = 0; d < e.length; ++d)
                    if (this._composedTreeContains(e[d], b))
                        return !0
            }
            return !1
        },
        _scrollInteractionHandler: function(b) {
            b.cancelable && this._shouldPreventScrolling(b) && b.preventDefault();
            b.targetTouches && (b = b.targetTouches[0],
            a.pageX = b.pageX,
            a.pageY = b.pageY)
        },
        _lockScrollInteractions: function() {
            this._boundScrollHandler = this._boundScrollHandler || this._scrollInteractionHandler.bind(this);
            document.addEventListener("wheel", this._boundScrollHandler, !0);
            document.addEventListener("mousewheel", this._boundScrollHandler, !0);
            document.addEventListener("DOMMouseScroll", this._boundScrollHandler, !0);
            document.addEventListener("touchstart", this._boundScrollHandler, !0);
            document.addEventListener("touchmove", this._boundScrollHandler, !0)
        },
        _unlockScrollInteractions: function() {
            document.removeEventListener("wheel", this._boundScrollHandler, !0);
            document.removeEventListener("mousewheel", this._boundScrollHandler, !0);
            document.removeEventListener("DOMMouseScroll", this._boundScrollHandler, !0);
            document.removeEventListener("touchstart", this._boundScrollHandler, !0);
            document.removeEventListener("touchmove", this._boundScrollHandler, !0)
        },
        _shouldPreventScrolling: function(a) {
            var d = Polymer.dom(a).rootTarget;
            "touchmove" !== a.type && b !== d && (b = d,
            c = this._getScrollableNodes(Polymer.dom(a).path));
            if (!c.length)
                return !0;
            if ("touchstart" === a.type)
                return !1;
            a = this._getScrollInfo(a);
            return !this._getScrollingNode(c, a.deltaX, a.deltaY)
        },
        _getScrollableNodes: function(a) {
            for (var b = [], c = a.indexOf(this.currentLockingElement), d = 0; d <= c; d++)
                if (a[d].nodeType === Node.ELEMENT_NODE) {
                    var h = a[d]
                      , k = h.style;
                    "scroll" !== k.overflow && "auto" !== k.overflow && (k = window.getComputedStyle(h));
                    "scroll" !== k.overflow && "auto" !== k.overflow || b.push(h)
                }
            return b
        },
        _getScrollingNode: function(a, b, c) {
            if (b || c)
                for (var d = Math.abs(c) >= Math.abs(b), e = 0; e < a.length; e++) {
                    var f = a[e], m;
                    if (m = d ? 0 > c ? 0 < f.scrollTop : f.scrollTop < f.scrollHeight - f.clientHeight : 0 > b ? 0 < f.scrollLeft : f.scrollLeft < f.scrollWidth - f.clientWidth)
                        return f
                }
        },
        _getScrollInfo: function(b) {
            var c = {
                deltaX: b.deltaX,
                deltaY: b.deltaY
            };
            "deltaX"in b || ("wheelDeltaX"in b ? (c.deltaX = -b.wheelDeltaX,
            c.deltaY = -b.wheelDeltaY) : "axis"in b ? (c.deltaX = 1 === b.axis ? b.detail : 0,
            c.deltaY = 2 === b.axis ? b.detail : 0) : b.targetTouches && (b = b.targetTouches[0],
            c.deltaX = a.pageX - b.pageX,
            c.deltaY = a.pageY - b.pageY));
            return c
        }
    }
}
)();
D.IronFitBehavior = {};
D.IronFitBehavior.IronFitBehavior = {};
Polymer.IronFitBehavior = {
    properties: {
        sizingTarget: {
            type: Object,
            value: function() {
                return this
            }
        },
        fitInto: {
            type: Object,
            value: window
        },
        noOverlap: {
            type: Boolean
        },
        positionTarget: {
            type: Element
        },
        horizontalAlign: {
            type: String
        },
        verticalAlign: {
            type: String
        },
        dynamicAlign: {
            type: Boolean
        },
        horizontalOffset: {
            type: Number,
            value: 0,
            notify: !0
        },
        verticalOffset: {
            type: Number,
            value: 0,
            notify: !0
        },
        autoFitOnAttach: {
            type: Boolean,
            value: !1
        },
        _fitInfo: {
            type: Object
        }
    },
    get _fitWidth() {
        var a;
        return a = this.fitInto === window ? this.fitInto.innerWidth : this.fitInto.getBoundingClientRect().width
    },
    get _fitHeight() {
        var a;
        return a = this.fitInto === window ? this.fitInto.innerHeight : this.fitInto.getBoundingClientRect().height
    },
    get _fitLeft() {
        var a;
        return a = this.fitInto === window ? 0 : this.fitInto.getBoundingClientRect().left
    },
    get _fitTop() {
        var a;
        return a = this.fitInto === window ? 0 : this.fitInto.getBoundingClientRect().top
    },
    get _defaultPositionTarget() {
        var a = Polymer.dom(this).parentNode;
        a && a.nodeType === Node.DOCUMENT_FRAGMENT_NODE && (a = a.host);
        return a
    },
    get _localeHorizontalAlign() {
        if (this._isRTL) {
            if ("right" === this.horizontalAlign)
                return "left";
            if ("left" === this.horizontalAlign)
                return "right"
        }
        return this.horizontalAlign
    },
    attached: function() {
        "undefined" === typeof this._isRTL && (this._isRTL = "rtl" == window.getComputedStyle(this).direction);
        this.positionTarget = this.positionTarget || this._defaultPositionTarget;
        this.autoFitOnAttach && ("none" === window.getComputedStyle(this).display ? setTimeout(function() {
            this.fit()
        }
        .bind(this)) : (window.ShadyDOM && ShadyDOM.flush(),
        this.fit()))
    },
    detached: function() {
        this.__deferredFit && (clearTimeout(this.__deferredFit),
        this.__deferredFit = null)
    },
    fit: function() {
        this.position();
        this.constrain();
        this.center()
    },
    _discoverInfo: function() {
        if (!this._fitInfo) {
            var a = window.getComputedStyle(this)
              , b = window.getComputedStyle(this.sizingTarget);
            this._fitInfo = {
                inlineStyle: {
                    top: this.style.top || "",
                    left: this.style.left || "",
                    position: this.style.position || ""
                },
                sizerInlineStyle: {
                    maxWidth: this.sizingTarget.style.maxWidth || "",
                    maxHeight: this.sizingTarget.style.maxHeight || "",
                    boxSizing: this.sizingTarget.style.boxSizing || ""
                },
                positionedBy: {
                    vertically: "auto" !== a.top ? "top" : "auto" !== a.bottom ? "bottom" : null,
                    horizontally: "auto" !== a.left ? "left" : "auto" !== a.right ? "right" : null
                },
                sizedBy: {
                    height: "none" !== b.maxHeight,
                    width: "none" !== b.maxWidth,
                    minWidth: parseInt(b.minWidth, 10) || 0,
                    minHeight: parseInt(b.minHeight, 10) || 0
                },
                margin: {
                    top: parseInt(a.marginTop, 10) || 0,
                    right: parseInt(a.marginRight, 10) || 0,
                    bottom: parseInt(a.marginBottom, 10) || 0,
                    left: parseInt(a.marginLeft, 10) || 0
                }
            }
        }
    },
    resetFit: function() {
        var a = this._fitInfo || {}, b;
        for (b in a.sizerInlineStyle)
            this.sizingTarget.style[b] = a.sizerInlineStyle[b];
        for (b in a.inlineStyle)
            this.style[b] = a.inlineStyle[b];
        this._fitInfo = null
    },
    refit: function() {
        var a = this.sizingTarget.scrollLeft
          , b = this.sizingTarget.scrollTop;
        this.resetFit();
        this.fit();
        this.sizingTarget.scrollLeft = a;
        this.sizingTarget.scrollTop = b
    },
    position: function() {
        if (this.horizontalAlign || this.verticalAlign) {
            this._discoverInfo();
            this.style.position = "fixed";
            this.sizingTarget.style.boxSizing = "border-box";
            this.style.left = "0px";
            this.style.top = "0px";
            var a = this.getBoundingClientRect()
              , b = this.__getNormalizedRect(this.positionTarget)
              , c = this.__getNormalizedRect(this.fitInto)
              , d = this._fitInfo.margin
              , e = {
                width: a.width + d.left + d.right,
                height: a.height + d.top + d.bottom
            };
            e = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, e, b, c);
            b = e.left + d.left;
            e = e.top + d.top;
            var f = Math.min(c.right - d.right, b + a.width)
              , l = Math.min(c.bottom - d.bottom, e + a.height);
            b = Math.max(c.left + d.left, Math.min(b, f - this._fitInfo.sizedBy.minWidth));
            e = Math.max(c.top + d.top, Math.min(e, l - this._fitInfo.sizedBy.minHeight));
            this.sizingTarget.style.maxWidth = Math.max(f - b, this._fitInfo.sizedBy.minWidth) + "px";
            this.sizingTarget.style.maxHeight = Math.max(l - e, this._fitInfo.sizedBy.minHeight) + "px";
            this.style.left = b - a.left + "px";
            this.style.top = e - a.top + "px"
        }
    },
    constrain: function() {
        if (!this.horizontalAlign && !this.verticalAlign) {
            this._discoverInfo();
            var a = this._fitInfo;
            a.positionedBy.vertically || (this.style.position = "fixed",
            this.style.top = "0px");
            a.positionedBy.horizontally || (this.style.position = "fixed",
            this.style.left = "0px");
            this.sizingTarget.style.boxSizing = "border-box";
            var b = this.getBoundingClientRect();
            a.sizedBy.height || this.__sizeDimension(b, a.positionedBy.vertically, "top", "bottom", "Height");
            a.sizedBy.width || this.__sizeDimension(b, a.positionedBy.horizontally, "left", "right", "Width")
        }
    },
    _sizeDimension: function(a, b, c, d, e) {
        this.__sizeDimension(a, b, c, d, e)
    },
    __sizeDimension: function(a, b, c, d, e) {
        var f = this._fitInfo
          , l = this.__getNormalizedRect(this.fitInto);
        l = "Width" === e ? l.width : l.height;
        a = (b = b === d) ? l - a[d] : a[c];
        c = f.margin[b ? c : d];
        d = "offset" + e;
        d = this[d] - this.sizingTarget[d];
        this.sizingTarget.style["max" + e] = l - c - a - d + "px"
    },
    center: function() {
        if (!this.horizontalAlign && !this.verticalAlign) {
            this._discoverInfo();
            var a = this._fitInfo.positionedBy;
            if (!a.vertically || !a.horizontally) {
                this.style.position = "fixed";
                a.vertically || (this.style.top = "0px");
                a.horizontally || (this.style.left = "0px");
                var b = this.getBoundingClientRect()
                  , c = this.__getNormalizedRect(this.fitInto);
                if (!a.vertically) {
                    var d = c.top - b.top + (c.height - b.height) / 2;
                    this.style.top = d + "px"
                }
                a.horizontally || (a = c.left - b.left + (c.width - b.width) / 2,
                this.style.left = a + "px")
            }
        }
    },
    __getNormalizedRect: function(a) {
        return a === document.documentElement || a === window ? {
            top: 0,
            left: 0,
            width: window.innerWidth,
            height: window.innerHeight,
            right: window.innerWidth,
            bottom: window.innerHeight
        } : a.getBoundingClientRect()
    },
    __getCroppedArea: function(a, b, c) {
        var d = Math.min(0, a.top) + Math.min(0, c.bottom - (a.top + b.height));
        a = Math.min(0, a.left) + Math.min(0, c.right - (a.left + b.width));
        return Math.abs(d) * b.width + Math.abs(a) * b.height
    },
    __getPosition: function(a, b, c, d, e) {
        var f = [{
            verticalAlign: "top",
            horizontalAlign: "left",
            top: d.top + this.verticalOffset,
            left: d.left + this.horizontalOffset
        }, {
            verticalAlign: "top",
            horizontalAlign: "right",
            top: d.top + this.verticalOffset,
            left: d.right - c.width - this.horizontalOffset
        }, {
            verticalAlign: "bottom",
            horizontalAlign: "left",
            top: d.bottom - c.height - this.verticalOffset,
            left: d.left + this.horizontalOffset
        }, {
            verticalAlign: "bottom",
            horizontalAlign: "right",
            top: d.bottom - c.height - this.verticalOffset,
            left: d.right - c.width - this.horizontalOffset
        }];
        if (this.noOverlap) {
            for (var l = 0, h = f.length; l < h; l++) {
                var k = {}, m;
                for (m in f[l])
                    k[m] = f[l][m];
                f.push(k)
            }
            f[0].top = f[1].top += d.height;
            f[2].top = f[3].top -= d.height;
            f[4].left = f[6].left += d.width;
            f[5].left = f[7].left -= d.width
        }
        b = "auto" === b ? null : b;
        a = "auto" === a ? null : a;
        for (l = 0; l < f.length; l++) {
            d = f[l];
            if (!this.dynamicAlign && !this.noOverlap && d.verticalAlign === b && d.horizontalAlign === a) {
                var r = d;
                break
            }
            h = (!b || d.verticalAlign === b) && (!a || d.horizontalAlign === a);
            if (this.dynamicAlign || h) {
                r = r || d;
                d.croppedArea = this.__getCroppedArea(d, c, e);
                k = d.croppedArea - r.croppedArea;
                if (0 > k || 0 === k && h)
                    r = d;
                if (0 === r.croppedArea && h)
                    break
            }
        }
        return r
    }
};
D.IronOverlayBehavior = {};
D.IronOverlayBehavior.IronFocusablesHelper = {};
(function() {
    var a = Element.prototype
      , b = a.matches || a.matchesSelector || a.mozMatchesSelector || a.msMatchesSelector || a.oMatchesSelector || a.webkitMatchesSelector;
    Polymer.IronFocusablesHelper = {
        getTabbableNodes: function(a) {
            var b = [];
            return (a = this._collectTabbableNodes(a, b)) ? this._sortByTabIndex(b) : b
        },
        isFocusable: function(a) {
            return b.call(a, "input, select, textarea, button, object") ? b.call(a, ":not([disabled])") : b.call(a, "a[href], area[href], iframe, [tabindex], [contentEditable]")
        },
        isTabbable: function(a) {
            return this.isFocusable(a) && b.call(a, ':not([tabindex="-1"])') && this._isVisible(a)
        },
        _normalizedTabIndex: function(a) {
            return this.isFocusable(a) ? (a = a.getAttribute("tabindex") || 0,
            Number(a)) : -1
        },
        _collectTabbableNodes: function(a, b) {
            if (a.nodeType !== Node.ELEMENT_NODE || !this._isVisible(a))
                return !1;
            var c = a
              , d = this._normalizedTabIndex(c);
            a = 0 < d;
            0 <= d && b.push(c);
            c = "content" === c.localName || "slot" === c.localName ? Polymer.dom(c).getDistributedNodes() : Polymer.dom(c.root || c).children;
            for (d = 0; d < c.length; d++)
                a = this._collectTabbableNodes(c[d], b) || a;
            return a
        },
        _isVisible: function(a) {
            var b = a.style;
            return "hidden" !== b.visibility && "none" !== b.display ? (b = window.getComputedStyle(a),
            "hidden" !== b.visibility && "none" !== b.display) : !1
        },
        _sortByTabIndex: function(a) {
            var b = a.length;
            if (2 > b)
                return a;
            var c = Math.ceil(b / 2);
            b = this._sortByTabIndex(a.slice(0, c));
            a = this._sortByTabIndex(a.slice(c));
            return this._mergeSortByTabIndex(b, a)
        },
        _mergeSortByTabIndex: function(a, b) {
            for (var c = []; 0 < a.length && 0 < b.length; )
                this._hasLowerTabOrder(a[0], b[0]) ? c.push(b.shift()) : c.push(a.shift());
            return c.concat(a, b)
        },
        _hasLowerTabOrder: function(a, b) {
            a = Math.max(a.tabIndex, 0);
            b = Math.max(b.tabIndex, 0);
            return 0 === a || 0 === b ? b > a : a > b
        }
    }
}
)();
D.IronOverlayBehavior.IronOverlayBackdrop = {};
Polymer({
    is: "iron-overlay-backdrop",
    properties: {
        opened: {
            reflectToAttribute: !0,
            type: Boolean,
            value: !1,
            observer: "_openedChanged"
        }
    },
    listeners: {
        transitionend: "_onTransitionend"
    },
    created: function() {
        this.__openedRaf = null
    },
    attached: function() {
        this.opened && this._openedChanged(this.opened)
    },
    prepare: function() {
        this.opened && !this.parentNode && Polymer.dom(document.body).appendChild(this)
    },
    open: function() {
        this.opened = !0
    },
    close: function() {
        this.opened = !1
    },
    complete: function() {
        this.opened || this.parentNode !== document.body || Polymer.dom(this.parentNode).removeChild(this)
    },
    _onTransitionend: function(a) {
        a && a.target === this && this.complete()
    },
    _openedChanged: function(a) {
        a ? this.prepare() : (a = window.getComputedStyle(this),
        "0s" !== a.transitionDuration && 0 != a.opacity || this.complete());
        this.isAttached && (this.__openedRaf && (window.cancelAnimationFrame(this.__openedRaf),
        this.__openedRaf = null),
        this.scrollTop = this.scrollTop,
        this.__openedRaf = window.requestAnimationFrame(function() {
            this.__openedRaf = null;
            this.toggleClass("opened", this.opened)
        }
        .bind(this)))
    }
});
D.IronOverlayBehavior.IronOverlayManager = {};
Polymer.IronOverlayManagerClass = function() {
    this._overlays = [];
    this._minimumZ = 101;
    this._backdropElement = null;
    Polymer.Gestures.add(document.documentElement, "tap", function() {});
    document.addEventListener("tap", this._onCaptureClick.bind(this), !0);
    document.addEventListener("focus", this._onCaptureFocus.bind(this), !0);
    document.addEventListener("keydown", this._onCaptureKeyDown.bind(this), !0)
}
;
Polymer.IronOverlayManagerClass.prototype = {
    constructor: Polymer.IronOverlayManagerClass,
    get backdropElement() {
        this._backdropElement || (this._backdropElement = document.createElement("iron-overlay-backdrop"));
        return this._backdropElement
    },
    get deepActiveElement() {
        var a = document.activeElement;
        a && !1 !== a instanceof Element || (a = document.body);
        for (; a.root && Polymer.dom(a.root).activeElement; )
            a = Polymer.dom(a.root).activeElement;
        return a
    },
    _bringOverlayAtIndexToFront: function(a) {
        var b = this._overlays[a];
        if (b) {
            var c = this._overlays.length - 1
              , d = this._overlays[c];
            d && this._shouldBeBehindOverlay(b, d) && c--;
            if (!(a >= c)) {
                d = Math.max(this.currentOverlayZ(), this._minimumZ);
                for (this._getZ(b) <= d && this._applyOverlayZ(b, d); a < c; )
                    this._overlays[a] = this._overlays[a + 1],
                    a++;
                this._overlays[c] = b
            }
        }
    },
    addOverlay: function(a) {
        var b = this._overlays.indexOf(a);
        if (0 <= b)
            this._bringOverlayAtIndexToFront(b);
        else {
            b = this._overlays.length;
            var c = this._overlays[b - 1]
              , d = Math.max(this._getZ(c), this._minimumZ)
              , e = this._getZ(a);
            c && this._shouldBeBehindOverlay(a, c) && (this._applyOverlayZ(c, d),
            b--,
            c = this._overlays[b - 1],
            d = Math.max(this._getZ(c), this._minimumZ));
            e <= d && this._applyOverlayZ(a, d);
            this._overlays.splice(b, 0, a)
        }
        this.trackBackdrop()
    },
    removeOverlay: function(a) {
        a = this._overlays.indexOf(a);
        -1 !== a && (this._overlays.splice(a, 1),
        this.trackBackdrop())
    },
    currentOverlay: function() {
        var a = this._overlays.length - 1;
        return this._overlays[a]
    },
    currentOverlayZ: function() {
        return this._getZ(this.currentOverlay())
    },
    trackBackdrop: function() {
        var a = this._overlayWithBackdrop();
        if (a || this._backdropElement)
            this.backdropElement.style.zIndex = this._getZ(a) - 1,
            this.backdropElement.opened = !!a,
            this.backdropElement.prepare()
    },
    _overlayWithBackdrop: function() {
        for (var a = 0; a < this._overlays.length; a++)
            if (this._overlays[a].withBackdrop)
                return this._overlays[a]
    },
    _getZ: function(a) {
        var b = this._minimumZ;
        a && (a = Number(a.style.zIndex || window.getComputedStyle(a).zIndex),
        a === a && (b = a));
        return b
    },
    _setZ: function(a, b) {
        a.style.zIndex = b
    },
    _applyOverlayZ: function(a, b) {
        this._setZ(a, b + 2)
    },
    _overlayInPath: function(a) {
        a = a || [];
        for (var b = 0; b < a.length; b++)
            if (a[b]._manager === this)
                return a[b]
    },
    _onCaptureClick: function(a) {
        var b = this._overlays.length - 1;
        if (-1 !== b)
            for (var c = Polymer.dom(a).path, d; (d = this._overlays[b]) && this._overlayInPath(c) !== d; )
                if (d._onCaptureClick(a),
                d.allowClickThrough)
                    b--;
                else
                    break
    },
    _onCaptureFocus: function(a) {
        var b = this.currentOverlay();
        b && b._onCaptureFocus(a)
    },
    _onCaptureKeyDown: function(a) {
        var b = this.currentOverlay();
        b && (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(a, "esc") ? b._onCaptureEsc(a) : Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(a, "tab") && b._onCaptureTab(a))
    },
    _shouldBeBehindOverlay: function(a, b) {
        return !a.alwaysOnTop && b.alwaysOnTop
    }
};
Polymer.IronOverlayManager = new Polymer.IronOverlayManagerClass;
D.IronOverlayBehavior.IronScrollManager = {};
(function() {
    var a = {
        pageX: 0,
        pageY: 0
    }
      , b = null
      , c = []
      , d = ["wheel", "mousewheel", "DOMMouseScroll", "touchstart", "touchmove"];
    Polymer.IronScrollManager = {
        get currentLockingElement() {
            return this._lockingElements[this._lockingElements.length - 1]
        },
        elementIsScrollLocked: function(a) {
            var b = this.currentLockingElement;
            if (void 0 === b)
                return !1;
            if (this._hasCachedLockedElement(a))
                return !0;
            if (this._hasCachedUnlockedElement(a))
                return !1;
            (b = !!b && b !== a && !this._composedTreeContains(b, a)) ? this._lockedElementCache.push(a) : this._unlockedElementCache.push(a);
            return b
        },
        pushScrollLock: function(a) {
            0 <= this._lockingElements.indexOf(a) || (0 === this._lockingElements.length && this._lockScrollInteractions(),
            this._lockingElements.push(a),
            this._lockedElementCache = [],
            this._unlockedElementCache = [])
        },
        removeScrollLock: function(a) {
            a = this._lockingElements.indexOf(a);
            -1 !== a && (this._lockingElements.splice(a, 1),
            this._lockedElementCache = [],
            this._unlockedElementCache = [],
            0 === this._lockingElements.length && this._unlockScrollInteractions())
        },
        _lockingElements: [],
        _lockedElementCache: null,
        _unlockedElementCache: null,
        _hasCachedLockedElement: function(a) {
            return -1 < this._lockedElementCache.indexOf(a)
        },
        _hasCachedUnlockedElement: function(a) {
            return -1 < this._unlockedElementCache.indexOf(a)
        },
        _composedTreeContains: function(a, b) {
            var c, d;
            if (a.contains(b))
                return !0;
            a = Polymer.dom(a).querySelectorAll("content,slot");
            for (c = 0; c < a.length; ++c) {
                var e = Polymer.dom(a[c]).getDistributedNodes();
                for (d = 0; d < e.length; ++d)
                    if (e[d].nodeType === Node.ELEMENT_NODE && this._composedTreeContains(e[d], b))
                        return !0
            }
            return !1
        },
        _scrollInteractionHandler: function(b) {
            b.cancelable && this._shouldPreventScrolling(b) && b.preventDefault();
            b.targetTouches && (b = b.targetTouches[0],
            a.pageX = b.pageX,
            a.pageY = b.pageY)
        },
        _lockScrollInteractions: function() {
            this._boundScrollHandler = this._boundScrollHandler || this._scrollInteractionHandler.bind(this);
            for (var a = 0, b = d.length; a < b; a++)
                document.addEventListener(d[a], this._boundScrollHandler, {
                    capture: !0,
                    passive: !1
                })
        },
        _unlockScrollInteractions: function() {
            for (var a = 0, b = d.length; a < b; a++)
                document.removeEventListener(d[a], this._boundScrollHandler, {
                    capture: !0,
                    passive: !1
                })
        },
        _shouldPreventScrolling: function(a) {
            var d = Polymer.dom(a).rootTarget;
            "touchmove" !== a.type && b !== d && (b = d,
            c = this._getScrollableNodes(Polymer.dom(a).path));
            if (!c.length)
                return !0;
            if ("touchstart" === a.type)
                return !1;
            a = this._getScrollInfo(a);
            return !this._getScrollingNode(c, a.deltaX, a.deltaY)
        },
        _getScrollableNodes: function(a) {
            for (var b = [], c = a.indexOf(this.currentLockingElement), d = 0; d <= c; d++)
                if (a[d].nodeType === Node.ELEMENT_NODE) {
                    var e = a[d]
                      , m = e.style;
                    "scroll" !== m.overflow && "auto" !== m.overflow && (m = window.getComputedStyle(e));
                    "scroll" !== m.overflow && "auto" !== m.overflow || b.push(e)
                }
            return b
        },
        _getScrollingNode: function(a, b, c) {
            if (b || c)
                for (var d = Math.abs(c) >= Math.abs(b), e = 0; e < a.length; e++) {
                    var f = a[e], l;
                    if (l = d ? 0 > c ? 0 < f.scrollTop : f.scrollTop < f.scrollHeight - f.clientHeight : 0 > b ? 0 < f.scrollLeft : f.scrollLeft < f.scrollWidth - f.clientWidth)
                        return f
                }
        },
        _getScrollInfo: function(b) {
            var c = {
                deltaX: b.deltaX,
                deltaY: b.deltaY
            };
            "deltaX"in b || ("wheelDeltaX"in b && "wheelDeltaY"in b ? (c.deltaX = -b.wheelDeltaX,
            c.deltaY = -b.wheelDeltaY) : "wheelDelta"in b ? (c.deltaX = 0,
            c.deltaY = -b.wheelDelta) : "axis"in b ? (c.deltaX = 1 === b.axis ? b.detail : 0,
            c.deltaY = 2 === b.axis ? b.detail : 0) : b.targetTouches && (b = b.targetTouches[0],
            c.deltaX = a.pageX - b.pageX,
            c.deltaY = a.pageY - b.pageY));
            return c
        }
    }
}
)();
D.IronOverlayBehavior.IronOverlayBehavior = {};
Polymer.IronOverlayBehaviorImpl = {
    properties: {
        opened: {
            observer: "_openedChanged",
            type: Boolean,
            value: !1,
            notify: !0
        },
        canceled: {
            observer: "_canceledChanged",
            readOnly: !0,
            type: Boolean,
            value: !1
        },
        withBackdrop: {
            observer: "_withBackdropChanged",
            type: Boolean
        },
        noAutoFocus: {
            type: Boolean,
            value: !1
        },
        noCancelOnEscKey: {
            type: Boolean,
            value: !1
        },
        noCancelOnOutsideClick: {
            type: Boolean,
            value: !1
        },
        closingReason: {
            type: Object
        },
        restoreFocusOnClose: {
            type: Boolean,
            value: !1
        },
        allowClickThrough: {
            type: Boolean
        },
        alwaysOnTop: {
            type: Boolean
        },
        scrollAction: {
            type: String
        },
        _manager: {
            type: Object,
            value: Polymer.IronOverlayManager
        },
        _focusedChild: {
            type: Object
        }
    },
    listeners: {
        "iron-resize": "_onIronResize"
    },
    observers: ["__updateScrollObservers(isAttached, opened, scrollAction)"],
    get backdropElement() {
        return this._manager.backdropElement
    },
    get _focusNode() {
        return this._focusedChild || Polymer.dom(this).querySelector("[autofocus]") || this
    },
    get _focusableNodes() {
        return Polymer.IronFocusablesHelper.getTabbableNodes(this)
    },
    ready: function() {
        this.__shouldRemoveTabIndex = this.__isAnimating = !1;
        this.__firstFocusableNode = this.__lastFocusableNode = null;
        this.__rafs = {};
        this.__scrollTop = this.__scrollLeft = this.__restoreFocusNode = null;
        this.__onCaptureScroll = this.__onCaptureScroll.bind(this);
        this._ensureSetup()
    },
    attached: function() {
        this.opened && this._openedChanged(this.opened);
        this._observer = Polymer.dom(this).observeNodes(this._onNodesChange)
    },
    detached: function() {
        Polymer.dom(this).unobserveNodes(this._observer);
        this._observer = null;
        for (var a in this.__rafs)
            null !== this.__rafs[a] && cancelAnimationFrame(this.__rafs[a]);
        this.__rafs = {};
        this._manager.removeOverlay(this);
        this.__isAnimating && (this.opened ? this._finishRenderOpened() : (this._applyFocus(),
        this._finishRenderClosed()))
    },
    toggle: function() {
        this._setCanceled(!1);
        this.opened = !this.opened
    },
    open: function() {
        this._setCanceled(!1);
        this.opened = !0
    },
    close: function() {
        this._setCanceled(!1);
        this.opened = !1
    },
    cancel: function(a) {
        a = this.fire("iron-overlay-canceled", a, {
            cancelable: !0
        });
        a.defaultPrevented || (this._setCanceled(!0),
        this.opened = !1)
    },
    invalidateTabbables: function() {
        this.__firstFocusableNode = this.__lastFocusableNode = null
    },
    _ensureSetup: function() {
        this._overlaySetup || (this._overlaySetup = !0,
        this.style.outline = "none",
        this.style.display = "none")
    },
    _openedChanged: function(a) {
        a ? this.removeAttribute("aria-hidden") : this.setAttribute("aria-hidden", "true");
        this.isAttached && (this.__isAnimating = !0,
        this.__deraf("__openedChanged", this.__openedChanged))
    },
    _canceledChanged: function() {
        this.closingReason = this.closingReason || {};
        this.closingReason.canceled = this.canceled
    },
    _withBackdropChanged: function() {
        this.withBackdrop && !this.hasAttribute("tabindex") ? (this.setAttribute("tabindex", "-1"),
        this.__shouldRemoveTabIndex = !0) : this.__shouldRemoveTabIndex && (this.removeAttribute("tabindex"),
        this.__shouldRemoveTabIndex = !1);
        this.opened && this.isAttached && this._manager.trackBackdrop()
    },
    _prepareRenderOpened: function() {
        this.__restoreFocusNode = this._manager.deepActiveElement;
        this._preparePositioning();
        this.refit();
        this._finishPositioning();
        this.noAutoFocus && document.activeElement === this._focusNode && (this._focusNode.blur(),
        this.__restoreFocusNode.focus())
    },
    _renderOpened: function() {
        this._finishRenderOpened()
    },
    _renderClosed: function() {
        this._finishRenderClosed()
    },
    _finishRenderOpened: function() {
        this.notifyResize();
        this.__isAnimating = !1;
        this.fire("iron-overlay-opened")
    },
    _finishRenderClosed: function() {
        this.style.display = "none";
        this.style.zIndex = "";
        this.notifyResize();
        this.__isAnimating = !1;
        this.fire("iron-overlay-closed", this.closingReason)
    },
    _preparePositioning: function() {
        this.style.transition = this.style.webkitTransition = "none";
        this.style.transform = this.style.webkitTransform = "none";
        this.style.display = ""
    },
    _finishPositioning: function() {
        this.style.display = "none";
        this.scrollTop = this.scrollTop;
        this.style.transition = this.style.webkitTransition = "";
        this.style.transform = this.style.webkitTransform = "";
        this.style.display = "";
        this.scrollTop = this.scrollTop
    },
    _applyFocus: function() {
        if (this.opened)
            this.noAutoFocus || this._focusNode.focus();
        else {
            this._focusNode.blur();
            this._focusedChild = null;
            if (this.restoreFocusOnClose && this.__restoreFocusNode) {
                var a = this._manager.deepActiveElement;
                (a === document.body || Polymer.dom(this).deepContains(a)) && this.__restoreFocusNode.focus()
            }
            this.__restoreFocusNode = null;
            (a = this._manager.currentOverlay()) && this !== a && a._applyFocus()
        }
    },
    _onCaptureClick: function(a) {
        this.noCancelOnOutsideClick || this.cancel(a)
    },
    _onCaptureFocus: function(a) {
        if (this.withBackdrop) {
            var b = Polymer.dom(a).path;
            -1 === b.indexOf(this) ? (a.stopPropagation(),
            this._applyFocus()) : this._focusedChild = b[0]
        }
    },
    _onCaptureEsc: function(a) {
        this.noCancelOnEscKey || this.cancel(a)
    },
    _onCaptureTab: function(a) {
        if (this.withBackdrop) {
            this.__ensureFirstLastFocusables();
            var b = a.shiftKey
              , c = b ? this.__firstFocusableNode : this.__lastFocusableNode;
            b = b ? this.__lastFocusableNode : this.__firstFocusableNode;
            if (c === b)
                c = !0;
            else {
                var d = this._manager.deepActiveElement;
                c = d === c || d === this
            }
            c && (a.preventDefault(),
            this._focusedChild = b,
            this._applyFocus())
        }
    },
    _onIronResize: function() {
        this.opened && !this.__isAnimating && this.__deraf("refit", this.refit)
    },
    _onNodesChange: function() {
        this.opened && !this.__isAnimating && (this.invalidateTabbables(),
        this.notifyResize())
    },
    __ensureFirstLastFocusables: function() {
        if (!this.__firstFocusableNode || !this.__lastFocusableNode) {
            var a = this._focusableNodes;
            this.__firstFocusableNode = a[0];
            this.__lastFocusableNode = a[a.length - 1]
        }
    },
    __openedChanged: function() {
        this.opened ? (this._prepareRenderOpened(),
        this._manager.addOverlay(this),
        this._applyFocus(),
        this._renderOpened()) : (this._manager.removeOverlay(this),
        this._applyFocus(),
        this._renderClosed())
    },
    __deraf: function(a, b) {
        var c = this.__rafs;
        null !== c[a] && cancelAnimationFrame(c[a]);
        c[a] = requestAnimationFrame(function() {
            c[a] = null;
            b.call(this)
        }
        .bind(this))
    },
    __updateScrollObservers: function(a, b, c) {
        a && b && this.__isValidScrollAction(c) ? ("lock" === c && (this.__saveScrollPosition(),
        Polymer.IronScrollManager.pushScrollLock(this)),
        document.addEventListener("scroll", this.__onCaptureScroll, {
            passive: !0
        })) : (Polymer.IronScrollManager.removeScrollLock(this),
        document.removeEventListener("scroll", this.__onCaptureScroll, {
            passive: !0
        }))
    },
    __isValidScrollAction: function(a) {
        return "lock" === a || "refit" === a || "cancel" === a
    },
    __onCaptureScroll: function(a) {
        if (!this.__isAnimating)
            switch (this.scrollAction) {
            case "lock":
                this.__restoreScrollPosition();
                break;
            case "refit":
                this.__deraf("refit", this.refit);
                break;
            case "cancel":
                this.cancel(a)
            }
    },
    __saveScrollPosition: function() {
        document.scrollingElement ? (this.__scrollTop = document.scrollingElement.scrollTop,
        this.__scrollLeft = document.scrollingElement.scrollLeft) : (this.__scrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop),
        this.__scrollLeft = Math.max(document.documentElement.scrollLeft, document.body.scrollLeft))
    },
    __restoreScrollPosition: function() {
        document.scrollingElement ? (document.scrollingElement.scrollTop = this.__scrollTop,
        document.scrollingElement.scrollLeft = this.__scrollLeft) : (document.documentElement.scrollTop = document.body.scrollTop = this.__scrollTop,
        document.documentElement.scrollLeft = document.body.scrollLeft = this.__scrollLeft)
    }
};
Polymer.IronOverlayBehavior = [Polymer.IronFitBehavior, Polymer.IronResizableBehavior, Polymer.IronOverlayBehaviorImpl];
D.IronDropdown.IronDropdown = {};
Polymer({
    is: "iron-dropdown",
    behaviors: [Polymer.IronControlState, Polymer.IronA11yKeysBehavior, Polymer.IronOverlayBehavior, Polymer.NeonAnimationRunnerBehavior],
    properties: {
        horizontalAlign: {
            type: String,
            value: "left",
            reflectToAttribute: !0
        },
        verticalAlign: {
            type: String,
            value: "top",
            reflectToAttribute: !0
        },
        openAnimationConfig: {
            type: Object
        },
        closeAnimationConfig: {
            type: Object
        },
        focusTarget: {
            type: Object
        },
        noAnimations: {
            type: Boolean,
            value: !1
        },
        allowOutsideScroll: {
            type: Boolean,
            value: !1
        },
        _boundOnCaptureScroll: {
            type: Function,
            value: function() {
                return this._onCaptureScroll.bind(this)
            }
        }
    },
    listeners: {
        "neon-animation-finish": "_onNeonAnimationFinish"
    },
    observers: ["_updateOverlayPosition(positionTarget, verticalAlign, horizontalAlign, verticalOffset, horizontalOffset)"],
    get containedElement() {
        return Polymer.dom(this.$.content).getDistributedNodes()[0]
    },
    get _focusTarget() {
        return this.focusTarget || this.containedElement
    },
    ready: function() {
        this._scrollLeft = this._scrollTop = 0;
        this._refitOnScrollRAF = null
    },
    attached: function() {
        this.sizingTarget && this.sizingTarget !== this || (this.sizingTarget = this.containedElement || this)
    },
    detached: function() {
        this.cancelAnimation();
        document.removeEventListener("scroll", this._boundOnCaptureScroll);
        Polymer.IronDropdownScrollManager.removeScrollLock(this)
    },
    _openedChanged: function() {
        this.opened && this.disabled ? this.cancel() : (this.cancelAnimation(),
        this._updateAnimationConfig(),
        this._saveScrollPosition(),
        this.opened ? (document.addEventListener("scroll", this._boundOnCaptureScroll),
        !this.allowOutsideScroll && Polymer.IronDropdownScrollManager.pushScrollLock(this)) : (document.removeEventListener("scroll", this._boundOnCaptureScroll),
        Polymer.IronDropdownScrollManager.removeScrollLock(this)),
        Polymer.IronOverlayBehaviorImpl._openedChanged.apply(this, arguments))
    },
    _renderOpened: function() {
        !this.noAnimations && this.animationConfig.open ? (this.$.contentWrapper.classList.add("animating"),
        this.playAnimation("open")) : Polymer.IronOverlayBehaviorImpl._renderOpened.apply(this, arguments)
    },
    _renderClosed: function() {
        !this.noAnimations && this.animationConfig.close ? (this.$.contentWrapper.classList.add("animating"),
        this.playAnimation("close")) : Polymer.IronOverlayBehaviorImpl._renderClosed.apply(this, arguments)
    },
    _onNeonAnimationFinish: function() {
        this.$.contentWrapper.classList.remove("animating");
        this.opened ? this._finishRenderOpened() : this._finishRenderClosed()
    },
    _onCaptureScroll: function() {
        this.allowOutsideScroll ? (this._refitOnScrollRAF && window.cancelAnimationFrame(this._refitOnScrollRAF),
        this._refitOnScrollRAF = window.requestAnimationFrame(this.refit.bind(this))) : this._restoreScrollPosition()
    },
    _saveScrollPosition: function() {
        document.scrollingElement ? (this._scrollTop = document.scrollingElement.scrollTop,
        this._scrollLeft = document.scrollingElement.scrollLeft) : (this._scrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop),
        this._scrollLeft = Math.max(document.documentElement.scrollLeft, document.body.scrollLeft))
    },
    _restoreScrollPosition: function() {
        document.scrollingElement ? (document.scrollingElement.scrollTop = this._scrollTop,
        document.scrollingElement.scrollLeft = this._scrollLeft) : (document.documentElement.scrollTop = this._scrollTop,
        document.documentElement.scrollLeft = this._scrollLeft,
        document.body.scrollTop = this._scrollTop,
        document.body.scrollLeft = this._scrollLeft)
    },
    _updateAnimationConfig: function() {
        for (var a = this.containedElement, b = [].concat(this.openAnimationConfig || []).concat(this.closeAnimationConfig || []), c = 0; c < b.length; c++)
            b[c].node = a;
        this.animationConfig = {
            open: this.openAnimationConfig,
            close: this.closeAnimationConfig
        }
    },
    _updateOverlayPosition: function() {
        this.isAttached && this.notifyResize()
    },
    _applyFocus: function() {
        var a = this.focusTarget || this.containedElement;
        a && this.opened && !this.noAutoFocus ? a.focus() : Polymer.IronOverlayBehaviorImpl._applyFocus.apply(this, arguments)
    }
});
D.IronFlexLayout.IronFlexLayoutClasses = {};
Polymer({
    is: "saft-text-item",
    properties: {
        item: Object
    },
    entityClicked_: function() {
        this.fire("entity-click", {
            data: this.item.data
        })
    }
});
Polymer({
    is: "saft-text",
    properties: {
        text: String,
        ranges: {
            type: Array,
            value: function() {
                return []
            }
        },
        renderStream_: {
            type: Array,
            value: function() {
                return []
            }
        }
    },
    observers: ["inputChanged_(text, ranges.*)"],
    checkNonOverlappingReferences: function(a) {
        for (var b = 0; b < a.length - 1; b++) {
            var c = a[b]
              , d = a[b + 1];
            c = c.end;
            d = d.start;
            if (c >= d)
                return !1
        }
        return !0
    },
    getRenderStream_: function(a, b) {
        b = (b || []).slice(0);
        b = b.sort(function(a, b) {
            return a.start - b.start
        });
        this.checkNonOverlappingReferences(b) || console.error("Overlapping phrases in input.");
        for (var c = [], d = 0, e = 0; e < b.length; e++) {
            var f = b[e];
            d < f.start && c.push({
                text: a.substring(d, f.start),
                data: null
            });
            f.start < f.end && c.push({
                text: a.substring(f.start, f.end),
                color: f.color,
                index: f.index,
                data: f.data
            });
            d = f.end
        }
        d < a.length && c.push({
            text: a.substring(d),
            data: null
        });
        return c
    },
    inputChanged_: function(a, b) {
        this.renderStream_ = this.getRenderStream_(a, b.base)
    }
});
Polymer({
    is: "entity-box",
    properties: {
        index: Number,
        kindColor: String,
        name: String,
        type: String,
        metadata: Object,
        salience: Number,
        sentiment: Object,
        hideSalience: {
            type: Boolean,
            value: !1
        },
        hideWikipediaUrl: {
            type: Boolean,
            value: !1
        },
        hideSentiment: {
            type: Boolean,
            value: !1
        },
        boxHeight: {
            type: Number,
            value: 125
        }
    },
    readableIndex_: function(a) {
        return a + 1
    },
    roundFloat_: function(a) {
        return a.toFixed(2)
    },
    formatTypeText_: function(a) {
        return a.replace(/_/g, " ")
    },
    shouldShow_: function(a, b) {
        return !0 !== b && void 0 !== a && null !== a && "" != a
    }
});
Polymer({
    is: "saft-entity-view",
    properties: {
        text: String,
        entities: {
            type: Array
        },
        entityRanges_: {
            type: Array,
            computed: "computeEntityRanges_(entities.*)"
        },
        hideSalience: {
            type: Boolean,
            value: !1
        },
        hideWikipediaUrl: {
            type: Boolean,
            value: !1
        },
        hideSentiment: {
            type: Boolean,
            value: !1
        },
        boxHeight: {
            type: Number,
            value: 125
        }
    },
    computeEntityRanges_: function(a) {
        var b = this;
        a = a.base;
        var c = [];
        a.forEach(function(a, e) {
            a.mentions.forEach(function(d) {
                var f = d.text
                  , h = f.beginOffset;
                0 > h ? console.error('Unexpected negative offset for entity mention. Requests should have the "encodingType" parameter set to "UTF16" to provide the correct offsets.') : (f = h + f.content.length,
                c.push({
                    start: h,
                    end: f,
                    data: d,
                    index: e + 1,
                    color: b.getEntityTypeColor_(a.type)
                }))
            })
        });
        return c
    },
    getEntityTypeColor_: function(a) {
        switch (a) {
        case "EVENT":
            return "#b29838";
        case "PERSON":
            return "#db4437";
        case "ORGANIZATION":
            return "#0000ff";
        case "CONSUMER_GOOD":
            return "#800080";
        case "LOCATION":
            return "#008000";
        case "WORK_OF_ART":
            return "#ff8c00";
        case "OTHER":
            return "#800000";
        case "UNKNOWN":
            return "#73909c"
        }
    }
});
Polymer({
    is: "vs-app",
    CROP_HINT_RATIOS: [.8, 1, 1.2],
    ERROR_MESSAGE: "There was an error connecting to service. Please, try again!",
    VALID_IMAGE_MESSAGE: "Please upload a valid image type.",
    MAX_SIZE_MESSAGE: "Maximum size of file upload is ",
    FEATURES: "TYPE_UNSPECIFIED LANDMARK_DETECTION FACE_DETECTION LOGO_DETECTION LABEL_DETECTION DOCUMENT_TEXT_DETECTION SAFE_SEARCH_DETECTION IMAGE_PROPERTIES CROP_HINTS WEB_DETECTION".split(" "),
    UNSUPPORTED_DOC_LANGUAGES: "ja zh el he iw ko th".split(" "),
    IMAGE_TYPES: "jpeg|jpg|png|gif|bmp|tiff",
    MAX_RESULTS: 50,
    MAX_UPLOAD_SIZE_MB: 4,
    properties: {
        serviceURL: {
            type: String,
            value: "https://vision.googleapis.com/v1/images:annotate"
        },
        proxyURL: {
            type: String,
            value: "https://cxl-services.appspot.com/proxy"
        },
        currentFile: {
            type: Object,
            notify: !0
        },
        maxImageWidth: {
            type: Number,
            value: 550
        },
        maxImageHeight: {
            type: Number,
            value: 550
        },
        resultData: {
            type: Object,
            value: {}
        },
        scrollableTabsWidth: {
            type: Number,
            value: 600
        },
        showLoading: {
            type: Boolean,
            value: !1,
            notify: !0
        },
        showPreview: {
            type: Boolean,
            value: !1,
            notify: !0
        },
        showResults: {
            type: Boolean,
            value: !1,
            notify: !0
        },
        titleText: {
            type: String,
            value: "Try the API"
        },
        verified: {
            type: Boolean,
            value: !1
        }
    },
    ready: function() {
        var a = this;
        this._supportsFileUpload() ? (this.$.input.addEventListener("change", function(b) {
            b.target.value && a.readFile(b.target.files)
        }),
        "drag dragstart dragend dragover dragenter dragleave drop".split(" ").forEach(function(b) {
            a.$.dropzone.addEventListener(b, function(a) {
                a.preventDefault();
                a.stopPropagation()
            })
        }),
        ["dragover", "dragenter"].forEach(function(b) {
            a.$.dropzone.addEventListener(b, function() {
                a.$.dropzone.classList.add("hover")
            })
        }),
        ["dragleave", "dragend", "drop"].forEach(function(b) {
            a.$.dropzone.addEventListener(b, function() {
                a.$.dropzone.classList.remove("hover")
            })
        }),
        this.$.dropzone.addEventListener("drop", function(b) {
            b = b.dataTransfer.files;
            0 < b.length && a.readFile(b[0])
        }),
        this.$.next.addEventListener("tap", function() {
            return a.reset()
        }),
        this.$.exit.addEventListener("tap", function() {
            return a.reset()
        }),
        window.addEventListener("resize", function(b) {
            return a.handleResize(b)
        })) : this.remove()
    },
    readFile: function(a) {
        var b = this;
        this.showLoading = !0;
        void 0 !== a.length && (a = a[0]);
        if (null !== a && this._validateFile(a)) {
            this.currentFile = a;
            var c = new FileReader;
            c.onload = function(a) {
                b.$.image.source = a.target.result
            }
            ;
            c.onloadend = function() {
                b.$.image.source = b.$.image.resizeImageOnLoad(a);
                b.sendImage()
            }
            ;
            c.readAsDataURL(a)
        } else
            this.reset()
    },
    isFeatureSupported: function(a) {
        switch (a) {
        case "DOCUMENT_TEXT_DETECTION":
            a = window.navigator.languages;
            a = n.makeIterator(a);
            for (var b = a.next(); !b.done; b = a.next())
                if (b = b.value,
                -1 < this.UNSUPPORTED_DOC_LANGUAGES.indexOf(b))
                    return !1;
            return !0;
        default:
            return !0
        }
    },
    sendImage: function() {
        var a = this;
        this.showLoading = this.showPreview = !0;
        var b = this.$.image.source;
        this.$.image.addEventListener("vs-image-load", function() {
            a.handleResultSizes()
        });
        var c = new RegExp("^data:image\\/(" + this.IMAGE_TYPES + ");base64,");
        b = b.replace(c, "");
        c = [];
        for (var d = n.makeIterator(this.FEATURES), e = d.next(); !e.done; e = d.next())
            e = e.value,
            this.isFeatureSupported(e) && c.push({
                type: e,
                maxResults: this.MAX_RESULTS
            });
        b = JSON.stringify({
            requests: [{
                image: {
                    content: b
                },
                features: c,
                imageContext: {
                    cropHintsParams: {
                        aspectRatios: this.CROP_HINT_RATIOS
                    }
                }
            }]
        });
        c = this.proxyURL + "?url=" + encodeURIComponent(this.serviceURL);
        var f = new XMLHttpRequest;
        f.onload = function(b) {
            a.showLoading = !1;
            200 <= f.status && 400 > f.status ? (b = JSON.parse(f.responseText),
            a.handleResults(b)) : a.handleError(b)
        }
        ;
        f.onerror = function() {
            return a.handleError
        }
        ;
        f.open("POST", c, !0);
        f.send(b)
    },
    handleResults: function(a) {
        var b = this;
        "string" === typeof a && (a = JSON.parse(a));
        this.resultData = a = a.responses[0];
        this.cachedTabs || (this.cachedTabs = this.$.tabs.querySelectorAll("paper-tab[id]"));
        for (var c = !1, d = 0; d < this.cachedTabs.length; d++) {
            var e = this.cachedTabs[d]
              , f = e.id
              , l = this.$.results.children[d]
              , h = a[f];
            this.$.json.data = a;
            if ("imagePropertiesAnnotation" === f && "cropHintsAnnotation"in a) {
                h.cropHints = a.cropHintsAnnotation.cropHints;
                var k = this.$.image;
                h.cropHints.forEach(function(a, c) {
                    a.ratio = b.CROP_HINT_RATIOS[c];
                    var d = a.boundingPoly.vertices;
                    c = d[0].x || 0;
                    var e = d[0].y || 0
                      , f = d[2].x || 0;
                    d = d[2].y || 0;
                    a.imageURI = k.getCroppedDataURI(c, e, f - c, d - e)
                })
            }
            h ? (e.removeAttribute("hidden"),
            l.removeAttribute("hidden"),
            c || (this.selected = d,
            c = !0,
            this.handlePolydata(f, h)),
            l.data = h) : (e.setAttribute("hidden", !0),
            l.setAttribute("hidden", !0),
            l.data = null);
            this.$.wrapper.classList.remove("center-all");
            this.$.wrapper.classList.add("center-horizontal");
            this.showResults = !0
        }
        this.$.tabs.notifyResize();
        this.handleResultSizes()
    },
    handleError: function(a) {
        this.showLoading = !1;
        this.reset();
        window.console.error(a);
        window.alert(this.ERROR_MESSAGE)
    },
    handleResize: function() {
        var a = this.clientWidth;
        if (a) {
            var b = this.$.tabs;
            b && (b.scrollable = a < this.scrollableTabsWidth)
        }
    },
    handleResultSizes: function() {
        var a = this.$.results.querySelectorAll("vs-card > paper-card");
        a = n.makeIterator(a);
        for (var b = a.next(); !b.done; b = a.next())
            b = b.value,
            b.style.maxHeight = this.$.image.height + "px"
    },
    handlePolydata: function(a, b) {
        var c = this.$.image;
        c.clear();
        if ("faceAnnotations" === a)
            b.forEach(function(a, d) {
                c.drawPoly(a.boundingPoly.vertices);
                c.drawPoly(a.fdBoundingPoly.vertices);
                a.landmarks.forEach(function(a) {
                    c.drawPoint(a.position.x, a.position.y)
                });
                1 < b.length && (a = a.boundingPoly.vertices[0],
                c.drawText("Face " + (d + 1), a.x, a.y))
            });
        else if ("landmarkAnnotations" === a)
            b.forEach(function(a) {
                c.drawPoly(a.boundingPoly.vertices);
                var b = a.boundingPoly.vertices[0];
                c.drawText(a.description, b.x, b.y)
            });
        else if ("textAnnotations" === a)
            b.forEach(function(a, b) {
                0 < b && c.drawPoly(a.boundingPoly.vertices)
            });
        else if ("fullTextAnnotation" === a) {
            a = n.makeIterator(b.pages);
            for (var d = a.next(); !d.done; d = a.next()) {
                d = d.value;
                d = n.makeIterator(d.blocks);
                for (var e = d.next(); !e.done; e = d.next()) {
                    var f = e.value;
                    e = c.color;
                    c.color = "#2CBBFF";
                    c.drawPoly(this._expandBox(f.boundingBox.vertices, 6 * c.scale));
                    f = n.makeIterator(f.paragraphs);
                    for (var l = f.next(); !l.done; l = f.next()) {
                        l = l.value;
                        c.color = e;
                        c.drawPoly(this._expandBox(l.boundingBox.vertices, 3 * c.scale));
                        l = n.makeIterator(l.words);
                        for (var h = l.next(); !h.done; h = l.next()) {
                            var k = h.value;
                            c.color = "#FFAA0A";
                            h = k.boundingBox.vertices[2];
                            k = k.boundingBox.vertices[3];
                            c.drawLine(h.x, h.y, k.x, k.y);
                            c.color = e
                        }
                    }
                }
            }
        } else
            "logoAnnotations" === a && b.forEach(function(a) {
                c.drawPoly(a.boundingPoly.vertices);
                var b = a.boundingPoly.vertices[0];
                c.drawText(a.description, b.x, b.y)
            })
    },
    onActivate: function(a, b) {
        a = b.item.id;
        this.resultData && this.handlePolydata(a, this.resultData[a])
    },
    reset: function() {
        this.currentFile = null;
        this.resultData = {};
        this.showResults = this.showPreview = this.showLoading = !1;
        this.$.image && (this.$.image.source = "");
        this.$.imageName && (this.$.imageName.innerHTML = "");
        this.$.input && (this.$.input.value = "");
        this.$.wrapper.classList.add("center-all");
        this.$.wrapper.classList.remove("center-horizontal");
        for (var a = 0; a < this.$.results.children.length; a++)
            this.$.results.children[a].data = null
    },
    _expandBox: function(a, b) {
        var c = [{}, {}, {}, {}];
        c[0].x = a[0].x - b;
        c[0].y = a[0].y - b;
        c[1].x = a[1].x + b;
        c[1].y = a[1].y - b;
        c[2].x = a[2].x + b;
        c[2].y = a[2].y + b;
        c[3].x = a[3].x - b;
        c[3].y = a[3].y + b;
        return c
    },
    _supportsFileUpload: function() {
        var a = document.createElement("div");
        return ("draggable"in a || "ondragstart"in a && "ondrop"in a) && "FileReader"in window
    },
    _validateFile: function(a) {
        var b = new RegExp("\\/" + this.IMAGE_TYPES + "^");
        return b.test(a.type) ? !0 : (window.alert(this.VALID_IMAGE_MESSAGE),
        !1)
    }
});
Polymer({
    is: "vs-card",
    properties: {
        center: {
            type: Boolean,
            value: !1,
            notify: !0
        }
    },
    ready: function() {
        var a = this;
        this.$.card.addEventListener("mousewheel", function(b) {
            a.$.card.scrollTop -= b.wheelDeltaY;
            b.stopPropagation();
            b.stopPropagation();
            return b.returnValue = !1
        })
    }
});
Polymer({
    is: "vs-likeliness",
    SCORES: {
        UNKNOWN: {
            value: 0,
            color: "#999",
            text: "Unknown"
        },
        VERY_UNLIKELY: {
            value: 1,
            color: "#A5D6A7",
            text: "Very Unlikely"
        },
        UNLIKELY: {
            value: 2,
            color: "#81C784",
            text: "Unlikely"
        },
        POSSIBLE: {
            value: 3,
            color: "#66BB6A",
            text: "Possible"
        },
        LIKELY: {
            value: 4,
            color: "#4CAF50",
            text: "Likely"
        },
        VERY_LIKELY: {
            value: 5,
            color: "#43A047",
            text: "Very Likely"
        }
    },
    properties: {
        value: {
            type: String,
            observer: "_render"
        },
        label: {
            type: String,
            notify: !0
        },
        width: {
            type: Number,
            value: 15
        },
        height: {
            type: Number,
            value: 15
        }
    },
    _render: function(a) {
        var b = 0
          , c = "";
        if (a) {
            var d = this.SCORES[a];
            c = "repeating-linear-gradient(to right, " + d.color + ", " + d.color + " " + this.width + "px, #fff " + this.width + "px, #fff " + 2 * this.width + "px)";
            b = d.value * this.width * 2
        }
        a = this.$.bar;
        a.style.width = b + "px";
        a.style.height = this.height + "px";
        a.style.background = c;
        this.$.text.textContent = d.text
    }
});
Polymer({
    is: "vs-loading"
});
Polymer({
    is: "vs-document",
    properties: {
        data: {
            type: Object,
            notify: !0
        }
    },
    toggleSection_: function(a) {
        var b = a.currentTarget.parentElement
          , c = a.currentTarget.children[0];
        b.classList.contains("collapsed") ? (b.classList.remove("collapsed"),
        setTimeout(function() {
            return c.innerText = "+"
        }, 200)) : (b.classList.add("collapsed"),
        setTimeout(function() {
            return c.innerText = "-"
        }, 200))
    },
    increment_: function(a) {
        return a + 1
    },
    getLanguage_: function(a) {
        var b = [];
        if (a.property) {
            a = n.makeIterator(a.property.detectedLanguages);
            for (var c = a.next(); !c.done; c = a.next())
                c = c.value,
                b.push(c.languageCode.toUpperCase())
        }
        return b.join(", ")
    }
});
Polymer({
    is: "vs-faces",
    TYPES: {
        joyLikelihood: "Joy",
        sorrowLikelihood: "Sorrow",
        angerLikelihood: "Anger",
        surpriseLikelihood: "Surprise",
        underExposedLikelihood: "Exposed",
        blurredLikelihood: "Blurred",
        headwearLikelihood: "Headwear"
    },
    properties: {
        data: {
            type: Object,
            notify: !0,
            observer: "_onChange"
        }
    },
    _onChange: function(a) {
        if (a && a.length)
            for (var b = 0; b < a.length; b++) {
                var c = a[b], d = [], e;
                for (e in this.TYPES) {
                    var f = c[e];
                    d.push({
                        type: e,
                        value: f,
                        friendlyType: this.TYPES[e]
                    })
                }
                c.types = d;
                c.detectionConfidence = Math.round(100 * c.detectionConfidence);
                c.tiltAngle = Math.round(c.tiltAngle);
                c.rollAngle = Math.round(c.rollAngle);
                c.panAngle = Math.round(c.panAngle);
                c.showHeader = 1 < a.length;
                c.num = b + 1
            }
    }
});
Polymer({
    is: "vs-image",
    properties: {
        source: {
            type: String,
            notify: !0,
            observer: "_onSourceChange"
        },
        width: {
            type: Number
        },
        height: {
            type: Number
        },
        maxWidth: {
            type: Number,
            value: 550
        },
        maxHeight: {
            type: Number,
            value: 650
        },
        color: {
            type: String,
            value: "#76FF03"
        }
    },
    _onSourceChange: function(a) {
        a || (this.clear(),
        this.height = this.width = this.ctx = null,
        this.$.image.style.width = null,
        this.$.image.style.height = null,
        this.$.canvas.style.width = null,
        this.$.canvas.style.height = null)
    },
    _onImageLoad: function() {
        this.fire("vs-image-load")
    },
    resizeImageOnLoad: function(a) {
        var b = this.$.canvas
          , c = this.$.image
          , d = c.width
          , e = c.height;
        this.maxWidth && d >= e && d > this.maxWidth && (d = this.maxWidth / d,
        e *= d,
        d = this.maxWidth);
        this.maxHeight && e > d && e > this.maxHeight && (e = this.maxHeight / e,
        d *= e,
        e = this.maxHeight);
        b.width = d;
        b.height = e;
        c.style.width = d + "px";
        c.style.height = e + "px";
        this.width = d;
        this.height = e;
        this.scale = this.width / c.naturalWidth;
        this.ctx = b.getContext("2d");
        a = (a.size / 1048576).toFixed(2);
        4 < a && (this.ctx.drawImage(c, 0, 0, d, e),
        c.src = b.toDataURL("image/png"),
        this.scale = c.width / c.naturalWidth);
        return c.src
    },
    drawRect: function(a, b, c) {
        this._draw(function(d, e) {
            a *= e;
            b *= e;
            c = (c + a) * e;
            d.rect(a, b, c, c)
        })
    },
    drawCircle: function(a, b, c) {
        this._draw(function(d, e) {
            d.beginPath();
            d.arc(a * e, b * e, c, 0, 2 * Math.PI, !0);
            d.closePath();
            d.fill()
        })
    },
    drawPoint: function(a, b) {
        this.drawCircle(a, b, 2)
    },
    drawText: function(a, b, c, d, e, f) {
        "number" !== typeof d && (d = 5);
        "number" !== typeof e && (e = 20);
        this._draw(function(l, h) {
            l.font = f || "12px Arial";
            l.fillText(a, b * h + d, c * h + e)
        })
    },
    drawLine: function(a, b, c, d) {
        a = a || 0;
        b = b || 0;
        c = c || 0;
        d = d || 0;
        this._draw(function(e, f) {
            e.beginPath();
            a *= f;
            b *= f;
            c *= f;
            d *= f;
            e.moveTo(a, b);
            e.lineTo(c, d);
            e.moveTo(a - 1, b - 1);
            e.lineTo(c - 1, d - 1)
        })
    },
    drawPoly: function(a) {
        var b = this, c;
        a.forEach(function(a) {
            c && b.drawLine(c.x, c.y, a.x, a.y);
            c = a
        });
        this.drawLine(c.x, c.y, a[0].x, a[0].y)
    },
    clear: function() {
        var a = this.$.canvas;
        this.ctx.clearRect(0, 0, a.width, a.height)
    },
    _draw: function(a) {
        var b = this.ctx;
        b && (b.strokeStyle = this.color,
        b.fillStyle = this.color,
        a(b, this.scale),
        b.stroke())
    },
    getCroppedDataURI: function(a, b, c, d) {
        a *= this.scale;
        b *= this.scale;
        c *= this.scale;
        d *= this.scale;
        var e = this.$.image
          , f = document.createElement("canvas");
        f.width = e.width;
        f.height = e.height;
        f = f.getContext("2d");
        f.drawImage(e, 0, 0, this.width, this.height);
        a = f.getImageData(a, b, c, d);
        b = document.createElement("canvas");
        b.width = c;
        b.height = d;
        e = b.getContext("2d");
        e.rect(0, 0, c, d);
        e.fillStyle = "white";
        e.fill();
        e.putImageData(a, 0, 0);
        return b.toDataURL("image/png")
    }
});
Polymer({
    is: "vs-json",
    properties: {
        data: {
            type: Object,
            notify: !0,
            observer: "_displayData"
        }
    },
    onScroll: function(a) {
        this.$.wrapper.scrollTop -= a.wheelDeltaY;
        a.stopPropagation();
        return a.returnValue = !1
    },
    _displayData: function(a) {
        "string" !== typeof a && (a = JSON.stringify(a, null, 2));
        a = a.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        var b = this.localName;
        a = a.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function(a) {
            var c = "number";
            /^"/.test(a) ? c = /:$/.test(a) ? "key" : "string" : /true|false/.test(a) ? c = "boolean" : /null/.test(a) && (c = "null");
            var e = document.createElement("span");
            e.className = c + " " + b;
            e.textContent = a;
            return e.outerHTML
        });
        this.$.display.innerHTML = a
    }
});
Polymer({
    is: "vs-labels",
    properties: {
        data: {
            type: Array,
            notify: !0,
            observer: "_onChange"
        }
    },
    _onChange: function(a) {
        var b = this;
        a && a.length && a.forEach(function(a) {
            a.description = b._toTitleCase(a.description);
            a.score = Math.round(100 * a.score)
        })
    },
    _toTitleCase: function(a) {
        return a.replace(/\w\S*/g, function(a) {
            return a.charAt(0).toUpperCase() + a.substr(1).toLowerCase()
        })
    }
});
Polymer({
    is: "vs-landmarks",
    properties: {
        data: {
            type: Array,
            notify: !0,
            observer: "_onChange"
        },
        mapsApiKey: {
            type: String,
            value: "AIzaSyBOspDW8tix5pbR-b5muXP3XHCBTJYuV-A"
        }
    },
    _onChange: function(a) {
        a && a.length && a.forEach(function(a) {
            a.score = Math.round(100 * a.score);
            a.lat = a.locations[0].latLng.latitude;
            a.long = a.locations[0].latLng.longitude;
            a.latText = parseFloat(a.lat).toFixed(6);
            a.longText = parseFloat(a.long).toFixed(6)
        })
    }
});
Polymer({
    is: "vs-logos",
    properties: {
        data: {
            type: Array,
            notify: !0,
            observer: "_onChange"
        }
    },
    _onChange: function(a) {
        a && a.length && a.forEach(function(a) {
            a.score = Math.round(100 * a.score)
        })
    }
});
Polymer({
    is: "vs-properties",
    properties: {
        data: Object,
        colors: {
            type: Array,
            computed: "onChange_(data)"
        },
        cropHints: Array,
        current: Object
    },
    onChange_: function(a) {
        var b = this;
        if (a) {
            colors = a.dominantColors.colors;
            var c = 0;
            colors.forEach(function(a) {
                c += a.score
            });
            colors.forEach(function(a) {
                a.percent = a.score / c * 100;
                a.percentRounded = Math.round(a.percent);
                a.rgb = a.color.red + ", " + a.color.green + ", " + a.color.blue;
                a.hex = b.convertRGB_(a.color.red, a.color.green, a.color.blue)
            });
            a.colors = colors;
            this.current = colors[0];
            this.cropHints = a.cropHints;
            return colors
        }
    },
    onColorHover_: function(a) {
        a = a.target;
        var b = Array.prototype.slice.call(a.parentElement.children);
        a = b.indexOf(a);
        this.current = this.colors[a]
    },
    convertRGB_: function(a, b, c) {
        a = a << 16 | b << 8 | c;
        a = a.toString(16).toUpperCase();
        return a = Array(7 - a.length).join("0") + a
    }
});
Polymer({
    is: "vs-safe",
    properties: {
        data: {
            type: Object
        },
        items: {
            type: Array,
            computed: "_onChange(data)"
        },
        helpMessage: {
            type: String,
            value: "Likeliness values are Unknown, Very Unlikely, Unlikely, Possible, Likely, and Very Likely"
        }
    },
    _onChange: function(a) {
        if (a) {
            var b = [], c;
            for (c in a) {
                var d = {
                    name: this._capitalize(c),
                    score: a[c]
                };
                b.push(d)
            }
            return b
        }
    },
    _capitalize: function(a) {
        return a.charAt(0).toUpperCase() + a.slice(1)
    }
});
Polymer({
    is: "vs-web",
    properties: {
        data: {
            type: Array,
            notify: !0,
            observer: "onChange_"
        }
    },
    onChange_: function(a) {
        a && (this.processItems_(a.webEntities),
        this.processItems_(a.pagesWithMatchingImages),
        this.processItems_(a.fullMatchingImages),
        this.processItems_(a.partialMatchingImages))
    },
    processItems_: function(a) {
        if (a && a.length) {
            a = n.makeIterator(a);
            for (var b = a.next(); !b.done; b = a.next())
                b = b.value,
                b.description && (b.description = this.abbreviateDescription_(b.description)),
                b.url && (b.urlDisplay = this.abbreviateURL_(b.url)),
                b.score && (b.score = parseFloat(b.score.toFixed(5)))
        }
    },
    abbreviateDescription_: function(a) {
        32 < a.length && (a = a.substring(0, 32) + "...");
        return a
    },
    abbreviateURL_: function(a) {
        var b = document.createElement("a");
        b.href = a;
        a = b.hostname;
        25 < a.length && (a = a.slice(-25));
        return a + "/..."
    }
});
